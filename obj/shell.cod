; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\shell.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_sc_map_table DB 0180H DUP (?)
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\kernel\shell.c
_BSS	ENDS
;	COMDAT _Sc_decode_cmdline
_TEXT	SEGMENT
_Sc_decode_cmdline PROC					; COMDAT
; _cmdline$ = ecx
; _argv$ = edi

; 61   : {

  00000	56		 push	 esi

; 62   :     int                     argc        = 0;

  00001	33 c0		 xor	 eax, eax

; 63   :     int                     status      = 0;

  00003	33 f6		 xor	 esi, esi

; 64   :     char                    c           = 0;
; 65   : 
; 66   :     for( ; *cmdline && argc < SHELL_ARG_MAX; cmdline++)

  00005	38 01		 cmp	 BYTE PTR [ecx], al
  00007	74 48		 je	 SHORT $LN10@Sc_decode_
  00009	53		 push	 ebx
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL12@Sc_decode_:
  00010	83 f8 10	 cmp	 eax, 16			; 00000010H
  00013	7d 3b		 jge	 SHORT $LN19@Sc_decode_

; 67   :     {
; 68   :         c = *cmdline;

  00015	8a 19		 mov	 bl, BYTE PTR [ecx]

; 69   :         switch( status )

  00017	8b d6		 mov	 edx, esi
  00019	83 ea 00	 sub	 edx, 0
  0001c	74 16		 je	 SHORT $LN7@Sc_decode_
  0001e	83 ea 01	 sub	 edx, 1
  00021	75 25		 jne	 SHORT $LN11@Sc_decode_

; 78   :             }
; 79   :             break;
; 80   :         case 1:
; 81   :             if( c == ' ' || c == '\t' )

  00023	80 fb 20	 cmp	 bl, 32			; 00000020H
  00026	74 05		 je	 SHORT $LN1@Sc_decode_
  00028	80 fb 09	 cmp	 bl, 9
  0002b	75 1b		 jne	 SHORT $LN11@Sc_decode_
$LN1@Sc_decode_:

; 82   :             {
; 83   :                 *cmdline = 0;

  0002d	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 84   :                 status = 0;

  00030	33 f6		 xor	 esi, esi

; 85   :             }
; 86   :             break;

  00032	eb 14		 jmp	 SHORT $LN11@Sc_decode_
$LN7@Sc_decode_:

; 70   :         {
; 71   :         case 0:
; 72   :             if( c == ' ' || c == '\t' )

  00034	80 fb 20	 cmp	 bl, 32			; 00000020H
  00037	74 0f		 je	 SHORT $LN11@Sc_decode_
  00039	80 fb 09	 cmp	 bl, 9
  0003c	74 0a		 je	 SHORT $LN11@Sc_decode_

; 73   :                 break;
; 74   :             else
; 75   :             {
; 76   :                 status = 1;

  0003e	be 01 00 00 00	 mov	 esi, 1

; 77   :                 argv[argc++] = cmdline;

  00043	89 0c 87	 mov	 DWORD PTR [edi+eax*4], ecx
  00046	03 c6		 add	 eax, esi
$LN11@Sc_decode_:
  00048	83 c1 01	 add	 ecx, 1
  0004b	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0004e	75 c0		 jne	 SHORT $LL12@Sc_decode_
$LN19@Sc_decode_:
  00050	5b		 pop	 ebx
$LN10@Sc_decode_:
  00051	5e		 pop	 esi

; 87   :         }
; 88   : 
; 89   :     }
; 90   :     return argc;
; 91   : }

  00052	c3		 ret	 0
_Sc_decode_cmdline ENDP
_TEXT	ENDS
PUBLIC	_Sc_name_to_cmd
EXTRN	_Cpu_psw_set:PROC
EXTRN	__namecmp:PROC
EXTRN	_Cpu_disable_interrupt:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Sc_name_to_cmd
_TEXT	SEGMENT
_cmdname$ = 8						; size = 4
_Sc_name_to_cmd PROC					; COMDAT

; 95   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 96   :     const sc_map_t   *      scm = sc_map_table;

  00004	be 00 00 00 00	 mov	 esi, OFFSET _sc_map_table

; 97   :     int                     i   = 0;

  00009	33 ff		 xor	 edi, edi

; 98   :     CRITICAL_DECLARE(sc_lock);
; 99   : 
; 100  :     CRITICAL_BEGIN();

  0000b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00010	8b 5c 24 14	 mov	 ebx, DWORD PTR _cmdname$[esp+12]
  00014	8b e8		 mov	 ebp, eax
$LL4@Sc_name_to:

; 102  :     {
; 103  :         /*
; 104  :         if( sc->sc_entry )
; 105  :             _printf("%d %s\n",i,sc->sc_name);
; 106  :          */
; 107  : 
; 108  :         if( scm->scm_entry && _namecmp(cmdname,scm->scm_name ) == 0 )

  00016	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0001a	74 0e		 je	 SHORT $LN3@Sc_name_to
  0001c	56		 push	 esi
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 __namecmp
  00023	83 c4 08	 add	 esp, 8
  00026	85 c0		 test	 eax, eax
  00028	74 1b		 je	 SHORT $LN11@Sc_name_to
$LN3@Sc_name_to:

; 101  :     for( ; i < SHELL_CMD_MAX ; i++, scm++)

  0002a	83 c7 01	 add	 edi, 1
  0002d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00030	83 ff 20	 cmp	 edi, 32			; 00000020H
  00033	7c e1		 jl	 SHORT $LL4@Sc_name_to

; 112  :         }
; 113  :     }
; 114  :     CRITICAL_END();

  00035	55		 push	 ebp
  00036	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003b	83 c4 04	 add	 esp, 4
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5d		 pop	 ebp

; 115  : 
; 116  :     return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	5b		 pop	 ebx

; 117  : }

  00044	c3		 ret	 0
$LN11@Sc_name_to:

; 109  :         {
; 110  :             CRITICAL_END();

  00045	55		 push	 ebp
  00046	e8 00 00 00 00	 call	 _Cpu_psw_set

; 111  :             return scm->scm_entry;

  0004b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004e	83 c4 04	 add	 esp, 4
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	5b		 pop	 ebx

; 117  : }

  00055	c3		 ret	 0
_Sc_name_to_cmd ENDP
_TEXT	ENDS
PUBLIC	_Sc_get_param
; Function compile flags: /Ogtpy
;	COMDAT _Sc_get_param
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_param$ = 16						; size = 1
_Sc_get_param PROC					; COMDAT

; 122  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 123  :     int                     i       = 0;
; 124  : 
; 125  :     for( ; i < argc ; i++)

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _argc$[esp+8]
  00007	33 d2		 xor	 edx, edx
  00009	85 ff		 test	 edi, edi
  0000b	7e 21		 jle	 SHORT $LN4@Sc_get_par
  0000d	8a 5c 24 18	 mov	 bl, BYTE PTR _param$[esp+8]
  00011	8b 74 24 14	 mov	 esi, DWORD PTR _argv$[esp+8]
$LL6@Sc_get_par:

; 126  :     {
; 127  :         if( argv[i][0] == '-' || '/' == argv[i][0] )

  00015	8b 0c 96	 mov	 ecx, DWORD PTR [esi+edx*4]
  00018	8a 01		 mov	 al, BYTE PTR [ecx]
  0001a	3c 2d		 cmp	 al, 45			; 0000002dH
  0001c	74 04		 je	 SHORT $LN2@Sc_get_par
  0001e	3c 2f		 cmp	 al, 47			; 0000002fH
  00020	75 05		 jne	 SHORT $LN5@Sc_get_par
$LN2@Sc_get_par:

; 128  :         {
; 129  :             if( param == argv[i][1] )

  00022	3a 59 01	 cmp	 bl, BYTE PTR [ecx+1]
  00025	74 0d		 je	 SHORT $LN10@Sc_get_par
$LN5@Sc_get_par:

; 123  :     int                     i       = 0;
; 124  : 
; 125  :     for( ; i < argc ; i++)

  00027	83 c2 01	 add	 edx, 1
  0002a	3b d7		 cmp	 edx, edi
  0002c	7c e7		 jl	 SHORT $LL6@Sc_get_par
$LN4@Sc_get_par:
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 131  :         }
; 132  :     }
; 133  : 
; 134  :     return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 135  : }

  00033	c3		 ret	 0
$LN10@Sc_get_par:
  00034	5f		 pop	 edi

; 130  :                 return argv[i] + 2;

  00035	8b c1		 mov	 eax, ecx
  00037	5e		 pop	 esi
  00038	83 c0 02	 add	 eax, 2
  0003b	5b		 pop	 ebx

; 135  : }

  0003c	c3		 ret	 0
_Sc_get_param ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@EMOFBOHO@?6bad?5or?5unkown?5command?6?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_09HADENOPA@?6Lenix?3?5?$DO?$AA@		; `string'
EXTRN	_Tty_read:PROC
EXTRN	__printf:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_cmdline DB	0b4H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BI@EMOFBOHO@?6bad?5or?5unkown?5command?6?$AA@
CONST	SEGMENT
??_C@_0BI@EMOFBOHO@?6bad?5or?5unkown?5command?6?$AA@ DB 0aH, 'bad or unko'
	DB	'wn command', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09HADENOPA@?6Lenix?3?5?$DO?$AA@
CONST	SEGMENT
??_C@_09HADENOPA@?6Lenix?3?5?$DO?$AA@ DB 0aH, 'Lenix: >', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Lenix_shell
_TEXT	SEGMENT
_argv$ = -64						; size = 64
_param$ = 8						; size = 4
_Lenix_shell PROC					; COMDAT

; 139  : {

  00000	83 ec 40	 sub	 esp, 64			; 00000040H
  00003	56		 push	 esi
  00004	57		 push	 edi

; 140  :     int                     len         = 0;
; 141  :     int                     argc        = 0;
; 142  :     char                *   argv[16]    = { NULL };

  00005	6a 3c		 push	 60			; 0000003cH
  00007	8d 44 24 10	 lea	 eax, DWORD PTR _argv$[esp+80]
  0000b	6a 00		 push	 0
  0000d	50		 push	 eax
  0000e	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _argv$[esp+84], 0
  00016	e8 00 00 00 00	 call	 _memset
$LN9@Lenix_shel:
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001e	8b ff		 npad	 2
$LL5@Lenix_shel:

; 143  :     sc_entry_t              entry       = NULL;
; 144  : 
; 145  :     param = param;
; 146  : 
; 147  :     for(;;)
; 148  :     {
; 149  :         _printf("\nLenix: >");                                /*  显示命令提示符        */

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_09HADENOPA@?6Lenix?3?5?$DO?$AA@
  00025	e8 00 00 00 00	 call	 __printf

; 150  :         len = Tty_read(TTY_MAJOR,cmdline,SHELL_CMD_SIZE - 1); /*  输入命令行            */

  0002a	68 b3 00 00 00	 push	 179			; 000000b3H
  0002f	68 00 00 00 00	 push	 OFFSET _cmdline
  00034	6a 00		 push	 0
  00036	e8 00 00 00 00	 call	 _Tty_read

; 151  :         cmdline[len] = 0;                                     /*  确保命令行末尾是0结尾 */
; 152  : 
; 153  : #ifdef _CFG_DEBUG_
; 154  :         /*
; 155  :          *  输出命令查看，调试用
; 156  :          */
; 157  :         _printf("\n");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00040	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _cmdline[eax], 0
  00047	e8 00 00 00 00	 call	 __printf

; 158  :         _printf(cmdline);

  0004c	68 00 00 00 00	 push	 OFFSET _cmdline
  00051	e8 00 00 00 00	 call	 __printf
  00056	83 c4 18	 add	 esp, 24			; 00000018H

; 159  : #endif  /*  _CFG_DEBUG_ */
; 160  : 
; 161  :         /*
; 162  :          *  命令分析，命令解码
; 163  :          */
; 164  :         argc = Sc_decode_cmdline(cmdline,argv);

  00059	8d 7c 24 08	 lea	 edi, DWORD PTR _argv$[esp+72]
  0005d	b9 00 00 00 00	 mov	 ecx, OFFSET _cmdline
  00062	e8 00 00 00 00	 call	 _Sc_decode_cmdline
  00067	8b f0		 mov	 esi, eax

; 165  : 
; 166  :         if( argc )      /*  存在命令才尝试执行   */

  00069	85 f6		 test	 esi, esi
  0006b	74 b3		 je	 SHORT $LL5@Lenix_shel

; 167  :         {
; 168  :             /*
; 169  :              *  查找是否存在命令
; 170  :              */
; 171  :             if( entry  = Sc_name_to_cmd(argv[0]) )

  0006d	8b 4c 24 08	 mov	 ecx, DWORD PTR _argv$[esp+72]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 _Sc_name_to_cmd
  00077	8b f8		 mov	 edi, eax
  00079	83 c4 04	 add	 esp, 4
  0007c	85 ff		 test	 edi, edi
  0007e	74 14		 je	 SHORT $LN2@Lenix_shel

; 172  :             {
; 173  :                 _printf("\n");

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  00085	e8 00 00 00 00	 call	 __printf

; 174  :                 entry(argc,argv);

  0008a	8d 54 24 0c	 lea	 edx, DWORD PTR _argv$[esp+76]
  0008e	52		 push	 edx
  0008f	56		 push	 esi
  00090	ff d7		 call	 edi

; 175  :             }
; 176  :             else

  00092	eb 87		 jmp	 SHORT $LN9@Lenix_shel
$LN2@Lenix_shel:

; 177  :                 _printf("\nbad or unkown command\n");

  00094	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@EMOFBOHO@?6bad?5or?5unkown?5command?6?$AA@
  00099	e8 00 00 00 00	 call	 __printf
  0009e	83 c4 04	 add	 esp, 4

; 178  :         }
; 179  :     }

  000a1	e9 7a ff ff ff	 jmp	 $LL5@Lenix_shel
_Lenix_shell ENDP
_TEXT	ENDS
PUBLIC	_Shell_cmd_add
EXTRN	__nstrcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Shell_cmd_add
_TEXT	SEGMENT
_result$ = -8						; size = 4
___psw$ = -4						; size = 4
_cmdname$ = 8						; size = 4
_cmdentry$ = 12						; size = 4
_Shell_cmd_add PROC					; COMDAT

; 183  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 184  :     sc_map_t            *   scm     = sc_map_table,
; 185  :                         *   scm_f   = NULL;         /*  空闲命令对象  */

  00007	33 ff		 xor	 edi, edi
  00009	be 00 00 00 00	 mov	 esi, OFFSET _sc_map_table
  0000e	33 db		 xor	 ebx, ebx

; 186  :     result_t                result  = RESULT_SUCCEED;

  00010	89 7c 24 10	 mov	 DWORD PTR _result$[esp+24], edi

; 187  :     int                     i       = 0;
; 188  :     CRITICAL_DECLARE(sc_lock);
; 189  : 
; 190  :     CRITICAL_BEGIN();

  00014	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00019	8b 6c 24 20	 mov	 ebp, DWORD PTR _cmdentry$[esp+20]
  0001d	89 44 24 14	 mov	 DWORD PTR ___psw$[esp+24], eax
$LL6@Shell_cmd_:

; 191  :     for( ; i < SHELL_CMD_MAX ; i++,scm++ )
; 192  :     {
; 193  :         if( NULL == scm_f && NULL == scm->scm_entry )

  00021	85 db		 test	 ebx, ebx
  00023	75 0a		 jne	 SHORT $LN3@Shell_cmd_
  00025	39 5e 08	 cmp	 DWORD PTR [esi+8], ebx
  00028	75 05		 jne	 SHORT $LN3@Shell_cmd_

; 194  :         {
; 195  :             scm_f           = scm;

  0002a	8b de		 mov	 ebx, esi

; 196  :             scm->scm_entry  = cmdentry;

  0002c	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
$LN3@Shell_cmd_:

; 197  :         }
; 198  : 
; 199  :         /*
; 200  :          *  保证系统命令不出现重名
; 201  :          */
; 202  :         if( _namecmp(scm->scm_name,cmdname) == 0 )

  0002f	8b 44 24 1c	 mov	 eax, DWORD PTR _cmdname$[esp+20]
  00033	50		 push	 eax
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 __namecmp
  0003a	83 c4 08	 add	 esp, 8
  0003d	85 c0		 test	 eax, eax
  0003f	74 38		 je	 SHORT $LN13@Shell_cmd_
  00041	83 c7 01	 add	 edi, 1
  00044	83 c6 0c	 add	 esi, 12			; 0000000cH
  00047	83 ff 20	 cmp	 edi, 32			; 00000020H
  0004a	7c d5		 jl	 SHORT $LL6@Shell_cmd_

; 207  :             break;
; 208  :         }
; 209  :     }
; 210  : 
; 211  :     if( scm_f )

  0004c	85 db		 test	 ebx, ebx
  0004e	74 10		 je	 SHORT $LN15@Shell_cmd_

; 212  :         _nstrcpy(scm_f->scm_name,cmdname,SHELL_CMD_NAME_SIZE);

  00050	8b 4c 24 1c	 mov	 ecx, DWORD PTR _cmdname$[esp+20]
  00054	6a 08		 push	 8
  00056	51		 push	 ecx
  00057	53		 push	 ebx
  00058	e8 00 00 00 00	 call	 __nstrcpy
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@Shell_cmd_:

; 213  : 
; 214  :     CRITICAL_END();

  00060	8b 54 24 14	 mov	 edx, DWORD PTR ___psw$[esp+24]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _Cpu_psw_set

; 215  : 
; 216  :     return result;

  0006a	8b 44 24 14	 mov	 eax, DWORD PTR _result$[esp+28]
  0006e	83 c4 04	 add	 esp, 4
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5d		 pop	 ebp
  00074	5b		 pop	 ebx

; 217  : }

  00075	83 c4 08	 add	 esp, 8
  00078	c3		 ret	 0
$LN13@Shell_cmd_:

; 203  :         {
; 204  :             scm_f->scm_entry    = NULL;

  00079	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0

; 205  :             scm_f               = NULL;
; 206  :             result              = RESULT_FAILED;

  00080	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR _result$[esp+24], -1

; 207  :             break;
; 208  :         }
; 209  :     }
; 210  : 
; 211  :     if( scm_f )

  00088	eb d6		 jmp	 SHORT $LN15@Shell_cmd_
_Shell_cmd_add ENDP
_TEXT	ENDS
PUBLIC	??_C@_07GJICHGAB@?5?5?5?5?$CFS?6?$AA@		; `string'
PUBLIC	??_C@_0BB@HAKHIHHN@System?5command?3?6?$AA@	; `string'
;	COMDAT ??_C@_07GJICHGAB@?5?5?5?5?$CFS?6?$AA@
CONST	SEGMENT
??_C@_07GJICHGAB@?5?5?5?5?$CFS?6?$AA@ DB '    %S', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HAKHIHHN@System?5command?3?6?$AA@
CONST	SEGMENT
??_C@_0BB@HAKHIHHN@System?5command?3?6?$AA@ DB 'System command:', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sc_help
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_Sc_help PROC						; COMDAT

; 249  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 250  :     sc_map_t            *   scm     = sc_map_table;
; 251  :     int                     i       = 0;
; 252  :     CRITICAL_DECLARE(sc_lock);
; 253  : 
; 254  :     _printf("System command:\n");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HAKHIHHN@System?5command?3?6?$AA@
  00008	be 00 00 00 00	 mov	 esi, OFFSET _sc_map_table
  0000d	e8 00 00 00 00	 call	 __printf
  00012	83 c4 04	 add	 esp, 4

; 255  : 
; 256  :     CRITICAL_BEGIN();

  00015	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0001a	8b d8		 mov	 ebx, eax
  0001c	bf 20 00 00 00	 mov	 edi, 32			; 00000020H
$LL4@Sc_help:

; 257  : 
; 258  :     for( ; i < SHELL_CMD_MAX ; i++,scm++ )
; 259  :     {
; 260  :         if( scm->scm_entry )

  00021	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00025	74 0e		 je	 SHORT $LN3@Sc_help

; 261  :             _printf("    %S\n",scm->scm_name);

  00027	56		 push	 esi
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_07GJICHGAB@?5?5?5?5?$CFS?6?$AA@
  0002d	e8 00 00 00 00	 call	 __printf
  00032	83 c4 08	 add	 esp, 8
$LN3@Sc_help:
  00035	83 c6 0c	 add	 esi, 12			; 0000000cH
  00038	83 ef 01	 sub	 edi, 1
  0003b	75 e4		 jne	 SHORT $LL4@Sc_help

; 262  :     }
; 263  : 
; 264  :     CRITICAL_END();

  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 _Cpu_psw_set
  00043	83 c4 04	 add	 esp, 4
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 265  : 
; 266  :     argc = argc;
; 267  :     argv = argv;
; 268  : 
; 269  :     return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	5b		 pop	 ebx

; 270  : }

  0004b	c3		 ret	 0
_Sc_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NNGJNHGF@Lenix?5ver?3?5?$CFd?4?$CF02d?6?$AA@ ; `string'
;	COMDAT ??_C@_0BE@NNGJNHGF@Lenix?5ver?3?5?$CFd?4?$CF02d?6?$AA@
CONST	SEGMENT
??_C@_0BE@NNGJNHGF@Lenix?5ver?3?5?$CFd?4?$CF02d?6?$AA@ DB 'Lenix ver: %d.'
	DB	'%02d', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sc_ver
_TEXT	SEGMENT
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_Sc_ver	PROC						; COMDAT

; 275  :     argc = argc;
; 276  :     argv = argv;
; 277  : 
; 278  :     _printf("Lenix ver: %d.%02d\n",VER_MAJOR,VER_MINOR);

  00000	6a 41		 push	 65			; 00000041H
  00002	6a 01		 push	 1
  00004	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NNGJNHGF@Lenix?5ver?3?5?$CFd?4?$CF02d?6?$AA@
  00009	e8 00 00 00 00	 call	 __printf
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 279  :     return 0;

  00011	33 c0		 xor	 eax, eax

; 280  : }

  00013	c3		 ret	 0
_Sc_ver	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GMALNMBL@OK?$CB?6?$AA@			; `string'
PUBLIC	??_C@_08LPEFHFBM@FAILED?$CB?6?$AA@		; `string'
PUBLIC	??_C@_04POHMOPHP@LeSH?$AA@			; `string'
PUBLIC	??_C@_03MDPKMNBM@ver?$AA@			; `string'
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	??_C@_0BF@PACIOFMD@shell?5initial?4?4?4?5?5?5?5?$AA@ ; `string'
PUBLIC	_Shell_initial
EXTRN	_Koum_release:PROC
EXTRN	_Proc_create:PROC
EXTRN	__memzero:PROC
EXTRN	__printk:PROC
_BSS	SEGMENT
_shell_stack DB	0800H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04GMALNMBL@OK?$CB?6?$AA@
CONST	SEGMENT
??_C@_04GMALNMBL@OK?$CB?6?$AA@ DB 'OK!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LPEFHFBM@FAILED?$CB?6?$AA@
CONST	SEGMENT
??_C@_08LPEFHFBM@FAILED?$CB?6?$AA@ DB 'FAILED!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04POHMOPHP@LeSH?$AA@
CONST	SEGMENT
??_C@_04POHMOPHP@LeSH?$AA@ DB 'LeSH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MDPKMNBM@ver?$AA@
CONST	SEGMENT
??_C@_03MDPKMNBM@ver?$AA@ DB 'ver', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PACIOFMD@shell?5initial?4?4?4?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BF@PACIOFMD@shell?5initial?4?4?4?5?5?5?5?$AA@ DB 'shell initial...'
	DB	'    ', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Shell_initial
_TEXT	SEGMENT
_Shell_initial PROC					; COMDAT

; 221  :     handle_t        handle  = INVALID_HANDLE;
; 222  :     _printk("shell initial...    ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PACIOFMD@shell?5initial?4?4?4?5?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 223  :     _memzero(sc_map_table,sizeof(sc_map_t)*SHELL_CMD_MAX);

  0000a	68 80 01 00 00	 push	 384			; 00000180H
  0000f	68 00 00 00 00	 push	 OFFSET _sc_map_table
  00014	e8 00 00 00 00	 call	 __memzero

; 224  : #ifdef _CFG_SMP_
; 225  :     sc_lock = 0;
; 226  : #endif  /*  _CFG_SMP_   */
; 227  : 
; 228  :     Shell_cmd_add("help",Sc_help);

  00019	68 00 00 00 00	 push	 OFFSET _Sc_help
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_04PCJFHION@help?$AA@
  00023	e8 00 00 00 00	 call	 _Shell_cmd_add

; 229  :     Shell_cmd_add("ver" ,Sc_ver );

  00028	68 00 00 00 00	 push	 OFFSET _Sc_ver
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_03MDPKMNBM@ver?$AA@
  00032	e8 00 00 00 00	 call	 _Shell_cmd_add

; 230  : 
; 231  :     handle = Proc_create("LeSH",
; 232  :         SHELL_PROCESS_PRIORITY,SHELL_PROCESS_PRIONUM,
; 233  :         Lenix_shell,0,
; 234  :         STACK_MAKE(shell_stack,SHELL_STACK_SIZE),
; 235  :         STACK_SIZE(shell_stack,SHELL_STACK_SIZE));

  00037	b8 00 08 00 00	 mov	 eax, OFFSET _shell_stack+2048
  0003c	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003f	8b c8		 mov	 ecx, eax
  00041	81 e9 00 00 00
	00		 sub	 ecx, OFFSET _shell_stack
  00047	51		 push	 ecx
  00048	50		 push	 eax
  00049	6a 00		 push	 0
  0004b	68 00 00 00 00	 push	 OFFSET _Lenix_shell
  00050	6a 03		 push	 3
  00052	6a 20		 push	 32			; 00000020H
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_04POHMOPHP@LeSH?$AA@
  00059	e8 00 00 00 00	 call	 _Proc_create
  0005e	83 c4 38	 add	 esp, 56			; 00000038H

; 236  : 
; 237  :     if( INVALID_HANDLE == handle )

  00061	85 c0		 test	 eax, eax
  00063	75 0e		 jne	 SHORT $LN2@Shell_init

; 238  :         _printk("FAILED!\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_08LPEFHFBM@FAILED?$CB?6?$AA@
  0006a	e8 00 00 00 00	 call	 __printk
  0006f	83 c4 04	 add	 esp, 4

; 243  :     }
; 244  : }

  00072	c3		 ret	 0
$LN2@Shell_init:

; 239  :     else
; 240  :     {
; 241  :         Koum_release(handle);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _Koum_release

; 242  :         _printk("OK!\n");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0007e	e8 00 00 00 00	 call	 __printk
  00083	83 c4 08	 add	 esp, 8

; 243  :     }
; 244  : }

  00086	c3		 ret	 0
_Shell_initial ENDP
_TEXT	ENDS
END
