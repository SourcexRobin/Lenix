/*
///////////////////////////////////////////////////////////////////////////////
//                             Lenix嵌入式操作系统
//                         2011 - 2014 @ 源代码工作室
//                                保留所有版权
//                     ***----------------------------***
//  名    称: pc_32.c
//  创建时间: 2014-01-31       创建者  : 罗斌
//  修改时间:                  修改者  : 
//  主要功能: 提供从字符终端的输入输出功能，作为Lenix默认支持的硬件设备
//  说    明: 
//
//  版本变化记录:
//  版本号      |    时  间     |    作  者     | 主要变化记录
//=============================================================================
//              |  2014-01-31   |    罗  斌     | 增加功能配置
///////////////////////////////////////////////////////////////////////////////
*/

#include <config.h>
#include <type.h>
#include <assert.h>
#include <lio.h>
#include <machine\machine.h>
#include <sys.h>
#include <clock.h>
#include <arch\x86.h>

extern volatile uint32_t    ticks;
extern volatile uint_t      e0e1;   /*  扩展字节标志    */
extern byte_t               interrupt_nest;
extern isp_t                machine_ivt[IRQ_SRC_MAX];       /*  中断向量表  */

/*
///////////////////////////////////////////////////////////////////////////////
//  名  称: Irq_clock
//  作  用: 32位X86的时钟中断处理程序
//  参  数: 无
//  返回值: 无
//  注  意: 中断嵌套超过196次以后，中断会丢失
//
//  变更记录:
//  时间        |  作  者       |  说明
//=============================================================================
//  2014-02-01  |  罗  斌       |  
///////////////////////////////////////////////////////////////////////////////
*/
NAKED
void        Irq_clock(void)
{
    I386_ISP_ENTER();
    ++ticks;
    ++interrupt_nest;                   /*  增加中断嵌套计数        */
    Io_outb((void *)0x20,0x20);         /*  重新开放主8259A         */
    if( interrupt_nest >= IRQ_NEST_MAX) /*  中断嵌套超过196则丢弃   */
        Machine_interrupt_mis();        /*  这个中断                */
    else
        machine_ivt[0](0,0);            /*  处理中断                */
    --interrupt_nest;                   /*  递减中断嵌套计数        */
    Syscall_exit(SCEXIT_TYPE_IRQ,1);    /*  中断退出前都要调用      */
    I386_ISP_LEAVE();
}


/*
///////////////////////////////////////////////////////////////////////////////
//  名  称: _Irq_keyboard
//  作  用: 32位X86的键盘中断处理程序
//  参  数: 无
//  返回值: 无
//  注  意: 为了使用局部变量才增加这个函数，在__declspec( naked )限定的条件下，
//          不能使用局部变量。
//          中断嵌套超过IRQ_NEST_MAX次以后，中断会丢失
//
//  变更记录:
//  时间        |  作  者       |  说明
//=============================================================================
//  2014-02-02  |  罗  斌       |  
///////////////////////////////////////////////////////////////////////////////
*/
static
void        _Irq_keyboard(void)
{
    byte_t                  sc = 0;     /*  系统扫描码,scan code    */
    
    sc = Io_inb((void*)0x60);
    Io_outb((void *)0x20,0x20);         /*  重新开放主8259A         */
    if( interrupt_nest >= IRQ_NEST_MAX )
    {
        Machine_interrupt_mis();
        return ;
    }
    switch(sc)
    {
    case 0xE0:  e0e1 |= 1;  break;
    case 0xE1:  e0e1 |= 2;  break;
    default:    machine_ivt[1](0,sc);
    }
}

/*
///////////////////////////////////////////////////////////////////////////////
//  名  称: Irq_keyboard
//  作  用: 32位X86的键盘中断处理程序
//  参  数: 无
//  返回值: 无
//  注  意: 
//
//  变更记录:
//  时间        |  作  者       |  说明
//=============================================================================
//  2014-02-02  |  罗  斌       |  
///////////////////////////////////////////////////////////////////////////////
*/
NAKED
void        Irq_keyboard(void)
{
    I386_ISP_ENTER();
    ++interrupt_nest;                   /*  增加中断嵌套计数        */
    _Irq_keyboard();
    --interrupt_nest;                   /*  递减中断嵌套计数        */
    Syscall_exit(SCEXIT_TYPE_IRQ,0);    /*  中断退出前都要调用      */
    I386_ISP_LEAVE();
}

NAKED
void        Irq_com1(void)
{
    __asm iretd
}

