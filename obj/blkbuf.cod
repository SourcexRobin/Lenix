; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\blkbuf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@GNOLGLLG@assert?5failed?$AA@		; `string'
PUBLIC	??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@FOOPJMPB@NULL?5?$CB?$DN?5bb_free?$AA@	; `string'
PUBLIC	??_C@_08HDNGNFCH@blkbuf?4c?$AA@			; `string'
EXTRN	_Sys_halt:PROC
EXTRN	__printf:PROC
EXTRN	_Proc_sched:PROC
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Proc_wait_on:PROC
EXTRN	_Cpu_disable_interrupt:PROC
_BSS	SEGMENT
_bb_total_free DD 01H DUP (?)
_bb_free DD	01H DUP (?)
_bb_wait_list DD 01H DUP (?)
_bb_total DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
; File e:\sourcexstudio\lenix\lenix\src\kernel\blkbuf.c
CONST	SEGMENT
??_C@_0O@GNOLGLLG@assert?5failed?$AA@ DB 'assert failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ DB 'a'
	DB	'ssert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOOPJMPB@NULL?5?$CB?$DN?5bb_free?$AA@
CONST	SEGMENT
??_C@_0BA@FOOPJMPB@NULL?5?$CB?$DN?5bb_free?$AA@ DB 'NULL != bb_free', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HDNGNFCH@blkbuf?4c?$AA@
CONST	SEGMENT
??_C@_08HDNGNFCH@blkbuf?4c?$AA@ DB 'blkbuf.c', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Bbuf_get
_TEXT	SEGMENT
_Bbuf_get PROC						; COMDAT

; 134  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 135  :     blkbuf_t      * blkbuf = NULL;
; 136  :     CRITICAL_DECLARE(bb_lock);
; 137  : 
; 138  :     /*
; 139  :      *  无可用块缓存时，等待。
; 140  :      *  此时淘汰进程必定已经启动，因此可以很快存在可用块缓存 
; 141  :      */
; 142  : blkbuf_get_begin:
; 143  :     CRITICAL_BEGIN();

  00003	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 144  :     if( 0 == bb_total )

  00008	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bb_total, 0
  0000f	8b f8		 mov	 edi, eax
  00011	75 2a		 jne	 SHORT $LN5@Bbuf_get
$blkbuf_get_begin$1937:

; 145  :     {
; 146  :         Proc_wait_on(&bb_wait_list);

  00013	68 00 00 00 00	 push	 OFFSET _bb_wait_list
  00018	e8 00 00 00 00	 call	 _Proc_wait_on

; 147  :         CRITICAL_END();

  0001d	57		 push	 edi
  0001e	e8 00 00 00 00	 call	 _Cpu_psw_set

; 148  :         Proc_sched(0);

  00023	6a 00		 push	 0
  00025	e8 00 00 00 00	 call	 _Proc_sched
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bb_total, 0
  00039	8b f8		 mov	 edi, eax
  0003b	74 d6		 je	 SHORT $blkbuf_get_begin$1937
$LN5@Bbuf_get:

; 149  :         goto blkbuf_get_begin;
; 150  :     }
; 151  :     ASSERT( NULL != bb_free );

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _bb_free
  00042	85 c0		 test	 eax, eax
  00044	75 2b		 jne	 SHORT $LN4@Bbuf_get
  00046	68 97 00 00 00	 push	 151			; 00000097H
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_08HDNGNFCH@blkbuf?4c?$AA@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOOPJMPB@NULL?5?$CB?$DN?5bb_free?$AA@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0005a	e8 00 00 00 00	 call	 __printf
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00064	e8 00 00 00 00	 call	 _Sys_halt
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _bb_free
  0006e	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@Bbuf_get:

; 152  :     blkbuf  = bb_free;
; 153  :     bb_free = bb_free->bb_next;

  00071	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  00074	8b d8		 mov	 ebx, eax
  00076	8b 06		 mov	 eax, DWORD PTR [esi]

; 154  :     if( bb_free )

  00078	85 c0		 test	 eax, eax
  0007a	a3 00 00 00 00	 mov	 DWORD PTR _bb_free, eax
  0007f	74 06		 je	 SHORT $LN1@Bbuf_get

; 155  :         bb_free->bb_prev = NULL;

  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@Bbuf_get:

; 156  :     --bb_total_free;

  00087	83 2d 00 00 00
	00 01		 sub	 DWORD PTR _bb_total_free, 1

; 157  :     CRITICAL_END();

  0008e	57		 push	 edi
  0008f	e8 00 00 00 00	 call	 _Cpu_psw_set
  00094	83 c4 04	 add	 esp, 4
  00097	5f		 pop	 edi

; 158  :     blkbuf->bb_next = NULL;

  00098	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0009e	5e		 pop	 esi

; 159  : 
; 160  :     return blkbuf;

  0009f	8b c3		 mov	 eax, ebx
  000a1	5b		 pop	 ebx

; 161  : }

  000a2	c3		 ret	 0
_Bbuf_get ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MDBGMHII@NULL?5?$CB?$DN?5blkbuf?$AA@	; `string'
;	COMDAT ??_C@_0P@MDBGMHII@NULL?5?$CB?$DN?5blkbuf?$AA@
CONST	SEGMENT
??_C@_0P@MDBGMHII@NULL?5?$CB?$DN?5blkbuf?$AA@ DB 'NULL != blkbuf', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Bbuf_put
_TEXT	SEGMENT
_Bbuf_put PROC						; COMDAT
; _blkbuf$ = ecx

; 182  :     result_t        result = RESULT_SUCCEED;

  00000	33 c0		 xor	 eax, eax

; 183  : 
; 184  :     ASSERT( NULL != blkbuf);

  00002	3b c8		 cmp	 ecx, eax
  00004	75 2a		 jne	 SHORT $LN3@Bbuf_put
  00006	68 b8 00 00 00	 push	 184			; 000000b8H
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_08HDNGNFCH@blkbuf?4c?$AA@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MDBGMHII@NULL?5?$CB?$DN?5blkbuf?$AA@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001a	e8 00 00 00 00	 call	 __printf
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00024	e8 00 00 00 00	 call	 _Sys_halt
  00029	83 c4 14	 add	 esp, 20			; 00000014H

; 185  : #ifdef _CFG_CHECK_PARAMETER_
; 186  :     if( NULL == blkbuf )
; 187  :     {
; 188  :         result = RESULT_FAILED;

  0002c	83 c8 ff	 or	 eax, -1

; 209  : 
; 210  : bbuf_put_end:
; 211  :     return result;
; 212  : }

  0002f	c3		 ret	 0
$LN3@Bbuf_put:

; 189  :         goto bbuf_put_end;
; 190  :     }
; 191  : #endif  /*  _CFG_CHECK_PARAMETER_*/
; 192  :     blkbuf->bb_prev         = NULL;
; 193  :     blkbuf->bb_next         = NULL;
; 194  :     blkbuf->bb_bucket_prev  = NULL;
; 195  :     blkbuf->bb_bucket_next  = NULL;
; 196  :     blkbuf->bb_device       = NULL;
; 197  :     blkbuf->bb_address      = 0;
; 198  :     blkbuf->bb_refcnt       = 0;
; 199  :     if( NULL == bb_free )

  00030	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _bb_free
  00036	3b d0		 cmp	 edx, eax
  00038	89 01		 mov	 DWORD PTR [ecx], eax
  0003a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0003d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00040	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00043	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
  00046	89 41 30	 mov	 DWORD PTR [ecx+48], eax
  00049	89 41 34	 mov	 DWORD PTR [ecx+52], eax
  0004c	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 200  :         bb_free = blkbuf;

  0004f	89 0d 00 00 00
	00		 mov	 DWORD PTR _bb_free, ecx

; 201  :     else

  00055	74 05		 je	 SHORT $LN1@Bbuf_put

; 202  :     {
; 203  :         /*  插入到表头  */
; 204  :         blkbuf->bb_next     = bb_free;

  00057	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 205  :         bb_free->bb_prev    = blkbuf;

  0005a	89 0a		 mov	 DWORD PTR [edx], ecx
$LN1@Bbuf_put:

; 206  :         bb_free             = blkbuf;
; 207  :     }
; 208  :     ++bb_total_free;

  0005c	83 05 00 00 00
	00 01		 add	 DWORD PTR _bb_total_free, 1
$bbuf_put_end$1964:

; 209  : 
; 210  : bbuf_put_end:
; 211  :     return result;
; 212  : }

  00063	c3		 ret	 0
_Bbuf_put ENDP
_TEXT	ENDS
_BSS	SEGMENT
_bb_used_tail DD 01H DUP (?)
_bb_used DD	01H DUP (?)
_bb_buckets DD	0137H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Bbuf_hash_add
_TEXT	SEGMENT
_Bbuf_hash_add PROC					; COMDAT
; _blkbuf$ = esi

; 235  :     blkbuf_t      * bucket  = NULL;
; 236  :     CRITICAL_DECLARE(bb_lock);
; 237  : 
; 238  :     ASSERT( NULL != blkbuf );

  00000	85 f6		 test	 esi, esi
  00002	75 26		 jne	 SHORT $LN10@Bbuf_hash_
  00004	68 ee 00 00 00	 push	 238			; 000000eeH
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_08HDNGNFCH@blkbuf?4c?$AA@
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MDBGMHII@NULL?5?$CB?$DN?5blkbuf?$AA@
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00018	e8 00 00 00 00	 call	 __printf
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00022	e8 00 00 00 00	 call	 _Sys_halt
  00027	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Bbuf_hash_:

; 239  :     blkbuf->bb_prev         = NULL;
; 240  :     blkbuf->bb_next         = NULL;
; 241  :     blkbuf->bb_bucket_prev  = NULL;
; 242  :     blkbuf->bb_bucket_next  = NULL;
; 243  :     bucket = BBUF_BUCKET(blkbuf->bb_address);

  0002a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0002d	c1 e8 03	 shr	 eax, 3
  00030	33 d2		 xor	 edx, edx
  00032	b9 37 01 00 00	 mov	 ecx, 311		; 00000137H
  00037	f7 f1		 div	 ecx
  00039	57		 push	 edi
  0003a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00040	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00047	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0004e	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00055	8b 3c 95 00 00
	00 00		 mov	 edi, DWORD PTR _bb_buckets[edx*4]

; 244  :     CRITICAL_BEGIN();

  0005c	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 245  :     /*  插入散列表  */
; 246  :     if( bucket )

  00061	85 ff		 test	 edi, edi
  00063	8b c8		 mov	 ecx, eax
  00065	74 08		 je	 SHORT $LN4@Bbuf_hash_

; 247  :     {
; 248  :         blkbuf->bb_bucket_next = bucket;

  00067	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 249  :         bucket->bb_bucket_prev = blkbuf;

  0006a	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 250  :         bucket = blkbuf;
; 251  :     }
; 252  :     else

  0006d	eb 16		 jmp	 SHORT $LN3@Bbuf_hash_
$LN4@Bbuf_hash_:

; 253  :         BBUF_BUCKET(blkbuf->bb_address) = blkbuf;

  0006f	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00072	c1 e8 03	 shr	 eax, 3
  00075	33 d2		 xor	 edx, edx
  00077	bf 37 01 00 00	 mov	 edi, 311		; 00000137H
  0007c	f7 f7		 div	 edi
  0007e	89 34 95 00 00
	00 00		 mov	 DWORD PTR _bb_buckets[edx*4], esi
$LN3@Bbuf_hash_:

; 254  :     /*  加入已用列表*/
; 255  :     if( NULL == bb_used )

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR _bb_used
  0008a	85 c0		 test	 eax, eax
  0008c	5f		 pop	 edi

; 256  :     {
; 257  :         bb_used         = blkbuf;

  0008d	89 35 00 00 00
	00		 mov	 DWORD PTR _bb_used, esi
  00093	75 0e		 jne	 SHORT $LN2@Bbuf_hash_

; 263  :         bb_used->bb_prev    = blkbuf;
; 264  :         bb_used             = blkbuf;
; 265  :     }
; 266  :     CRITICAL_END();

  00095	51		 push	 ecx
  00096	89 35 00 00 00
	00		 mov	 DWORD PTR _bb_used_tail, esi
  0009c	e8 00 00 00 00	 call	 _Cpu_psw_set
  000a1	59		 pop	 ecx

; 267  : }

  000a2	c3		 ret	 0
$LN2@Bbuf_hash_:

; 258  :         bb_used_tail    = blkbuf;
; 259  :     }
; 260  :     else
; 261  :     {
; 262  :         blkbuf->bb_next     = bb_used;

  000a3	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 263  :         bb_used->bb_prev    = blkbuf;
; 264  :         bb_used             = blkbuf;
; 265  :     }
; 266  :     CRITICAL_END();

  000a6	51		 push	 ecx
  000a7	89 30		 mov	 DWORD PTR [eax], esi
  000a9	e8 00 00 00 00	 call	 _Cpu_psw_set
  000ae	59		 pop	 ecx

; 267  : }

  000af	c3		 ret	 0
_Bbuf_hash_add ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Bbuf_hash_del
_TEXT	SEGMENT
_Bbuf_hash_del PROC					; COMDAT
; _blkbuf$ = ecx

; 288  :     blkbuf_t      * prev    = NULL,
; 289  :                   * next    = NULL,
; 290  :                   * bucket  = NULL;
; 291  : 
; 292  :     prev = blkbuf->bb_prev;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]

; 293  :     next = blkbuf->bb_next;

  00002	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00005	53		 push	 ebx
  00006	56		 push	 esi

; 294  :     /*  从已用列表中删除 */
; 295  :     if( blkbuf == bb_used)  /*  处理表头 */
; 296  :     {
; 297  :         bb_used = next;
; 298  :         if( next )

  00007	33 db		 xor	 ebx, ebx
  00009	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _bb_used
  0000f	57		 push	 edi
  00010	75 15		 jne	 SHORT $LN10@Bbuf_hash_@2
  00012	3b c3		 cmp	 eax, ebx
  00014	a3 00 00 00 00	 mov	 DWORD PTR _bb_used, eax
  00019	74 04		 je	 SHORT $LN9@Bbuf_hash_@2

; 299  :             next->bb_prev = NULL;

  0001b	89 18		 mov	 DWORD PTR [eax], ebx

; 300  :         else

  0001d	eb 19		 jmp	 SHORT $LN5@Bbuf_hash_@2
$LN9@Bbuf_hash_@2:

; 301  :             bb_used_tail  = NULL;   /*  链表已经没有，链表尾也要处理*/

  0001f	89 1d 00 00 00
	00		 mov	 DWORD PTR _bb_used_tail, ebx

; 302  :     }
; 303  :     else

  00025	eb 11		 jmp	 SHORT $LN5@Bbuf_hash_@2
$LN10@Bbuf_hash_@2:

; 304  :     {
; 305  :         prev->bb_next = next;
; 306  :         if( next )

  00027	3b c3		 cmp	 eax, ebx
  00029	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0002c	74 04		 je	 SHORT $LN6@Bbuf_hash_@2

; 307  :             next->bb_prev = prev;

  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 308  :         else

  00030	eb 06		 jmp	 SHORT $LN5@Bbuf_hash_@2
$LN6@Bbuf_hash_@2:

; 309  :             bb_used_tail  = prev;

  00032	89 15 00 00 00
	00		 mov	 DWORD PTR _bb_used_tail, edx
$LN5@Bbuf_hash_@2:

; 310  :     }
; 311  :     /*  从散列表中删除  */
; 312  :     bucket  = BBUF_BUCKET(blkbuf->bb_address);

  00038	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0003b	55		 push	 ebp
  0003c	c1 e8 03	 shr	 eax, 3
  0003f	33 d2		 xor	 edx, edx
  00041	bd 37 01 00 00	 mov	 ebp, 311		; 00000137H
  00046	f7 f5		 div	 ebp

; 313  :     prev    = blkbuf->bb_bucket_prev;
; 314  :     next    = blkbuf->bb_bucket_next;
; 315  :     if( blkbuf == bucket )  /*  处理表头 */

  00048	3b 0c 95 00 00
	00 00		 cmp	 ecx, DWORD PTR _bb_buckets[edx*4]
  0004f	8b 79 08	 mov	 edi, DWORD PTR [ecx+8]
  00052	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00055	5d		 pop	 ebp
  00056	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR _bb_buckets[edx*4]
  0005d	75 1a		 jne	 SHORT $LN4@Bbuf_hash_@2

; 316  :     {
; 317  :         BBUF_BUCKET(blkbuf->bb_address) = next;
; 318  :         if( next )

  0005f	3b f3		 cmp	 esi, ebx
  00061	89 30		 mov	 DWORD PTR [eax], esi
  00063	74 1e		 je	 SHORT $LN1@Bbuf_hash_@2

; 319  :             next->bb_bucket_prev = NULL;

  00065	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 326  :     }
; 327  :     /*  */
; 328  :     blkbuf->bb_next         = NULL;

  0006a	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 329  :     blkbuf->bb_prev         = NULL;

  0006d	89 19		 mov	 DWORD PTR [ecx], ebx

; 330  :     blkbuf->bb_bucket_next  = NULL;

  0006f	89 59 0c	 mov	 DWORD PTR [ecx+12], ebx

; 331  :     blkbuf->bb_bucket_prev  = NULL;

  00072	89 59 08	 mov	 DWORD PTR [ecx+8], ebx

; 332  :     return RESULT_SUCCEED;

  00075	33 c0		 xor	 eax, eax
  00077	5b		 pop	 ebx

; 333  : }

  00078	c3		 ret	 0
$LN4@Bbuf_hash_@2:

; 320  :     }
; 321  :     else
; 322  :     {
; 323  :         prev->bb_bucket_next = next;
; 324  :         if( next )

  00079	3b f3		 cmp	 esi, ebx
  0007b	89 77 0c	 mov	 DWORD PTR [edi+12], esi
  0007e	74 03		 je	 SHORT $LN1@Bbuf_hash_@2

; 325  :             next->bb_bucket_prev = prev;

  00080	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN1@Bbuf_hash_@2:
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 326  :     }
; 327  :     /*  */
; 328  :     blkbuf->bb_next         = NULL;

  00085	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 329  :     blkbuf->bb_prev         = NULL;

  00088	89 19		 mov	 DWORD PTR [ecx], ebx

; 330  :     blkbuf->bb_bucket_next  = NULL;

  0008a	89 59 0c	 mov	 DWORD PTR [ecx+12], ebx

; 331  :     blkbuf->bb_bucket_prev  = NULL;

  0008d	89 59 08	 mov	 DWORD PTR [ecx+8], ebx

; 332  :     return RESULT_SUCCEED;

  00090	33 c0		 xor	 eax, eax
  00092	5b		 pop	 ebx

; 333  : }

  00093	c3		 ret	 0
_Bbuf_hash_del ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Bbuf_query
_TEXT	SEGMENT
_address$ = 8						; size = 8
_Bbuf_query PROC					; COMDAT
; _device$ = ebx

; 355  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 356  :     blkbuf_t      * blkbuf  = BBUF_BUCKET(address);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _address$[esp+4]
  00006	8b c7		 mov	 eax, edi
  00008	c1 e8 03	 shr	 eax, 3
  0000b	33 d2		 xor	 edx, edx
  0000d	b9 37 01 00 00	 mov	 ecx, 311		; 00000137H
  00012	f7 f1		 div	 ecx
  00014	8b 34 95 00 00
	00 00		 mov	 esi, DWORD PTR _bb_buckets[edx*4]

; 357  :     CRITICAL_DECLARE(bb_lock);
; 358  : 
; 359  :     CRITICAL_BEGIN();

  0001b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 360  :     /*  采用遍历的方式查找*/
; 361  :     for( blkbuf ; blkbuf ; blkbuf = blkbuf->bb_bucket_next )

  00020	85 f6		 test	 esi, esi
  00022	74 1e		 je	 SHORT $LN11@Bbuf_query
  00024	8b 4c 24 10	 mov	 ecx, DWORD PTR _address$[esp+8]
$LL4@Bbuf_query:

; 362  :         if( blkbuf->bb_device == device && blkbuf->bb_address == address )

  00028	39 5e 2c	 cmp	 DWORD PTR [esi+44], ebx
  0002b	75 0e		 jne	 SHORT $LN3@Bbuf_query
  0002d	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00030	3b d7		 cmp	 edx, edi
  00032	75 07		 jne	 SHORT $LN3@Bbuf_query
  00034	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00037	3b d1		 cmp	 edx, ecx
  00039	74 07		 je	 SHORT $LN11@Bbuf_query
$LN3@Bbuf_query:

; 360  :     /*  采用遍历的方式查找*/
; 361  :     for( blkbuf ; blkbuf ; blkbuf = blkbuf->bb_bucket_next )

  0003b	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  0003e	85 f6		 test	 esi, esi
  00040	75 e6		 jne	 SHORT $LL4@Bbuf_query
$LN11@Bbuf_query:

; 363  :             break;
; 364  :     CRITICAL_END();

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _Cpu_psw_set
  00048	83 c4 04	 add	 esp, 4
  0004b	5f		 pop	 edi

; 365  :     return blkbuf;

  0004c	8b c6		 mov	 eax, esi
  0004e	5e		 pop	 esi

; 366  : }

  0004f	c3		 ret	 0
_Bbuf_query ENDP
_TEXT	ENDS
EXTRN	_Proc_wait:PROC
EXTRN	_Proc_resume_on:PROC
EXTRN	_Lck_lock:PROC
_BSS	SEGMENT
_bb_eliminate_proc DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Bbuf_eliminate
_TEXT	SEGMENT
___psw$ = -4						; size = 4
_param$ = 8						; size = 4
_Bbuf_eliminate PROC					; COMDAT

; 389  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	33 db		 xor	 ebx, ebx
$eliminate_begin$2054:

; 390  :     int             i       = 0;
; 391  :     blkbuf_t      * blkbuf  = NULL,
; 392  :                   * temp    = NULL;
; 393  :     CRITICAL_DECLARE(bb_lock);
; 394  : 
; 395  :     param = param;
; 396  : eliminate_begin:
; 397  :     CRITICAL_BEGIN();

  00007	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 398  :     /*
; 399  :      *  将修改过的块缓存写回设备。
; 400  :      *    从已使用链表尾开始遍历，遍历完毕或者已经同步了4个块缓存，写操作结束。
; 401  :      *  这么做可以分散系统的写操作时间，同时可以保证有缓存块可淘汰。
; 402  :      */
; 403  :     blkbuf  = bb_used_tail; /*  从已使用列表尾开始  */

  0000c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _bb_used_tail
  00012	89 44 24 10	 mov	 DWORD PTR ___psw$[esp+20], eax

; 404  :     i       = 0;            /*  这里用作写计数器    */

  00016	33 ff		 xor	 edi, edi
$LL9@Bbuf_elimi:

; 405  :     for( ; i < 4 && blkbuf ; blkbuf = blkbuf->bb_prev )

  00018	3b f3		 cmp	 esi, ebx
  0001a	74 1c		 je	 SHORT $LN7@Bbuf_elimi

; 406  :     {
; 407  :         if( blkbuf->bb_flags & BBUF_FLAGS_DIRTED )

  0001c	f6 46 10 01	 test	 BYTE PTR [esi+16], 1
  00020	74 0f		 je	 SHORT $LN8@Bbuf_elimi

; 408  :         {
; 409  :             Lck_lock(&blkbuf->bb_lock);

  00022	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _Lck_lock
  0002b	83 c4 04	 add	 esp, 4

; 410  :             i++;

  0002e	83 c7 01	 add	 edi, 1
$LN8@Bbuf_elimi:
  00031	83 ff 04	 cmp	 edi, 4
  00034	8b 36		 mov	 esi, DWORD PTR [esi]
  00036	7c e0		 jl	 SHORT $LL9@Bbuf_elimi
$LN7@Bbuf_elimi:

; 411  :         }
; 412  :     }
; 413  :     /*
; 414  :      *  淘汰规则：
; 415  :      *    1.从引用计数最少的块缓存开始淘汰。由于是从已使用列表尾开始，因此刚读
; 416  :      *  出数据的块缓存一般不会被淘汰。
; 417  :      *    2.仅淘汰未修改过的块缓存
; 418  :      */
; 419  :     blkbuf  = bb_used_tail; /*  从已使用列表尾开始  */ 

  00038	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bb_used_tail

; 420  :     i       = 0;            /*  这里用作淘汰计数器  */

  0003e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _bb_free
  00044	33 ff		 xor	 edi, edi
$LN5@Bbuf_elimi:

; 421  :     for(; i < 8 && blkbuf ; blkbuf = temp)

  00046	3b cb		 cmp	 ecx, ebx
  00048	74 45		 je	 SHORT $LN30@Bbuf_elimi

; 422  :     {
; 423  :         temp = blkbuf->bb_prev;
; 424  :         if( 0 == blkbuf->bb_refcnt && !(blkbuf->bb_flags & BBUF_FLAGS_DIRTED))

  0004a	39 59 28	 cmp	 DWORD PTR [ecx+40], ebx
  0004d	8b 29		 mov	 ebp, DWORD PTR [ecx]
  0004f	75 37		 jne	 SHORT $LN4@Bbuf_elimi
  00051	f6 41 10 01	 test	 BYTE PTR [ecx+16], 1
  00055	75 31		 jne	 SHORT $LN4@Bbuf_elimi

; 425  :         {
; 426  :             Bbuf_hash_del(blkbuf);

  00057	e8 00 00 00 00	 call	 _Bbuf_hash_del

; 427  :             Bbuf_put(blkbuf);

  0005c	3b f3		 cmp	 esi, ebx
  0005e	89 19		 mov	 DWORD PTR [ecx], ebx
  00060	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00063	89 59 08	 mov	 DWORD PTR [ecx+8], ebx
  00066	89 59 0c	 mov	 DWORD PTR [ecx+12], ebx
  00069	89 59 2c	 mov	 DWORD PTR [ecx+44], ebx
  0006c	89 59 30	 mov	 DWORD PTR [ecx+48], ebx
  0006f	89 59 34	 mov	 DWORD PTR [ecx+52], ebx
  00072	89 59 28	 mov	 DWORD PTR [ecx+40], ebx
  00075	74 05		 je	 SHORT $LN31@Bbuf_elimi
  00077	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0007a	89 0e		 mov	 DWORD PTR [esi], ecx
$LN31@Bbuf_elimi:
  0007c	83 05 00 00 00
	00 01		 add	 DWORD PTR _bb_total_free, 1
  00083	8b f1		 mov	 esi, ecx
$bbuf_put_end$2198:

; 428  :             i++;

  00085	83 c7 01	 add	 edi, 1
$LN4@Bbuf_elimi:
  00088	83 ff 08	 cmp	 edi, 8
  0008b	8b cd		 mov	 ecx, ebp
  0008d	7c b7		 jl	 SHORT $LN5@Bbuf_elimi
$LN30@Bbuf_elimi:

; 429  :         }
; 430  :     }
; 431  :     Proc_resume_on(&bb_wait_list);

  0008f	68 00 00 00 00	 push	 OFFSET _bb_wait_list
  00094	89 35 00 00 00
	00		 mov	 DWORD PTR _bb_free, esi
  0009a	e8 00 00 00 00	 call	 _Proc_resume_on

; 432  :     CRITICAL_END();

  0009f	8b 4c 24 14	 mov	 ecx, DWORD PTR ___psw$[esp+24]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _Cpu_psw_set

; 433  :     Proc_sched(0);

  000a9	53		 push	 ebx
  000aa	e8 00 00 00 00	 call	 _Proc_sched

; 434  :     /*  在可用块缓存超过总数的40%后，停止淘汰*/
; 435  :     if( ((bb_total_free * 10 ) / bb_total) > 4 )

  000af	a1 00 00 00 00	 mov	 eax, DWORD PTR _bb_total_free
  000b4	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000b7	03 c0		 add	 eax, eax
  000b9	33 d2		 xor	 edx, edx
  000bb	f7 35 00 00 00
	00		 div	 DWORD PTR _bb_total
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c4	83 f8 04	 cmp	 eax, 4
  000c7	0f 86 3a ff ff
	ff		 jbe	 $eliminate_begin$2054

; 436  :         Proc_wait(&bb_eliminate_proc);

  000cd	68 00 00 00 00	 push	 OFFSET _bb_eliminate_proc
  000d2	e8 00 00 00 00	 call	 _Proc_wait
  000d7	83 c4 04	 add	 esp, 4

; 437  : 
; 438  :     goto eliminate_begin;

  000da	e9 28 ff ff ff	 jmp	 $eliminate_begin$2054
_Bbuf_eliminate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@GAOMEACD@Block?5buffer?5is?5NULL?$CB?6?$AA@ ; `string'
PUBLIC	_Bbuf_read
EXTRN	_Proc_resume:PROC
EXTRN	_Dev_read:PROC
;	COMDAT ??_C@_0BH@GAOMEACD@Block?5buffer?5is?5NULL?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BH@GAOMEACD@Block?5buffer?5is?5NULL?$CB?6?$AA@ DB 'Block buffer is'
	DB	' NULL!', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Bbuf_read
_TEXT	SEGMENT
_device$ = 8						; size = 4
_address$ = 12						; size = 8
_Bbuf_read PROC						; COMDAT

; 470  : {

  00000	53		 push	 ebx

; 471  :     blkbuf_t      * blkbuf  = NULL;
; 472  : 
; 473  :     address &= ~7;
; 474  :     /*  先检测是否已经存在 */
; 475  :     if( NULL != ( blkbuf = Bbuf_query(device,address) ) )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _device$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 14	 mov	 ebp, DWORD PTR _address$[esp+8]
  0000a	57		 push	 edi
  0000b	8b 7c 24 14	 mov	 edi, DWORD PTR _address$[esp+8]
  0000f	83 e7 f8	 and	 edi, -8			; fffffff8H
  00012	55		 push	 ebp
  00013	57		 push	 edi
  00014	e8 00 00 00 00	 call	 _Bbuf_query
  00019	83 c4 08	 add	 esp, 8
  0001c	85 c0		 test	 eax, eax
  0001e	74 08		 je	 SHORT $LN4@Bbuf_read

; 476  :     {
; 477  :         blkbuf->bb_refcnt++;

  00020	83 40 28 01	 add	 DWORD PTR [eax+40], 1
  00024	5f		 pop	 edi
  00025	5d		 pop	 ebp
  00026	5b		 pop	 ebx

; 500  : }

  00027	c3		 ret	 0
$LN4@Bbuf_read:
  00028	56		 push	 esi

; 478  :         goto blkbuf_read_end;
; 479  :     }
; 480  :     /*  到达这里说明数据未读入，需要分配新的缓存块然后读数据    */
; 481  :     if( NULL == ( blkbuf = Bbuf_get() ) )

  00029	e8 00 00 00 00	 call	 _Bbuf_get
  0002e	8b f0		 mov	 esi, eax
  00030	85 f6		 test	 esi, esi
  00032	75 0d		 jne	 SHORT $LN3@Bbuf_read

; 482  :         Sys_halt("Block buffer is NULL!\n");    /*  按设计是不会出现NULL的 */

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GAOMEACD@Block?5buffer?5is?5NULL?$CB?6?$AA@
  00039	e8 00 00 00 00	 call	 _Sys_halt
  0003e	83 c4 04	 add	 esp, 4
$LN3@Bbuf_read:

; 483  :     /*  数据读取失败，释放块缓存，返回失败  */
; 484  :     if( Dev_read(device,address,blkbuf->bb_buffer,BBUF_SIZE) != BBUF_SIZE)

  00041	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00044	68 00 10 00 00	 push	 4096			; 00001000H
  00049	50		 push	 eax
  0004a	55		 push	 ebp
  0004b	57		 push	 edi
  0004c	53		 push	 ebx
  0004d	e8 00 00 00 00	 call	 _Dev_read
  00052	83 c4 14	 add	 esp, 20			; 00000014H
  00055	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0005a	74 0e		 je	 SHORT $LN2@Bbuf_read

; 485  :     {
; 486  :         Bbuf_put(blkbuf);

  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 _Bbuf_put
  00063	5e		 pop	 esi
  00064	5f		 pop	 edi
  00065	5d		 pop	 ebp

; 487  :         blkbuf = NULL;

  00066	33 c0		 xor	 eax, eax
  00068	5b		 pop	 ebx

; 500  : }

  00069	c3		 ret	 0
$LN2@Bbuf_read:

; 488  :         goto blkbuf_read_end;
; 489  :     }
; 490  :     blkbuf->bb_device   = device;

  0006a	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx

; 491  :     blkbuf->bb_address  = address;

  0006d	89 7e 30	 mov	 DWORD PTR [esi+48], edi
  00070	89 6e 34	 mov	 DWORD PTR [esi+52], ebp

; 492  :     blkbuf->bb_refcnt   = 1;

  00073	c7 46 28 01 00
	00 00		 mov	 DWORD PTR [esi+40], 1

; 493  :     Bbuf_hash_add(blkbuf);

  0007a	e8 00 00 00 00	 call	 _Bbuf_hash_add

; 494  :     /*  在可用缓存小于系统总数的20%的时候，唤醒淘汰进程 */
; 495  :     if( bb_eliminate_proc && (((bb_total_free * 10 )) / bb_total) < 2 )

  0007f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _bb_eliminate_proc, 0
  00086	74 24		 je	 SHORT $LN8@Bbuf_read
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _bb_total_free
  0008d	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00090	03 c0		 add	 eax, eax
  00092	33 d2		 xor	 edx, edx
  00094	f7 35 00 00 00
	00		 div	 DWORD PTR _bb_total
  0009a	83 f8 02	 cmp	 eax, 2
  0009d	73 0d		 jae	 SHORT $LN8@Bbuf_read

; 496  :         Proc_resume(&bb_eliminate_proc);

  0009f	68 00 00 00 00	 push	 OFFSET _bb_eliminate_proc
  000a4	e8 00 00 00 00	 call	 _Proc_resume
  000a9	83 c4 04	 add	 esp, 4
$LN8@Bbuf_read:

; 497  : 
; 498  : blkbuf_read_end:
; 499  :     return blkbuf;

  000ac	8b c6		 mov	 eax, esi
  000ae	5e		 pop	 esi
  000af	5f		 pop	 edi
  000b0	5d		 pop	 ebp
$blkbuf_read_end$2076:
  000b1	5b		 pop	 ebx

; 500  : }

  000b2	c3		 ret	 0
_Bbuf_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@HLLDADII@blkbuf?9?$DObb_refcnt?5?$DO?50?$AA@ ; `string'
PUBLIC	_Bbuf_release
;	COMDAT ??_C@_0BG@HLLDADII@blkbuf?9?$DObb_refcnt?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BG@HLLDADII@blkbuf?9?$DObb_refcnt?5?$DO?50?$AA@ DB 'blkbuf->bb_ref'
	DB	'cnt > 0', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Bbuf_release
_TEXT	SEGMENT
_blkbuf$ = 8						; size = 4
_Bbuf_release PROC					; COMDAT

; 519  : {

  00000	56		 push	 esi

; 520  :     //Bbuf_msg(blkbuf);
; 521  :     ASSERT( blkbuf->bb_refcnt > 0 );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _blkbuf$[esp]
  00005	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00009	7f 26		 jg	 SHORT $LN4@Bbuf_relea
  0000b	68 09 02 00 00	 push	 521			; 00000209H
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_08HDNGNFCH@blkbuf?4c?$AA@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HLLDADII@blkbuf?9?$DObb_refcnt?5?$DO?50?$AA@
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001f	e8 00 00 00 00	 call	 __printf
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00029	e8 00 00 00 00	 call	 _Sys_halt
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@Bbuf_relea:

; 522  :     if( --blkbuf->bb_refcnt < 0 )

  00031	83 46 28 ff	 add	 DWORD PTR [esi+40], -1
  00035	b8 00 00 00 00	 mov	 eax, 0
  0003a	5e		 pop	 esi
  0003b	0f 99 c0	 setns	 al
  0003e	83 e8 01	 sub	 eax, 1

; 523  :         return RESULT_FAILED;
; 524  :     return RESULT_SUCCEED;
; 525  : }

  00041	c3		 ret	 0
_Bbuf_release ENDP
_TEXT	ENDS
PUBLIC	_Bbuf_sync
EXTRN	_Lck_free:PROC
EXTRN	_Dev_write:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Bbuf_sync
_TEXT	SEGMENT
___psw$ = -4						; size = 4
_Bbuf_sync PROC						; COMDAT

; 542  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 543  :     blkbuf_t      * blkbuf = bb_used;

  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _bb_used

; 544  :     CRITICAL_DECLARE(bb_lock);
; 545  : 
; 546  :     CRITICAL_BEGIN();

  00008	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 547  :     while( blkbuf )

  0000d	85 f6		 test	 esi, esi
  0000f	89 44 24 04	 mov	 DWORD PTR ___psw$[esp+8], eax
  00013	74 3f		 je	 SHORT $LN5@Bbuf_sync
  00015	57		 push	 edi
$LL6@Bbuf_sync:

; 548  :     {
; 549  :         if( blkbuf->bb_flags & BBUF_FLAGS_DIRTED )

  00016	f6 46 10 01	 test	 BYTE PTR [esi+16], 1
  0001a	74 30		 je	 SHORT $LN1@Bbuf_sync

; 550  :             BBUF_WRITE(blkbuf);

  0001c	8d 7e 18	 lea	 edi, DWORD PTR [esi+24]
  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 _Lck_lock
  00025	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00028	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0002b	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0002e	68 00 10 00 00	 push	 4096			; 00001000H
  00033	50		 push	 eax
  00034	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00037	51		 push	 ecx
  00038	52		 push	 edx
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _Dev_write
  0003f	83 66 10 fe	 and	 DWORD PTR [esi+16], -2	; fffffffeH
  00043	57		 push	 edi
  00044	e8 00 00 00 00	 call	 _Lck_free
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@Bbuf_sync:

; 551  :         blkbuf = blkbuf->bb_next;

  0004c	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0004f	85 f6		 test	 esi, esi
  00051	75 c3		 jne	 SHORT $LL6@Bbuf_sync
  00053	5f		 pop	 edi
$LN5@Bbuf_sync:

; 552  :     }
; 553  :     CRITICAL_END();

  00054	8b 4c 24 04	 mov	 ecx, DWORD PTR ___psw$[esp+8]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 _Cpu_psw_set
  0005e	83 c4 04	 add	 esp, 4

; 554  : 
; 555  :     return RESULT_SUCCEED;

  00061	33 c0		 xor	 eax, eax
  00063	5e		 pop	 esi

; 556  : }

  00064	59		 pop	 ecx
  00065	c3		 ret	 0
_Bbuf_sync ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@ ; `string'
PUBLIC	??_C@_06IMPBIGNP@bbelim?$AA@			; `string'
PUBLIC	_Bbuf_initial
EXTRN	_Koum_release:PROC
EXTRN	_Proc_create:PROC
EXTRN	__memzero:PROC
_BSS	SEGMENT
_bb_stack DB	0400H DUP (?)
_bb_buffer DB	020000H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
CONST	SEGMENT
??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@ DB 'INVALID_HAND'
	DB	'LE != handle', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06IMPBIGNP@bbelim?$AA@
CONST	SEGMENT
??_C@_06IMPBIGNP@bbelim?$AA@ DB 'bbelim', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Bbuf_initial
_TEXT	SEGMENT
_Bbuf_initial PROC					; COMDAT

; 573  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 574  :     int             i       = 0;
; 575  :     byte_t        * bbuf    = NULL;    /*  块缓存地址，*/
; 576  :     handle_t        handle  = INVALID_HANDLE;
; 577  :     blkbuf_t      * blkbuf  = (blkbuf_t *)bb_buffer;
; 578  : 
; 579  :     bb_free         = NULL;

  00002	33 ed		 xor	 ebp, ebp
  00004	56		 push	 esi

; 580  :     bb_used         = NULL;
; 581  :     bb_used_tail    = NULL;
; 582  :     bb_total_free   = 0;
; 583  :     for( i = 0 ; i < BBUF_BUCKETS ; i++)
; 584  :         bb_buckets[i] = NULL;
; 585  :     /*  计算出缓存区的尾部  */
; 586  :     bbuf = (byte_t *)(((uint_t)bb_buffer + BLKBUF_SIZE - BBUF_SIZE) & ~7);

  00005	bb 00 f0 01 00	 mov	 ebx, OFFSET _bb_buffer+126976
  0000a	57		 push	 edi
  0000b	33 c0		 xor	 eax, eax
  0000d	83 e3 f8	 and	 ebx, -8			; fffffff8H

; 587  :     /*  构造可用块缓存列表  */
; 588  :     for( ; bbuf > (byte_t *)(blkbuf + 1) ; bbuf -= BBUF_SIZE,++blkbuf)

  00010	81 fb 38 00 00
	00		 cmp	 ebx, OFFSET _bb_buffer+56
  00016	b9 37 01 00 00	 mov	 ecx, 311		; 00000137H
  0001b	bf 00 00 00 00	 mov	 edi, OFFSET _bb_buckets
  00020	89 2d 00 00 00
	00		 mov	 DWORD PTR _bb_free, ebp
  00026	89 2d 00 00 00
	00		 mov	 DWORD PTR _bb_used, ebp
  0002c	89 2d 00 00 00
	00		 mov	 DWORD PTR _bb_used_tail, ebp
  00032	89 2d 00 00 00
	00		 mov	 DWORD PTR _bb_total_free, ebp
  00038	f3 ab		 rep stosd
  0003a	76 57		 jbe	 SHORT $LN5@Bbuf_initi

; 580  :     bb_used         = NULL;
; 581  :     bb_used_tail    = NULL;
; 582  :     bb_total_free   = 0;
; 583  :     for( i = 0 ; i < BBUF_BUCKETS ; i++)
; 584  :         bb_buckets[i] = NULL;
; 585  :     /*  计算出缓存区的尾部  */
; 586  :     bbuf = (byte_t *)(((uint_t)bb_buffer + BLKBUF_SIZE - BBUF_SIZE) & ~7);

  0003c	be 08 00 00 00	 mov	 esi, OFFSET _bb_buffer+8
$LL7@Bbuf_initi:

; 589  :     {
; 590  :         _memzero(blkbuf,sizeof(blkbuf_t));

  00041	8d 7e f8	 lea	 edi, DWORD PTR [esi-8]
  00044	6a 38		 push	 56			; 00000038H
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 __memzero

; 591  :         blkbuf->bb_buffer = bbuf;
; 592  :         Bbuf_put(blkbuf);

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _bb_free
  00051	83 c4 08	 add	 esp, 8
  00054	3b c5		 cmp	 eax, ebp
  00056	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00059	89 2f		 mov	 DWORD PTR [edi], ebp
  0005b	89 6e fc	 mov	 DWORD PTR [esi-4], ebp
  0005e	89 2e		 mov	 DWORD PTR [esi], ebp
  00060	89 6e 04	 mov	 DWORD PTR [esi+4], ebp
  00063	89 6e 24	 mov	 DWORD PTR [esi+36], ebp
  00066	89 6e 28	 mov	 DWORD PTR [esi+40], ebp
  00069	89 6e 2c	 mov	 DWORD PTR [esi+44], ebp
  0006c	89 6e 20	 mov	 DWORD PTR [esi+32], ebp
  0006f	89 3d 00 00 00
	00		 mov	 DWORD PTR _bb_free, edi
  00075	74 05		 je	 SHORT $LN13@Bbuf_initi
  00077	89 46 fc	 mov	 DWORD PTR [esi-4], eax
  0007a	89 38		 mov	 DWORD PTR [eax], edi
$LN13@Bbuf_initi:
  0007c	83 05 00 00 00
	00 01		 add	 DWORD PTR _bb_total_free, 1
  00083	83 c6 38	 add	 esi, 56			; 00000038H
  00086	81 eb 00 10 00
	00		 sub	 ebx, 4096		; 00001000H
  0008c	8d 46 30	 lea	 eax, DWORD PTR [esi+48]
  0008f	3b d8		 cmp	 ebx, eax
$bbuf_put_end$2231:
  00091	77 ae		 ja	 SHORT $LL7@Bbuf_initi
$LN5@Bbuf_initi:

; 593  :     }
; 594  :     bb_total = bb_total_free;

  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _bb_total_free

; 595  :     /*  创建块缓存淘汰进程  */
; 596  :     handle = Proc_create("bbelim",32,1,Bbuf_eliminate,NULL,
; 597  :         STACK_MAKE(bb_stack,BBUF_STACK),STACK_SIZE(bb_stack,BBUF_STACK));

  00099	b8 00 04 00 00	 mov	 eax, OFFSET _bb_stack+1024
  0009e	83 e0 fc	 and	 eax, -4			; fffffffcH
  000a1	8b d0		 mov	 edx, eax
  000a3	81 ea 00 00 00
	00		 sub	 edx, OFFSET _bb_stack
  000a9	52		 push	 edx
  000aa	50		 push	 eax
  000ab	55		 push	 ebp
  000ac	68 00 00 00 00	 push	 OFFSET _Bbuf_eliminate
  000b1	6a 01		 push	 1
  000b3	6a 20		 push	 32			; 00000020H
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_06IMPBIGNP@bbelim?$AA@
  000ba	89 0d 00 00 00
	00		 mov	 DWORD PTR _bb_total, ecx
  000c0	e8 00 00 00 00	 call	 _Proc_create
  000c5	8b f0		 mov	 esi, eax
  000c7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 598  :     ASSERT( INVALID_HANDLE != handle);

  000ca	3b f5		 cmp	 esi, ebp
  000cc	75 26		 jne	 SHORT $LN3@Bbuf_initi
  000ce	68 56 02 00 00	 push	 598			; 00000256H
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_08HDNGNFCH@blkbuf?4c?$AA@
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  000e2	e8 00 00 00 00	 call	 __printf
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  000ec	e8 00 00 00 00	 call	 _Sys_halt
  000f1	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@Bbuf_initi:

; 599  :     Handle_release(handle);

  000f4	56		 push	 esi
  000f5	e8 00 00 00 00	 call	 _Koum_release
  000fa	83 c4 04	 add	 esp, 4
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5d		 pop	 ebp
  00100	5b		 pop	 ebx

; 600  : #ifdef _CFG_SMP_
; 601  :     bb_lock = 0;
; 602  : #endif  /*  _CFG_SMP_   */
; 603  : }

  00101	c3		 ret	 0
_Bbuf_initial ENDP
_TEXT	ENDS
END
