; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\clock.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_ticks:DWORD
_DATA	ENDS
_BSS	SEGMENT
?tmid@?1??Timer_create@@9@9 DD 01H DUP (?)		; `Timer_create'::`2'::tmid
?watch@?1??Timer_handle@@9@9 DD 01H DUP (?)		; `Timer_handle'::`2'::watch
_BSS	ENDS
PUBLIC	_Timer_create
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Machine_clock_frequency_get:PROC
EXTRN	_Cpu_disable_interrupt:PROC
_BSS	SEGMENT
_timer_pool DB	0c0H DUP (?)
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\kernel\clock.c
_BSS	ENDS
;	COMDAT _Timer_create
_TEXT	SEGMENT
_millisecond$ = 8					; size = 4
_repeat$ = 12						; size = 4
_handle$ = 16						; size = 4
_param$ = 20						; size = 4
_Timer_create PROC					; COMDAT

; 82   :     static int              tmid    = 0;
; 83   :     timer_t             *   tm      = NULL;
; 84   :     int                     i       = 0;
; 85   :     CRITICAL_DECLARE(timer_lock);
; 86   : 
; 87   : #ifdef CHECK_PARAMETER
; 88   :     if( ticks <= 0 || NULL == handle)   /*  参数校验    */

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ticks
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	85 c0		 test	 eax, eax
  0000b	0f 86 e2 00 00
	00		 jbe	 $LN15@Timer_crea
  00011	8b 5c 24 14	 mov	 ebx, DWORD PTR _handle$[esp+4]
  00015	85 db		 test	 ebx, ebx
  00017	0f 84 d6 00 00
	00		 je	 $LN15@Timer_crea
  0001d	57		 push	 edi

; 90   : #endif  /*  CHECK_PARAMETER */
; 91   : 
; 92   :     CRITICAL_BEGIN();

  0001e	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00023	8b f8		 mov	 edi, eax

; 93   : 
; 94   :     for( i = 0 ; i < TIMER_MAX ; i++)

  00025	33 c9		 xor	 ecx, ecx
  00027	b8 14 00 00 00	 mov	 eax, OFFSET _timer_pool+20
  0002c	8d 64 24 00	 npad	 4
$LL11@Timer_crea:

; 95   :     {
; 96   :         if( TIMER_IS_FREE(timer_pool + i) )

  00030	39 30		 cmp	 DWORD PTR [eax], esi
  00032	74 12		 je	 SHORT $LN27@Timer_crea
  00034	83 c0 18	 add	 eax, 24			; 00000018H
  00037	83 c1 01	 add	 ecx, 1
  0003a	3d d4 00 00 00	 cmp	 eax, OFFSET _timer_pool+212
  0003f	7c ef		 jl	 SHORT $LL11@Timer_crea

; 111  :                 continue;
; 112  : 
; 113  :             if( timer_pool[i].tm_id == tmid )

  00041	e9 94 00 00 00	 jmp	 $LN7@Timer_crea
$LN27@Timer_crea:

; 97   :         {
; 98   :             tm = timer_pool + i;

  00046	8d 34 49	 lea	 esi, DWORD PTR [ecx+ecx*2]

; 99   :             tm->tm_handle = (tm_handle_t)(-1);

  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?tmid@?1??Timer_create@@9@9
  0004f	8d 34 f5 00 00
	00 00		 lea	 esi, DWORD PTR _timer_pool[esi*8]
  00056	c7 46 14 ff ff
	ff ff		 mov	 DWORD PTR [esi+20], -1
  0005d	8d 49 00	 npad	 3
$create_timer_tmid$1622:

; 100  :             break;
; 101  :         }
; 102  :     }
; 103  :     if( tm )    /*  tm不为0，表示系统可以创建定时器     */
; 104  :     {
; 105  : create_timer_tmid:
; 106  :         tmid++;

  00060	83 c1 01	 add	 ecx, 1

; 107  :         if( tmid <= 0 ) tmid = 1;

  00063	85 c9		 test	 ecx, ecx
  00065	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tmid@?1??Timer_create@@9@9, ecx
  0006b	7f 0b		 jg	 SHORT $LN6@Timer_crea
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tmid@?1??Timer_create@@9@9, ecx
$LN6@Timer_crea:

; 108  :         for( i = 0 ; i < TIMER_MAX ; i++)

  00078	b8 00 00 00 00	 mov	 eax, OFFSET _timer_pool
  0007d	8d 49 00	 npad	 3
$LL5@Timer_crea:
  00080	3d c0 00 00 00	 cmp	 eax, OFFSET _timer_pool+192
  00085	7d 0f		 jge	 SHORT $LN3@Timer_crea

; 109  :         {
; 110  :             if( !TIMER_IS_VALID(timer_pool + i) )

  00087	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0008b	74 04		 je	 SHORT $LN4@Timer_crea

; 111  :                 continue;
; 112  : 
; 113  :             if( timer_pool[i].tm_id == tmid )

  0008d	39 08		 cmp	 DWORD PTR [eax], ecx
  0008f	74 cf		 je	 SHORT $create_timer_tmid$1622
$LN4@Timer_crea:

; 108  :         for( i = 0 ; i < TIMER_MAX ; i++)

  00091	83 c0 18	 add	 eax, 24			; 00000018H
  00094	eb ea		 jmp	 SHORT $LL5@Timer_crea
$LN3@Timer_crea:

; 114  :                 goto create_timer_tmid;
; 115  :         }
; 116  : 
; 117  :         /*
; 118  :          *  对定时器进行设置，定时器的上限和重复次数都设置了上限
; 119  :          */
; 120  :         tm->tm_id       = tmid;

  00096	89 0e		 mov	 DWORD PTR [esi], ecx

; 121  :         tm->tm_ticks    = (int)MILIONSECOND_TO_TICKS(millisecond & 0x7FFFFFFF);

  00098	e8 00 00 00 00	 call	 _Machine_clock_frequency_get
  0009d	8b 54 24 10	 mov	 edx, DWORD PTR _millisecond$[esp+8]
  000a1	0f b7 c8	 movzx	 ecx, ax
  000a4	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  000aa	0f af ca	 imul	 ecx, edx
  000ad	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  000b2	f7 e1		 mul	 ecx

; 122  :         tm->tm_left     = (int)tm->tm_ticks;
; 123  :         tm->tm_repeat   = MIN(repeat,TIMER_REPEAT_MAX);

  000b4	8b 44 24 14	 mov	 eax, DWORD PTR _repeat$[esp+8]
  000b8	c1 ea 06	 shr	 edx, 6
  000bb	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  000c0	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000c3	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000c6	7c 05		 jl	 SHORT $LN20@Timer_crea
  000c8	b8 30 75 00 00	 mov	 eax, 30000		; 00007530H
$LN20@Timer_crea:
  000cd	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 124  :         tm->tm_param    = param;

  000d0	8b 44 24 1c	 mov	 eax, DWORD PTR _param$[esp+8]
  000d4	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 125  :         tm->tm_handle   = handle;

  000d7	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
$LN7@Timer_crea:

; 126  :     }
; 127  :     CRITICAL_END();

  000da	57		 push	 edi
  000db	e8 00 00 00 00	 call	 _Cpu_psw_set
  000e0	83 c4 04	 add	 esp, 4

; 128  : 
; 129  :     return tm?tm->tm_id:(-1);

  000e3	85 f6		 test	 esi, esi
  000e5	5f		 pop	 edi
  000e6	74 05		 je	 SHORT $LN21@Timer_crea
  000e8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx

; 130  : }

  000ec	c3		 ret	 0
$LN21@Timer_crea:
  000ed	5e		 pop	 esi

; 128  : 
; 129  :     return tm?tm->tm_id:(-1);

  000ee	83 c8 ff	 or	 eax, -1
  000f1	5b		 pop	 ebx

; 130  : }

  000f2	c3		 ret	 0
$LN15@Timer_crea:
  000f3	5e		 pop	 esi

; 89   :         return 0;

  000f4	33 c0		 xor	 eax, eax
  000f6	5b		 pop	 ebx

; 130  : }

  000f7	c3		 ret	 0
_Timer_create ENDP
_TEXT	ENDS
PUBLIC	_Timer_delete
EXTRN	__memzero:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Timer_delete
_TEXT	SEGMENT
_id$ = 8						; size = 4
_Timer_delete PROC					; COMDAT

; 147  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 148  :     result_t                ret     = RESULT_FAILED;

  00002	83 ce ff	 or	 esi, -1

; 149  :     int                     i       = 0;
; 150  :     CRITICAL_DECLARE(timer_lock);
; 151  : 
; 152  :     CRITICAL_BEGIN();

  00005	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0000a	8b 4c 24 0c	 mov	 ecx, DWORD PTR _id$[esp+4]
  0000e	8b f8		 mov	 edi, eax
  00010	b8 00 00 00 00	 mov	 eax, OFFSET _timer_pool
$LL4@Timer_dele:

; 153  :     for( ; i < TIMER_MAX ; i++)
; 154  :     {
; 155  :         if( timer_pool[i].tm_id == id)

  00015	39 08		 cmp	 DWORD PTR [eax], ecx
  00017	74 18		 je	 SHORT $LN11@Timer_dele
  00019	83 c0 18	 add	 eax, 24			; 00000018H
  0001c	3d c0 00 00 00	 cmp	 eax, OFFSET _timer_pool+192
  00021	7c f2		 jl	 SHORT $LL4@Timer_dele

; 158  :             ret = RESULT_SUCCEED;
; 159  :             break;
; 160  :         }
; 161  :     }
; 162  :     CRITICAL_END();

  00023	57		 push	 edi
  00024	e8 00 00 00 00	 call	 _Cpu_psw_set
  00029	83 c4 04	 add	 esp, 4
  0002c	5f		 pop	 edi

; 163  : 
; 164  :     return ret;

  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi

; 165  : }

  00030	c3		 ret	 0
$LN11@Timer_dele:

; 156  :         {
; 157  :             TIMER_ZERO(timer_pool + id);

  00031	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00034	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR _timer_pool[eax*8]
  0003b	6a 18		 push	 24			; 00000018H
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 __memzero
  00043	83 c4 08	 add	 esp, 8

; 158  :             ret = RESULT_SUCCEED;
; 159  :             break;
; 160  :         }
; 161  :     }
; 162  :     CRITICAL_END();

  00046	57		 push	 edi
  00047	33 f6		 xor	 esi, esi
  00049	e8 00 00 00 00	 call	 _Cpu_psw_set
  0004e	83 c4 04	 add	 esp, 4
  00051	5f		 pop	 edi

; 163  : 
; 164  :     return ret;

  00052	8b c6		 mov	 eax, esi
  00054	5e		 pop	 esi

; 165  : }

  00055	c3		 ret	 0
_Timer_delete ENDP
_TEXT	ENDS
EXTRN	_Cpu_tas_i:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Timer_handle
_TEXT	SEGMENT
_Timer_handle PROC					; COMDAT

; 183  :     static int              watch   = 0;
; 184  :     timer_t             *   tm      = NULL;
; 185  :     int                     i       = 0;
; 186  : 
; 187  :     /*
; 188  :      *  这里要注意: 
; 189  :      *  在处理定时器的时候，如果定时器较多，且执行时间长，则有可能发生嵌套，
; 190  :      *  因此应设置检测变量
; 191  :      */
; 192  :     if( Cpu_tas(&watch,0,1) == 0 )

  00000	6a 01		 push	 1
  00002	6a 00		 push	 0
  00004	68 00 00 00 00	 push	 OFFSET ?watch@?1??Timer_handle@@9@9
  00009	e8 00 00 00 00	 call	 _Cpu_tas_i
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	85 c0		 test	 eax, eax
  00013	74 67		 je	 SHORT $LN10@Timer_hand
  00015	56		 push	 esi

; 193  :         return ;
; 194  :     for( i = 0 ; i < TIMER_MAX ; i++)

  00016	be 14 00 00 00	 mov	 esi, OFFSET _timer_pool+20
  0001b	eb 03 8d 49 00	 npad	 5
$LL8@Timer_hand:

; 195  :     {
; 196  :         tm = timer_pool + i;
; 197  :         /*  
; 198  :          *  跳过无效的或者未到时的定时器
; 199  :          */
; 200  :         if( !TIMER_IS_VALID(tm) || --tm->tm_left > 0)       

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	85 c0		 test	 eax, eax
  00024	74 40		 je	 SHORT $LN7@Timer_hand
  00026	83 46 f4 ff	 add	 DWORD PTR [esi-12], -1
  0002a	83 7e f4 00	 cmp	 DWORD PTR [esi-12], 0
  0002e	7f 36		 jg	 SHORT $LN7@Timer_hand

; 201  :             continue;
; 202  :         tm->tm_handle(tm->tm_param);

  00030	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00033	51		 push	 ecx
  00034	ff d0		 call	 eax

; 203  :         /*
; 204  :          *  如果是无限重复定时器，重新设置定时间隔
; 205  :          */
; 206  :         if( TIMER_IS_INFINITE(tm) )                    

  00036	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00039	83 c4 04	 add	 esp, 4
  0003c	85 c0		 test	 eax, eax
  0003e	7d 08		 jge	 SHORT $LN14@Timer_hand

; 207  :         {
; 208  :             tm->tm_left = tm->tm_ticks;

  00040	8b 56 f0	 mov	 edx, DWORD PTR [esi-16]
  00043	89 56 f4	 mov	 DWORD PTR [esi-12], edx

; 209  :             continue;

  00046	eb 1e		 jmp	 SHORT $LN7@Timer_hand
$LN14@Timer_hand:

; 210  :         }
; 211  :         if( TIMER_CAN_REPEAT(tm) )

  00048	74 0e		 je	 SHORT $LN2@Timer_hand

; 212  :         {
; 213  :             tm->tm_left = tm->tm_ticks;

  0004a	8b 4e f0	 mov	 ecx, DWORD PTR [esi-16]

; 214  :             --tm->tm_repeat;

  0004d	83 c0 ff	 add	 eax, -1
  00050	89 4e f4	 mov	 DWORD PTR [esi-12], ecx
  00053	89 46 f8	 mov	 DWORD PTR [esi-8], eax

; 215  :         }
; 216  :         else

  00056	eb 0e		 jmp	 SHORT $LN7@Timer_hand
$LN2@Timer_hand:

; 217  :             TIMER_ZERO(tm);

  00058	8d 56 ec	 lea	 edx, DWORD PTR [esi-20]
  0005b	6a 18		 push	 24			; 00000018H
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 __memzero
  00063	83 c4 08	 add	 esp, 8
$LN7@Timer_hand:
  00066	83 c6 18	 add	 esi, 24			; 00000018H
  00069	81 fe d4 00 00
	00		 cmp	 esi, OFFSET _timer_pool+212
  0006f	7c af		 jl	 SHORT $LL8@Timer_hand

; 218  :     }
; 219  :     watch = 0;

  00071	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?watch@?1??Timer_handle@@9@9, 0
  0007b	5e		 pop	 esi
$LN10@Timer_hand:

; 220  : }

  0007c	c3		 ret	 0
_Timer_handle ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Clk_default_ticks_hook
_TEXT	SEGMENT
_Clk_default_ticks_hook PROC				; COMDAT

; 227  : }

  00000	c3		 ret	 0
_Clk_default_ticks_hook ENDP
_TEXT	ENDS
EXTRN	_proc_need_sched:DWORD
EXTRN	_Proc_ticks:PROC
EXTRN	_proc_current:DWORD
_BSS	SEGMENT
_clk_ticks_hook DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Clk_do_clock
_TEXT	SEGMENT
_notuse1$ = 8						; size = 4
_notuse2$ = 12						; size = 4
_Clk_do_clock PROC					; COMDAT

; 267  :     --proc_current->proc_cpu_time;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	83 40 50 ff	 add	 DWORD PTR [eax+80], -1

; 268  :     ++proc_current->proc_run_time;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0000e	83 40 34 01	 add	 DWORD PTR [eax+52], 1

; 269  :     Proc_ticks();

  00012	e8 00 00 00 00	 call	 _Proc_ticks

; 270  :     /*
; 271  :      *  调用回调函数
; 272  :      */
; 273  :     clk_ticks_hook();

  00017	ff 15 00 00 00
	00		 call	 DWORD PTR _clk_ticks_hook

; 274  : #ifdef _CFG_TIMER_ENABLE_
; 275  :     /*  
; 276  :      *  处理系统定时器
; 277  :      */
; 278  :     Timer_handle();

  0001d	e8 00 00 00 00	 call	 _Timer_handle

; 279  : #endif  /*  _CFG_TIMER_ENABLE_   * /
; 280  :     /*  
; 281  :      *  进程时间消耗完后，重新计算调度算子并且标记为需要调度，在每次中断或者
; 282  :      *  系统调用后，都会进行调度
; 283  :      */
; 284  :     if( proc_current->proc_cpu_time < 1 )

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00027	83 78 50 01	 cmp	 DWORD PTR [eax+80], 1
  0002b	7d 11		 jge	 SHORT $LN4@Clk_do_clo

; 285  :     {                    
; 286  :         /*  避免某些编译器发出警告     */
; 287  :         notuse1 = notuse1;
; 288  :         notuse2 = notuse2;
; 289  :         proc_current->proc_cpu_time = 0;

  0002d	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 290  :         proc_need_sched = 1;

  00034	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN4@Clk_do_clo:

; 291  :     } 
; 292  :     
; 293  :     return 0;

  0003e	33 c0		 xor	 eax, eax

; 294  : }

  00040	c3		 ret	 0
_Clk_do_clock ENDP
_TEXT	ENDS
PUBLIC	_Clk_get_ticks
; Function compile flags: /Ogtpy
;	COMDAT _Clk_get_ticks
_TEXT	SEGMENT
_Clk_get_ticks PROC					; COMDAT

; 316  : #if _CFG_WORD_ == 8 || _CFG_WORD_ == 16
; 317  :     uint32_t                ret     = 0;
; 318  :     CRITICAL_DECLARE(NULL);
; 319  : 
; 320  :     CRITICAL_BEGIN();
; 321  :     ret = ticks;
; 322  :     CRITICAL_END();
; 323  :     return ret;
; 324  : #else
; 325  :     return ticks;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _ticks

; 326  : #endif
; 327  : }

  00005	c3		 ret	 0
_Clk_get_ticks ENDP
_TEXT	ENDS
PUBLIC	_Clk_delay
; Function compile flags: /Ogtpy
;	COMDAT _Clk_delay
_TEXT	SEGMENT
_millisecond$ = 8					; size = 4
_Clk_delay PROC						; COMDAT

; 349  :     uint32_t    start;
; 350  :     
; 351  :     millisecond = MILIONSECOND_TO_TICKS(millisecond);

  00000	e8 00 00 00 00	 call	 _Machine_clock_frequency_get
  00005	0f b7 c8	 movzx	 ecx, ax
  00008	0f af 4c 24 04	 imul	 ecx, DWORD PTR _millisecond$[esp-4]
  0000d	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00012	f7 e1		 mul	 ecx

; 352  :     start   = Clk_get_ticks();

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _ticks
  00019	c1 ea 06	 shr	 edx, 6
  0001c	8d 64 24 00	 npad	 4
$LL2@Clk_delay:

; 353  :     while( Clk_get_ticks() - start < millisecond ) 

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ticks
  00026	2b c8		 sub	 ecx, eax
  00028	3b ca		 cmp	 ecx, edx
  0002a	72 f4		 jb	 SHORT $LL2@Clk_delay

; 354  :         ; 
; 355  : }

  0002c	c3		 ret	 0
_Clk_delay ENDP
_TEXT	ENDS
PUBLIC	_Clk_ticks_hook_get
; Function compile flags: /Ogtpy
;	COMDAT _Clk_ticks_hook_get
_TEXT	SEGMENT
_Clk_ticks_hook_get PROC				; COMDAT

; 374  :     return clk_ticks_hook;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _clk_ticks_hook

; 375  : }

  00005	c3		 ret	 0
_Clk_ticks_hook_get ENDP
_TEXT	ENDS
PUBLIC	_Clk_ticks_hook_set
; Function compile flags: /Ogtpy
;	COMDAT _Clk_ticks_hook_set
_TEXT	SEGMENT
_tickshook$ = 8						; size = 4
_Clk_ticks_hook_set PROC				; COMDAT

; 394  :     void        *   ret    = NULL ;
; 395  : 
; 396  :     if( NULL == tickshook )

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _tickshook$[esp-4]
  00004	85 c9		 test	 ecx, ecx

; 397  :         return clk_ticks_hook;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _clk_ticks_hook
  0000b	74 06		 je	 SHORT $LN2@Clk_ticks_

; 398  :     ret = clk_ticks_hook;
; 399  :     clk_ticks_hook = tickshook;

  0000d	89 0d 00 00 00
	00		 mov	 DWORD PTR _clk_ticks_hook, ecx
$LN2@Clk_ticks_:

; 400  : 
; 401  :     return ret;
; 402  : }

  00013	c3		 ret	 0
_Clk_ticks_hook_set ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GMALNMBL@OK?$CB?6?$AA@			; `string'
PUBLIC	??_C@_0BF@FONJNPCB@clock?5initial?4?4?4?5?5?5?5?$AA@ ; `string'
PUBLIC	_Clk_initial
EXTRN	_Machine_ivt_set:PROC
EXTRN	__printk:PROC
;	COMDAT ??_C@_04GMALNMBL@OK?$CB?6?$AA@
CONST	SEGMENT
??_C@_04GMALNMBL@OK?$CB?6?$AA@ DB 'OK!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FONJNPCB@clock?5initial?4?4?4?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BF@FONJNPCB@clock?5initial?4?4?4?5?5?5?5?$AA@ DB 'clock initial...'
	DB	'    ', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Clk_initial
_TEXT	SEGMENT
_Clk_initial PROC					; COMDAT

; 406  :     _printk("clock initial...    ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FONJNPCB@clock?5initial?4?4?4?5?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 407  : #ifdef _CFG_SMP_
; 408  :     timer_lock  = 0;
; 409  :     ticks_lock  = 0;
; 410  : #endif  /*  _CFG_SMP_   */
; 411  :     ticks       = 0;
; 412  :     _memzero(timer_pool,TIMER_MAX * sizeof( timer_t));

  0000a	68 c0 00 00 00	 push	 192			; 000000c0H
  0000f	68 00 00 00 00	 push	 OFFSET _timer_pool
  00014	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ticks, 0
  0001e	e8 00 00 00 00	 call	 __memzero

; 413  :     clk_ticks_hook = Clk_default_ticks_hook;
; 414  :     Machine_ivt_set(ISR_CLOCK,Clk_do_clock);

  00023	68 00 00 00 00	 push	 OFFSET _Clk_do_clock
  00028	6a 00		 push	 0
  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _clk_ticks_hook, OFFSET _Clk_default_ticks_hook
  00034	e8 00 00 00 00	 call	 _Machine_ivt_set

; 415  :     _printk("OK!\n");

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0003e	e8 00 00 00 00	 call	 __printk
  00043	83 c4 18	 add	 esp, 24			; 00000018H

; 416  : }

  00046	c3		 ret	 0
_Clk_initial ENDP
_TEXT	ENDS
END
