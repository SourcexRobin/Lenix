; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\device.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_Dev_sdl_lock
EXTRN	_Cpu_tas_i:PROC
_BSS	SEGMENT
_dev_sdl_lock DD 01H DUP (?)
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\kernel\device.c
_BSS	ENDS
;	COMDAT _Dev_sdl_lock
_TEXT	SEGMENT
_Dev_sdl_lock PROC					; COMDAT

; 59   : {

$LL2@Dev_sdl_lo:

; 60   :     while( Cpu_tas((int *)&dev_sdl_lock,0,1) )

  00000	6a 01		 push	 1
  00002	6a 00		 push	 0
  00004	68 00 00 00 00	 push	 OFFSET _dev_sdl_lock
  00009	e8 00 00 00 00	 call	 _Cpu_tas_i
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	85 c0		 test	 eax, eax
  00013	75 eb		 jne	 SHORT $LL2@Dev_sdl_lo

; 61   :         ;
; 62   : }

  00015	c3		 ret	 0
_Dev_sdl_lock ENDP
_TEXT	ENDS
PUBLIC	_Dev_sdl_free
; Function compile flags: /Ogtpy
;	COMDAT _Dev_sdl_free
_TEXT	SEGMENT
_Dev_sdl_free PROC					; COMDAT

; 65   :     dev_sdl_lock = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dev_sdl_lock, 0

; 66   : }

  0000a	c3		 ret	 0
_Dev_sdl_free ENDP
_TEXT	ENDS
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Cpu_disable_interrupt:PROC
_BSS	SEGMENT
_dev_fdol DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Dev_get
_TEXT	SEGMENT
_Dev_get PROC						; COMDAT

; 90   : {

  00000	56		 push	 esi

; 91   :     device_t      * dev = dev_fdol;

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _dev_fdol

; 92   :     CRITICAL_DECLARE(dev_fdol_lock);
; 93   : 
; 94   :     CRITICAL_BEGIN();

  00007	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 95   :     if( dev )

  0000c	85 f6		 test	 esi, esi
  0000e	74 22		 je	 SHORT $LN1@Dev_get

; 96   :     {
; 97   :         dev_fdol            = dev_fdol->dev_next;

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dev_fdol
  00016	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 98   :         dev_fdol->dev_prev  = NULL;

  00019	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0001f	89 0d 00 00 00
	00		 mov	 DWORD PTR _dev_fdol, ecx

; 99   :         dev->dev_prev       = NULL;

  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 100  :         dev->dev_next       = NULL;

  0002b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
$LN1@Dev_get:

; 101  :     }
; 102  :     CRITICAL_END();

  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _Cpu_psw_set
  00038	83 c4 04	 add	 esp, 4

; 103  : 
; 104  :     return dev;

  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi

; 105  : }

  0003e	c3		 ret	 0
_Dev_get ENDP
_TEXT	ENDS
EXTRN	__memzero:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Dev_put
_TEXT	SEGMENT
_Dev_put PROC						; COMDAT
; _device$ = esi

; 126  : {

  00000	57		 push	 edi

; 127  :     CRITICAL_DECLARE(dev_fdol_lock);
; 128  : 
; 129  :     CRITICAL_BEGIN();

  00001	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 130  :     DEV_ZERO(device);

  00006	6a 7c		 push	 124			; 0000007cH
  00008	56		 push	 esi
  00009	8b f8		 mov	 edi, eax
  0000b	e8 00 00 00 00	 call	 __memzero

; 131  :     if( dev_fdol )

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR _dev_fdol
  00015	83 c4 08	 add	 esp, 8
  00018	85 c0		 test	 eax, eax
  0001a	74 05		 je	 SHORT $LN1@Dev_put

; 132  :     {
; 133  :         device->dev_next    = dev_fdol; 

  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 134  :         dev_fdol->dev_prev   = device;

  0001f	89 30		 mov	 DWORD PTR [eax], esi
$LN1@Dev_put:

; 135  :     }
; 136  :     dev_fdol = device;
; 137  :     CRITICAL_END();

  00021	57		 push	 edi
  00022	89 35 00 00 00
	00		 mov	 DWORD PTR _dev_fdol, esi
  00028	e8 00 00 00 00	 call	 _Cpu_psw_set
  0002d	83 c4 04	 add	 esp, 4
  00030	5f		 pop	 edi

; 138  : }

  00031	c3		 ret	 0
_Dev_put ENDP
_TEXT	ENDS
_BSS	SEGMENT
_dev_sdl DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Dev_sdl_add
_TEXT	SEGMENT
_Dev_sdl_add PROC					; COMDAT
; _device$ = eax

; 160  :     if(dev_sdl)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dev_sdl
  00006	85 c9		 test	 ecx, ecx

; 161  :     {
; 162  :         device->dev_next  = dev_sdl;
; 163  :         dev_sdl->dev_prev = device;
; 164  :     }
; 165  :         
; 166  :     dev_sdl = device;

  00008	a3 00 00 00 00	 mov	 DWORD PTR _dev_sdl, eax
  0000d	74 05		 je	 SHORT $LN1@Dev_sdl_ad
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00012	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Dev_sdl_ad:

; 167  : }

  00014	c3		 ret	 0
_Dev_sdl_add ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Dev_sdl_del
_TEXT	SEGMENT
_Dev_sdl_del PROC					; COMDAT
; _device$ = eax

; 189  :     if( device == dev_sdl)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _dev_sdl
  00006	3b c1		 cmp	 eax, ecx
  00008	75 1f		 jne	 SHORT $LN4@Dev_sdl_de

; 190  :     {
; 191  :         dev_sdl = dev_sdl->dev_next;

  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 192  :         if( dev_sdl )

  0000d	85 c9		 test	 ecx, ecx
  0000f	89 0d 00 00 00
	00		 mov	 DWORD PTR _dev_sdl, ecx
  00015	74 25		 je	 SHORT $LN1@Dev_sdl_de

; 200  :     }
; 201  :     _memzero(device,sizeof(device_t));

  00017	6a 7c		 push	 124			; 0000007cH
  00019	50		 push	 eax
  0001a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00020	e8 00 00 00 00	 call	 __memzero
  00025	83 c4 08	 add	 esp, 8

; 202  : }

  00028	c3		 ret	 0
$LN4@Dev_sdl_de:

; 193  :             dev_sdl->dev_prev = NULL;
; 194  :     }
; 195  :     else
; 196  :     {
; 197  :         device->dev_prev->dev_next = device->dev_next;

  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 198  :         if( device->dev_next )

  00031	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00034	85 c9		 test	 ecx, ecx
  00036	74 04		 je	 SHORT $LN1@Dev_sdl_de

; 199  :             device->dev_next->dev_prev = device->dev_prev;

  00038	8b 10		 mov	 edx, DWORD PTR [eax]
  0003a	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Dev_sdl_de:

; 200  :     }
; 201  :     _memzero(device,sizeof(device_t));

  0003c	6a 7c		 push	 124			; 0000007cH
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 __memzero
  00044	83 c4 08	 add	 esp, 8

; 202  : }

  00047	c3		 ret	 0
_Dev_sdl_del ENDP
_TEXT	ENDS
EXTRN	__namecmp:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Dev_query_by_name
_TEXT	SEGMENT
_Dev_query_by_name PROC					; COMDAT
; _devname$ = edi

; 223  : {

  00000	56		 push	 esi

; 224  :     device_t      * device = dev_sdl;

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _dev_sdl

; 225  : 
; 226  :     for( ; device ; device = device->dev_next)

  00007	85 f6		 test	 esi, esi
  00009	74 23		 je	 SHORT $LN11@Dev_query_
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@Dev_query_:

; 227  :     {
; 228  :         /*  名称相同并且处于激活状态，才能认为找到设备。*/
; 229  :         if(_namecmp(device->dev_name,devname) == 0 && DEV_IS_ACTIVED(device))

  00010	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00013	57		 push	 edi
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 __namecmp
  0001a	83 c4 08	 add	 esp, 8
  0001d	85 c0		 test	 eax, eax
  0001f	75 06		 jne	 SHORT $LN3@Dev_query_
  00021	f6 46 20 01	 test	 BYTE PTR [esi+32], 1
  00025	75 07		 jne	 SHORT $LN11@Dev_query_
$LN3@Dev_query_:

; 225  : 
; 226  :     for( ; device ; device = device->dev_next)

  00027	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0002a	85 f6		 test	 esi, esi
  0002c	75 e2		 jne	 SHORT $LL4@Dev_query_
$LN11@Dev_query_:

; 230  :             break;
; 231  :     }
; 232  : 
; 233  :     return device;

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi

; 234  : }

  00031	c3		 ret	 0
_Dev_query_by_name ENDP
_TEXT	ENDS
PUBLIC	_Dev_initial
_BSS	SEGMENT
_dev_pool DB	07c0H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Dev_initial
_TEXT	SEGMENT
_Dev_initial PROC					; COMDAT

; 259  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 260  :     device_t      * device      = NULL;
; 261  : 
; 262  :     dev_fdol        = NULL;
; 263  :     dev_sdl         = NULL;
; 264  : #ifdef _CFG_SMP_
; 265  :     dev_fdol_lock   = 0;
; 266  :     dev_sdl_lock    = 0;
; 267  : #endif  /*  _CFG_SMP_   */
; 268  : 
; 269  :     _memzero(dev_pool,DEVICE_MAX * sizeof(device_t));

  00002	68 c0 07 00 00	 push	 1984			; 000007c0H
  00007	68 00 00 00 00	 push	 OFFSET _dev_pool
  0000c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dev_fdol, 0
  00016	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _dev_sdl, 0
  00020	e8 00 00 00 00	 call	 __memzero
  00025	83 c4 08	 add	 esp, 8

; 270  :     /*
; 271  :      *  建立可用设备对象列表
; 272  :      */
; 273  :     for( device = dev_pool ; device <= LAST_DEVICE ; device++)

  00028	be 00 00 00 00	 mov	 esi, OFFSET _dev_pool
  0002d	8d 49 00	 npad	 3
$LL3@Dev_initia:

; 274  :         Dev_put(device);

  00030	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00035	6a 7c		 push	 124			; 0000007cH
  00037	56		 push	 esi
  00038	8b f8		 mov	 edi, eax
  0003a	e8 00 00 00 00	 call	 __memzero
  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR _dev_fdol
  00044	83 c4 08	 add	 esp, 8
  00047	85 c0		 test	 eax, eax
  00049	74 05		 je	 SHORT $LN6@Dev_initia
  0004b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0004e	89 30		 mov	 DWORD PTR [eax], esi
$LN6@Dev_initia:
  00050	57		 push	 edi
  00051	89 35 00 00 00
	00		 mov	 DWORD PTR _dev_fdol, esi
  00057	e8 00 00 00 00	 call	 _Cpu_psw_set
  0005c	83 c6 7c	 add	 esi, 124		; 0000007cH
  0005f	83 c4 04	 add	 esp, 4
  00062	81 fe 44 07 00
	00		 cmp	 esi, OFFSET _dev_pool+1860
  00068	76 c6		 jbe	 SHORT $LL3@Dev_initia
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 275  : }

  0006c	c3		 ret	 0
_Dev_initial ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
PUBLIC	??_C@_0O@GNOLGLLG@assert?5failed?$AA@		; `string'
PUBLIC	??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_06CHPEJBOD@device?$AA@			; `string'
PUBLIC	??_C@_08IOFIHHIH@device?4c?$AA@			; `string'
PUBLIC	_Dev_set_date
EXTRN	__memcpy:PROC
EXTRN	_proc_current:DWORD
EXTRN	_Sys_halt:PROC
EXTRN	__printf:PROC
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
CONST	SEGMENT
??_C@_0O@GNOLGLLG@assert?5failed?$AA@ DB 'assert failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ DB 'a'
	DB	'ssert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHPEJBOD@device?$AA@
CONST	SEGMENT
??_C@_06CHPEJBOD@device?$AA@ DB 'device', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOFIHHIH@device?4c?$AA@
CONST	SEGMENT
??_C@_08IOFIHHIH@device?4c?$AA@ DB 'device.c', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Dev_set_date
_TEXT	SEGMENT
_device$ = 8						; size = 4
_data$ = 12						; size = 4
_size$ = 16						; size = 4
_Dev_set_date PROC					; COMDAT

; 297  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	57		 push	 edi

; 298  :     ASSERT(device);

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _device$[esp+8]
  00007	85 ff		 test	 edi, edi
  00009	75 26		 jne	 SHORT $LN25@Dev_set_da
  0000b	68 2a 01 00 00	 push	 298			; 0000012aH
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_06CHPEJBOD@device?$AA@
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001f	e8 00 00 00 00	 call	 __printf
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00029	e8 00 00 00 00	 call	 _Sys_halt
  0002e	83 c4 14	 add	 esp, 20			; 00000014H
$LN25@Dev_set_da:

; 299  :     ASSERT(data);

  00031	8b 6c 24 14	 mov	 ebp, DWORD PTR _data$[esp+8]
  00035	85 ed		 test	 ebp, ebp
  00037	75 26		 jne	 SHORT $LN21@Dev_set_da
  00039	68 2b 01 00 00	 push	 299			; 0000012bH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_04PJOLNDGD@data?$AA@
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0004d	e8 00 00 00 00	 call	 __printf
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00057	e8 00 00 00 00	 call	 _Sys_halt
  0005c	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@Dev_set_da:

; 300  :     ASSERT(size);

  0005f	8b 5c 24 18	 mov	 ebx, DWORD PTR _size$[esp+8]
  00063	85 db		 test	 ebx, ebx
  00065	75 26		 jne	 SHORT $LN17@Dev_set_da
  00067	68 2c 01 00 00	 push	 300			; 0000012cH
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_04IAGNFIBA@size?$AA@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0007b	e8 00 00 00 00	 call	 __printf
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00085	e8 00 00 00 00	 call	 _Sys_halt
  0008a	83 c4 14	 add	 esp, 20			; 00000014H
$LN17@Dev_set_da:

; 301  : 
; 302  : #ifdef _CFG_CHECK_PARAMETER_
; 303  :     if( NULL == device  )

  0008d	85 ff		 test	 edi, edi
  0008f	75 12		 jne	 SHORT $LN14@Dev_set_da

; 304  :     {
; 305  :         PROC_SET_ERR(ERR_DEV_INVALID);

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00096	5f		 pop	 edi
  00097	5d		 pop	 ebp
  00098	c7 40 38 08 05
	00 00		 mov	 DWORD PTR [eax+56], 1288 ; 00000508H

; 306  :         return NULL;

  0009f	33 c0		 xor	 eax, eax
  000a1	5b		 pop	 ebx

; 330  : }

  000a2	c3		 ret	 0
$LN14@Dev_set_da:

; 307  :     }
; 308  :     if( NULL == data )

  000a3	85 ed		 test	 ebp, ebp
  000a5	75 13		 jne	 SHORT $LN10@Dev_set_da

; 309  :     {
; 310  :         PROC_SET_ERR(ERR_DATA_INVALID);

  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000ad	5f		 pop	 edi
  000ae	5d		 pop	 ebp
  000af	c7 41 38 09 05
	00 00		 mov	 DWORD PTR [ecx+56], 1289 ; 00000509H

; 311  :         return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	5b		 pop	 ebx

; 330  : }

  000b9	c3		 ret	 0
$LN10@Dev_set_da:

; 312  :     }
; 313  :     if( 0 == size)

  000ba	85 db		 test	 ebx, ebx
  000bc	75 13		 jne	 SHORT $LN6@Dev_set_da

; 314  :     {
; 315  :         PROC_SET_ERR(ERR_DATA_SIZE_INVALID);

  000be	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000c4	5f		 pop	 edi
  000c5	5d		 pop	 ebp
  000c6	c7 42 38 0a 05
	00 00		 mov	 DWORD PTR [edx+56], 1290 ; 0000050aH

; 316  :         return NULL;

  000cd	33 c0		 xor	 eax, eax
  000cf	5b		 pop	 ebx

; 330  : }

  000d0	c3		 ret	 0
$LN6@Dev_set_da:
  000d1	56		 push	 esi

; 317  :     }
; 318  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 319  : 
; 320  :     _memzero(device->dev_data,32);

  000d2	8d 77 58	 lea	 esi, DWORD PTR [edi+88]
  000d5	6a 20		 push	 32			; 00000020H
  000d7	56		 push	 esi
  000d8	e8 00 00 00 00	 call	 __memzero
  000dd	83 c4 08	 add	 esp, 8

; 321  :     if( size > 32 )

  000e0	83 fb 20	 cmp	 ebx, 32			; 00000020H
  000e3	76 05		 jbe	 SHORT $LN2@Dev_set_da

; 322  :         device->dev_data_ext = data;

  000e5	89 6f 78	 mov	 DWORD PTR [edi+120], ebp

; 323  :     else

  000e8	eb 12		 jmp	 SHORT $LN1@Dev_set_da
$LN2@Dev_set_da:

; 324  :     {
; 325  :         _memcpy(device->dev_data,data,size);

  000ea	53		 push	 ebx
  000eb	55		 push	 ebp
  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 __memcpy
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 326  :         device->dev_data_ext = NULL;

  000f5	c7 47 78 00 00
	00 00		 mov	 DWORD PTR [edi+120], 0
$LN1@Dev_set_da:

; 327  :     }
; 328  : 
; 329  :     return DEV_DATA(device);

  000fc	8b 7f 78	 mov	 edi, DWORD PTR [edi+120]
  000ff	85 ff		 test	 edi, edi
  00101	8b c7		 mov	 eax, edi
  00103	75 02		 jne	 SHORT $LN30@Dev_set_da
  00105	8b c6		 mov	 eax, esi
$LN30@Dev_set_da:
  00107	5e		 pop	 esi
  00108	5f		 pop	 edi
  00109	5d		 pop	 ebp
  0010a	5b		 pop	 ebx

; 330  : }

  0010b	c3		 ret	 0
_Dev_set_date ENDP
_TEXT	ENDS
PUBLIC	??_C@_05HNNDEAND@entry?$AA@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	_Dev_registe
EXTRN	__nstrcpy:PROC
;	COMDAT ??_C@_05HNNDEAND@entry?$AA@
CONST	SEGMENT
??_C@_05HNNDEAND@entry?$AA@ DB 'entry', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Dev_registe
_TEXT	SEGMENT
_name$ = 8						; size = 4
_entry$ = 12						; size = 4
_param$ = 16						; size = 4
_Dev_registe PROC					; COMDAT

; 357  : {

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 358  :     device_t            *   device      = NULL;
; 359  :     CRITICAL_DECLARE(dev_sdl_lock);
; 360  : 
; 361  :     ASSERT(name);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _name$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	75 26		 jne	 SHORT $LN39@Dev_regist
  0000a	68 69 01 00 00	 push	 361			; 00000169H
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_04MEMAJGDJ@name?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001e	e8 00 00 00 00	 call	 __printf
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00028	e8 00 00 00 00	 call	 _Sys_halt
  0002d	83 c4 14	 add	 esp, 20			; 00000014H
$LN39@Dev_regist:

; 362  :     ASSERT(entry);

  00030	8b 5c 24 10	 mov	 ebx, DWORD PTR _entry$[esp+4]
  00034	85 db		 test	 ebx, ebx
  00036	75 26		 jne	 SHORT $LN35@Dev_regist
  00038	68 6a 01 00 00	 push	 362			; 0000016aH
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_05HNNDEAND@entry?$AA@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0004c	e8 00 00 00 00	 call	 __printf
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00056	e8 00 00 00 00	 call	 _Sys_halt
  0005b	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@Dev_regist:

; 363  : #ifdef _CFG_CHECK_PARAMETER_
; 364  :     if( NULL == name )

  0005e	85 ff		 test	 edi, edi
  00060	75 11		 jne	 SHORT $LN32@Dev_regist

; 365  :     {
; 366  :         PROC_SET_ERR(ERR_NAME_INVALID);

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00068	b8 03 00 00 00	 mov	 eax, 3
  0006d	5f		 pop	 edi
  0006e	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00071	5b		 pop	 ebx

; 425  : }

  00072	c3		 ret	 0
$LN32@Dev_regist:

; 367  :         return ERR_NAME_INVALID;
; 368  :     }
; 369  :     if( NULL == entry )

  00073	85 db		 test	 ebx, ebx
  00075	75 11		 jne	 SHORT $LN24@Dev_regist

; 370  :     {
; 371  :         PROC_SET_ERR(ERR_DEV_ENTRY_INVALID);

  00077	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0007d	b8 07 05 00 00	 mov	 eax, 1287		; 00000507H
  00082	5f		 pop	 edi
  00083	89 42 38	 mov	 DWORD PTR [edx+56], eax
  00086	5b		 pop	 ebx

; 425  : }

  00087	c3		 ret	 0
$LN24@Dev_regist:
  00088	55		 push	 ebp

; 372  :         return ERR_DEV_ENTRY_INVALID;
; 373  :     }
; 374  : #endif  /* _CFG_CHECK_PARAMETER_    */
; 375  :     /*
; 376  :      *    查找该设备名称是否存在，如果存在，则不能注册设备。Lenix保证系统中设
; 377  :      * 备名称唯一
; 378  :      */
; 379  :     CRITICAL_BEGIN();

  00089	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0008e	8b e8		 mov	 ebp, eax

; 380  :     /*
; 381  :      *  查找到名称，说明存在同名设备，不能注册。
; 382  :      */
; 383  :     if( NULL != ( device = Dev_query_by_name(name) ) )

  00090	e8 00 00 00 00	 call	 _Dev_query_by_name
  00095	85 c0		 test	 eax, eax
  00097	74 1e		 je	 SHORT $LN21@Dev_regist

; 384  :     {
; 385  :         PROC_SET_ERR(ERR_DEV_EXIST);

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current

; 386  :         CRITICAL_END();

  0009e	55		 push	 ebp
  0009f	c7 40 38 02 05
	00 00		 mov	 DWORD PTR [eax+56], 1282 ; 00000502H
  000a6	e8 00 00 00 00	 call	 _Cpu_psw_set
  000ab	83 c4 04	 add	 esp, 4
  000ae	5d		 pop	 ebp
  000af	5f		 pop	 edi

; 387  :         return ERR_DEV_EXIST;

  000b0	b8 02 05 00 00	 mov	 eax, 1282		; 00000502H
  000b5	5b		 pop	 ebx

; 425  : }

  000b6	c3		 ret	 0
$LN21@Dev_regist:
  000b7	56		 push	 esi

; 388  :     }
; 389  :     /*
; 390  :      *  到达这里说明系统中没有重名设备，可以注册。
; 391  :      */
; 392  :     if( NULL == (device = Dev_get() ) ) 

  000b8	e8 00 00 00 00	 call	 _Dev_get
  000bd	8b f0		 mov	 esi, eax
  000bf	85 f6		 test	 esi, esi
  000c1	75 1c		 jne	 SHORT $LN17@Dev_regist

; 393  :     {
; 394  :         CRITICAL_END();

  000c3	55		 push	 ebp
  000c4	e8 00 00 00 00	 call	 _Cpu_psw_set

; 395  :         PROC_SET_ERR(ERR_SOURCE_EXHAUST);

  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000cf	83 c4 04	 add	 esp, 4
  000d2	5e		 pop	 esi
  000d3	5d		 pop	 ebp
  000d4	b8 02 00 00 00	 mov	 eax, 2
  000d9	5f		 pop	 edi
  000da	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  000dd	5b		 pop	 ebx

; 425  : }

  000de	c3		 ret	 0
$LN17@Dev_regist:

; 396  :         return ERR_SOURCE_EXHAUST;
; 397  :     }
; 398  :     DEV_ZERO(device);

  000df	6a 7c		 push	 124			; 0000007cH
  000e1	56		 push	 esi
  000e2	e8 00 00 00 00	 call	 __memzero

; 399  :     _nstrcpy(device->dev_name,name,12);

  000e7	6a 0c		 push	 12			; 0000000cH
  000e9	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  000ec	57		 push	 edi
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 __nstrcpy

; 400  :     device->dev_entry = entry;
; 401  :     Dev_sdl_add(device);

  000f3	a1 00 00 00 00	 mov	 eax, DWORD PTR _dev_sdl
  000f8	83 c4 14	 add	 esp, 20			; 00000014H
  000fb	85 c0		 test	 eax, eax
  000fd	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  00100	74 05		 je	 SHORT $LN43@Dev_regist
  00102	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00105	89 30		 mov	 DWORD PTR [eax], esi
$LN43@Dev_regist:

; 402  :     CRITICAL_END();

  00107	55		 push	 ebp
  00108	89 35 00 00 00
	00		 mov	 DWORD PTR _dev_sdl, esi
  0010e	e8 00 00 00 00	 call	 _Cpu_psw_set

; 403  :     /*
; 404  :      *  退出临界段保护后，才能执行驱动入口程序
; 405  :      */
; 406  :     if( entry(device,DEV_ENTRY_FLAG_REG,param) != RESULT_SUCCEED )

  00113	8b 44 24 20	 mov	 eax, DWORD PTR _param$[esp+16]
  00117	50		 push	 eax
  00118	6a 00		 push	 0
  0011a	56		 push	 esi
  0011b	ff d3		 call	 ebx
  0011d	83 c4 10	 add	 esp, 16			; 00000010H
  00120	85 c0		 test	 eax, eax
  00122	74 2f		 je	 SHORT $LN6@Dev_regist

; 407  :     {
; 408  :         /*
; 409  :          *  驱动入口程序执行失败，说明设备没有初始化成功，则将设备从sdl中删除
; 410  :          */
; 411  :         CRITICAL_BEGIN();

  00124	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00129	8b f8		 mov	 edi, eax

; 412  :         Dev_sdl_del(device);

  0012b	8b c6		 mov	 eax, esi
  0012d	e8 00 00 00 00	 call	 _Dev_sdl_del

; 413  :         CRITICAL_END();

  00132	57		 push	 edi
  00133	e8 00 00 00 00	 call	 _Cpu_psw_set
  00138	83 c4 04	 add	 esp, 4

; 414  :         Dev_put(device);

  0013b	e8 00 00 00 00	 call	 _Dev_put

; 415  :         PROC_SET_ERR(ERR_DEV_REG_FAILED);

  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00146	5e		 pop	 esi
  00147	5d		 pop	 ebp
  00148	b8 03 05 00 00	 mov	 eax, 1283		; 00000503H
  0014d	5f		 pop	 edi
  0014e	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00151	5b		 pop	 ebx

; 425  : }

  00152	c3		 ret	 0
$LN6@Dev_regist:

; 416  :         return ERR_DEV_REG_FAILED;
; 417  :     }
; 418  :     /*
; 419  :      *  驱动入口程序成功完成后，才可以激活设备。
; 420  :      *  激活时，不用锁设备，因为激活后才有可能打开设备。
; 421  :      */
; 422  :     DEV_ACTIVE(device);

  00153	83 4e 20 01	 or	 DWORD PTR [esi+32], 1

; 423  :     PROC_NO_ERR();

  00157	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0015d	5e		 pop	 esi
  0015e	5d		 pop	 ebp
  0015f	5f		 pop	 edi
  00160	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 424  :     return RESULT_SUCCEED;

  00167	33 c0		 xor	 eax, eax
  00169	5b		 pop	 ebx

; 425  : }

  0016a	c3		 ret	 0
_Dev_registe ENDP
_TEXT	ENDS
PUBLIC	_Dev_unregiste
; Function compile flags: /Ogtpy
;	COMDAT _Dev_unregiste
_TEXT	SEGMENT
_name$ = 8						; size = 4
_param$ = 12						; size = 4
_Dev_unregiste PROC					; COMDAT

; 446  : {

  00000	57		 push	 edi

; 447  :     device_t      * device      = NULL;
; 448  :     result_t     (* entry)(device_t *,int,void *);
; 449  :     CRITICAL_DECLARE(dev_sdl_lock);
; 450  : 
; 451  :     ASSERT(name);

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR _name$[esp]
  00005	85 ff		 test	 edi, edi
  00007	75 36		 jne	 SHORT $LN18@Dev_unregi
  00009	68 c3 01 00 00	 push	 451			; 000001c3H
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_04MEMAJGDJ@name?$AA@
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001d	e8 00 00 00 00	 call	 __printf
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00027	e8 00 00 00 00	 call	 _Sys_halt

; 452  : 
; 453  : #ifdef _CFG_CHECK_PARAMETER_
; 454  :     if( NULL == name )
; 455  :     {
; 456  :         PROC_SET_ERR(ERR_NAME_INVALID);

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00032	83 c4 14	 add	 esp, 20			; 00000014H
  00035	b8 03 00 00 00	 mov	 eax, 3
  0003a	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0003d	5f		 pop	 edi

; 492  : }

  0003e	c3		 ret	 0
$LN18@Dev_unregi:
  0003f	53		 push	 ebx
  00040	56		 push	 esi

; 457  :         return ERR_NAME_INVALID;
; 458  :     }
; 459  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 460  : 
; 461  :     CRITICAL_BEGIN();

  00041	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00046	8b d8		 mov	 ebx, eax

; 462  :     if( NULL == ( device = Dev_query_by_name(name) ) )

  00048	e8 00 00 00 00	 call	 _Dev_query_by_name
  0004d	8b f0		 mov	 esi, eax
  0004f	85 f6		 test	 esi, esi
  00051	75 1f		 jne	 SHORT $LN15@Dev_unregi

; 463  :     {
; 464  :         PROC_SET_ERR(ERR_DEV_NOT_EXIST);

  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current

; 465  :         CRITICAL_END();

  00059	53		 push	 ebx
  0005a	c7 42 38 01 05
	00 00		 mov	 DWORD PTR [edx+56], 1281 ; 00000501H
  00061	e8 00 00 00 00	 call	 _Cpu_psw_set
  00066	83 c4 04	 add	 esp, 4
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 466  :         return ERR_DEV_NOT_EXIST;

  0006b	b8 01 05 00 00	 mov	 eax, 1281		; 00000501H
  00070	5f		 pop	 edi

; 492  : }

  00071	c3		 ret	 0
$LN15@Dev_unregi:

; 467  :     }
; 468  :     /*
; 469  :      *  设备已经锁定，则不能卸载。
; 470  :      */
; 471  :     if( DEV_IS_LOCKED(device) )

  00072	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00075	85 c0		 test	 eax, eax
  00077	74 1f		 je	 SHORT $LN11@Dev_unregi

; 472  :     {
; 473  :         PROC_SET_ERR(ERR_BUSY);

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current

; 474  :         CRITICAL_END();

  0007f	53		 push	 ebx
  00080	c7 41 38 04 00
	00 00		 mov	 DWORD PTR [ecx+56], 4
  00087	e8 00 00 00 00	 call	 _Cpu_psw_set
  0008c	83 c4 04	 add	 esp, 4
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx

; 475  :         return ERR_BUSY;

  00091	b8 04 00 00 00	 mov	 eax, 4
  00096	5f		 pop	 edi

; 492  : }

  00097	c3		 ret	 0
$LN11@Dev_unregi:

; 476  :     }
; 477  :     entry = device->dev_entry;

  00098	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]

; 478  :     Dev_sdl_del(device);

  0009b	8b c6		 mov	 eax, esi
  0009d	e8 00 00 00 00	 call	 _Dev_sdl_del

; 479  :     CRITICAL_END();

  000a2	53		 push	 ebx
  000a3	e8 00 00 00 00	 call	 _Cpu_psw_set

; 480  :     Dev_put(device);

  000a8	e8 00 00 00 00	 call	 _Dev_put

; 481  :     /*
; 482  :      *  系统已经回收资源，调用驱动入口程序对设备作最后的清理
; 483  :      */
; 484  :     if( entry(device,DEV_ENTRY_FLAG_UNREG,param) != RESULT_SUCCEED )

  000ad	8b 54 24 18	 mov	 edx, DWORD PTR _param$[esp+12]
  000b1	52		 push	 edx
  000b2	6a 01		 push	 1
  000b4	56		 push	 esi
  000b5	ff d7		 call	 edi
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	85 c0		 test	 eax, eax
  000bc	74 12		 je	 SHORT $LN3@Dev_unregi

; 485  :     {
; 486  :         PROC_SET_ERR(ERR_DEV_UNREG_FAILED);

  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000c4	5e		 pop	 esi
  000c5	b8 04 05 00 00	 mov	 eax, 1284		; 00000504H
  000ca	5b		 pop	 ebx
  000cb	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  000ce	5f		 pop	 edi

; 492  : }

  000cf	c3		 ret	 0
$LN3@Dev_unregi:

; 487  :         return ERR_DEV_UNREG_FAILED;
; 488  :     }
; 489  :     PROC_NO_ERR();

  000d0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 490  : 
; 491  :     return RESULT_SUCCEED;

  000df	33 c0		 xor	 eax, eax
  000e1	5f		 pop	 edi

; 492  : }

  000e2	c3		 ret	 0
_Dev_unregiste ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@MFEEEKAL@ivtid?5?$DM?5IVT_MAX?$AA@	; `string'
PUBLIC	_Dev_isr
EXTRN	_Lck_free:PROC
EXTRN	_Machine_ivt_set:PROC
EXTRN	_Lck_lock:PROC
;	COMDAT ??_C@_0BA@MFEEEKAL@ivtid?5?$DM?5IVT_MAX?$AA@
CONST	SEGMENT
??_C@_0BA@MFEEEKAL@ivtid?5?$DM?5IVT_MAX?$AA@ DB 'ivtid < IVT_MAX', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Dev_isr
_TEXT	SEGMENT
_device$ = 8						; size = 4
_ivtid$ = 12						; size = 1
_isr$ = 16						; size = 4
_Dev_isr PROC						; COMDAT

; 514  : {

  00000	53		 push	 ebx
  00001	57		 push	 edi

; 515  :     isr_t           pisr    = NULL;   /*  prev isr    */
; 516  : 
; 517  :     ASSERT( device );

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _device$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	75 26		 jne	 SHORT $LN18@Dev_isr
  0000a	68 05 02 00 00	 push	 517			; 00000205H
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_06CHPEJBOD@device?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001e	e8 00 00 00 00	 call	 __printf
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00028	e8 00 00 00 00	 call	 _Sys_halt
  0002d	83 c4 14	 add	 esp, 20			; 00000014H
$LN18@Dev_isr:

; 518  :     ASSERT( ivtid < IVT_MAX);

  00030	8a 5c 24 10	 mov	 bl, BYTE PTR _ivtid$[esp+4]
  00034	80 fb 10	 cmp	 bl, 16			; 00000010H
  00037	72 26		 jb	 SHORT $LN14@Dev_isr
  00039	68 06 02 00 00	 push	 518			; 00000206H
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MFEEEKAL@ivtid?5?$DM?5IVT_MAX?$AA@
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0004d	e8 00 00 00 00	 call	 __printf
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00057	e8 00 00 00 00	 call	 _Sys_halt
  0005c	83 c4 14	 add	 esp, 20			; 00000014H
$LN14@Dev_isr:

; 519  : 
; 520  : #ifdef _CFG_CHECK_PARAMETER_
; 521  :     if( NULL == device )

  0005f	85 ff		 test	 edi, edi
  00061	75 11		 jne	 SHORT $LN11@Dev_isr

; 522  :     {
; 523  :         PROC_SET_ERR(ERR_DEV_INVALID);

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00068	5f		 pop	 edi
  00069	c7 40 38 08 05
	00 00		 mov	 DWORD PTR [eax+56], 1288 ; 00000508H

; 524  :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	5b		 pop	 ebx

; 540  : }

  00073	c3		 ret	 0
$LN11@Dev_isr:

; 525  :     }
; 526  :     if( ivtid >= IVT_MAX )

  00074	80 fb 10	 cmp	 bl, 16			; 00000010H
  00077	72 12		 jb	 SHORT $LN7@Dev_isr

; 527  :     {
; 528  :         PROC_SET_ERR(ERR_OUT_OF_IVTID);

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0007f	5f		 pop	 edi
  00080	c7 41 38 05 00
	00 00		 mov	 DWORD PTR [ecx+56], 5

; 529  :         return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	5b		 pop	 ebx

; 540  : }

  0008a	c3		 ret	 0
$LN7@Dev_isr:
  0008b	56		 push	 esi

; 530  :     }
; 531  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 532  : 
; 533  :     DEV_LOCK(device);

  0008c	8d 77 24	 lea	 esi, DWORD PTR [edi+36]
  0008f	56		 push	 esi
  00090	e8 00 00 00 00	 call	 _Lck_lock

; 534  :     device->dev_ivtid = ivtid;
; 535  :     pisr = Machine_ivt_set(ivtid,isr);

  00095	8b 54 24 1c	 mov	 edx, DWORD PTR _isr$[esp+12]
  00099	0f b6 c3	 movzx	 eax, bl
  0009c	52		 push	 edx
  0009d	50		 push	 eax
  0009e	88 5f 1c	 mov	 BYTE PTR [edi+28], bl
  000a1	e8 00 00 00 00	 call	 _Machine_ivt_set

; 536  :     DEV_FREE(device);

  000a6	56		 push	 esi
  000a7	8b f8		 mov	 edi, eax
  000a9	e8 00 00 00 00	 call	 _Lck_free

; 537  :     PROC_NO_ERR();

  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000b4	83 c4 10	 add	 esp, 16			; 00000010H
  000b7	5e		 pop	 esi

; 538  : 
; 539  :     return pisr;

  000b8	8b c7		 mov	 eax, edi
  000ba	5f		 pop	 edi
  000bb	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  000c2	5b		 pop	 ebx

; 540  : }

  000c3	c3		 ret	 0
_Dev_isr ENDP
_TEXT	ENDS
PUBLIC	_Dev_open
; Function compile flags: /Ogtpy
;	COMDAT _Dev_open
_TEXT	SEGMENT
_name$ = 8						; size = 4
_mode$ = 12						; size = 4
_Dev_open PROC						; COMDAT

; 561  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 562  :     device_t      * device      = NULL;
; 563  :     CRITICAL_DECLARE(dev_sdl_lock);
; 564  : 
; 565  :     CRITICAL_BEGIN();

  00003	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 566  :     if( NULL == ( device = Dev_query_by_name(name) ) )

  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _name$[esp+8]
  0000c	8b d8		 mov	 ebx, eax
  0000e	e8 00 00 00 00	 call	 _Dev_query_by_name
  00013	8b f0		 mov	 esi, eax
  00015	85 f6		 test	 esi, esi
  00017	75 1b		 jne	 SHORT $LN11@Dev_open

; 567  :     {
; 568  :         PROC_SET_ERR(ERR_DEV_NOT_EXIST);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current

; 569  :         CRITICAL_END();

  0001e	53		 push	 ebx
  0001f	c7 40 38 01 05
	00 00		 mov	 DWORD PTR [eax+56], 1281 ; 00000501H
  00026	e8 00 00 00 00	 call	 _Cpu_psw_set
  0002b	83 c4 04	 add	 esp, 4
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 570  :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	5b		 pop	 ebx

; 591  : }

  00033	c3		 ret	 0
$LN11@Dev_open:

; 571  :     }
; 572  : 
; 573  :     DEV_LOCK(device);

  00034	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  00037	57		 push	 edi
  00038	e8 00 00 00 00	 call	 _Lck_lock

; 574  :     /*
; 575  :      *    必须在锁定设备后，才能退出临界段保护。如果先退出临界段保护，在锁定设
; 576  :      *  备，则有可能出现在锁定前发生任务切换，设备被卸载，导致设备无效。
; 577  :      */
; 578  :     CRITICAL_END();

  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 _Cpu_psw_set

; 579  :     if( RESULT_SUCCEED != device->dev_ddo.ddo_open(device) )

  00043	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00046	56		 push	 esi
  00047	ff d1		 call	 ecx
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	85 c0		 test	 eax, eax

; 580  :     {
; 581  :         DEV_FREE(device);

  0004e	57		 push	 edi
  0004f	74 1b		 je	 SHORT $LN7@Dev_open
  00051	e8 00 00 00 00	 call	 _Lck_free

; 582  :         PROC_SET_ERR(ERR_DEV_OPEN_FAILED);

  00056	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0005c	83 c4 04	 add	 esp, 4
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	c7 42 38 05 05
	00 00		 mov	 DWORD PTR [edx+56], 1285 ; 00000505H

; 583  :         mode = mode;
; 584  :         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	5b		 pop	 ebx

; 591  : }

  0006b	c3		 ret	 0
$LN7@Dev_open:

; 585  :     }
; 586  :     device->dev_ref_cnt++;

  0006c	80 46 1f 01	 add	 BYTE PTR [esi+31], 1

; 587  :     DEV_FREE(device);

  00070	e8 00 00 00 00	 call	 _Lck_free

; 588  :     PROC_NO_ERR();

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0007a	83 c4 04	 add	 esp, 4
  0007d	5f		 pop	 edi
  0007e	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 589  : 
; 590  :     return device;

  00085	8b c6		 mov	 eax, esi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 591  : }

  00089	c3		 ret	 0
_Dev_open ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@CJGKMMND@device?9?$DOdev_ref_cnt?5?$DO?50?$AA@ ; `string'
PUBLIC	_Dev_close
;	COMDAT ??_C@_0BI@CJGKMMND@device?9?$DOdev_ref_cnt?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BI@CJGKMMND@device?9?$DOdev_ref_cnt?5?$DO?50?$AA@ DB 'device->dev_'
	DB	'ref_cnt > 0', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Dev_close
_TEXT	SEGMENT
_device$ = 8						; size = 4
_Dev_close PROC						; COMDAT

; 611  : {

  00000	56		 push	 esi

; 612  :     result_t        result      = RESULT_SUCCEED;
; 613  : 
; 614  :     ASSERT(device);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _device$[esp]
  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
  00008	85 f6		 test	 esi, esi
  0000a	75 26		 jne	 SHORT $LN20@Dev_close
  0000c	68 66 02 00 00	 push	 614			; 00000266H
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_06CHPEJBOD@device?$AA@
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00020	e8 00 00 00 00	 call	 __printf
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0002a	e8 00 00 00 00	 call	 _Sys_halt
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
$LN20@Dev_close:

; 615  :     ASSERT(device->dev_ref_cnt > 0 );

  00032	80 7e 1f 00	 cmp	 BYTE PTR [esi+31], 0
  00036	7f 26		 jg	 SHORT $LN16@Dev_close
  00038	68 67 02 00 00	 push	 615			; 00000267H
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CJGKMMND@device?9?$DOdev_ref_cnt?5?$DO?50?$AA@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0004c	e8 00 00 00 00	 call	 __printf
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00056	e8 00 00 00 00	 call	 _Sys_halt
  0005b	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@Dev_close:

; 616  : 
; 617  : #ifdef _CFG_CHECK_PARAMETER_
; 618  :     if( NULL == device  )
; 619  :     {
; 620  :         PROC_SET_ERR(ERR_DEV_INVALID);
; 621  :         return ERR_DEV_INVALID;
; 622  :     }
; 623  :     if( device->dev_ref_cnt < 1 )

  0005e	80 7e 1f 01	 cmp	 BYTE PTR [esi+31], 1
  00062	7d 11		 jge	 SHORT $LN9@Dev_close

; 624  :     {
; 625  :         PROC_SET_ERR(ERR_REF_CNT_INVALID);

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0006a	b8 0b 05 00 00	 mov	 eax, 1291		; 0000050bH
  0006f	5f		 pop	 edi
  00070	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00073	5e		 pop	 esi

; 640  : }

  00074	c3		 ret	 0
$LN9@Dev_close:
  00075	53		 push	 ebx

; 626  :         return ERR_REF_CNT_INVALID;
; 627  :     }
; 628  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 629  :     
; 630  :     DEV_LOCK(device);

  00076	8d 5e 24	 lea	 ebx, DWORD PTR [esi+36]
  00079	53		 push	 ebx
  0007a	e8 00 00 00 00	 call	 _Lck_lock
  0007f	83 c4 04	 add	 esp, 4

; 631  :     if( --device->dev_ref_cnt == 0 )

  00082	80 46 1f ff	 add	 BYTE PTR [esi+31], -1
  00086	75 12		 jne	 SHORT $LN4@Dev_close

; 632  :     {
; 633  :         if( RESULT_SUCCEED != device->dev_ddo.ddo_close(device) )

  00088	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  0008b	56		 push	 esi
  0008c	ff d2		 call	 edx
  0008e	83 c4 04	 add	 esp, 4
  00091	85 c0		 test	 eax, eax
  00093	74 05		 je	 SHORT $LN4@Dev_close

; 634  :             result = ERR_DEV_CLOSE_FAILED;

  00095	bf 06 05 00 00	 mov	 edi, 1286		; 00000506H
$LN4@Dev_close:

; 635  :     }
; 636  :     DEV_FREE(device);

  0009a	53		 push	 ebx
  0009b	e8 00 00 00 00	 call	 _Lck_free

; 637  :     PROC_SET_ERR(result);

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000a5	83 c4 04	 add	 esp, 4
  000a8	89 78 38	 mov	 DWORD PTR [eax+56], edi
  000ab	5b		 pop	 ebx

; 638  : 
; 639  :     return result;

  000ac	8b c7		 mov	 eax, edi
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi

; 640  : }

  000b0	c3		 ret	 0
_Dev_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_09OJCCCDEJ@size?5?$DO?$DN?50?$AA@		; `string'
PUBLIC	??_C@_06HOHPNJLC@buffer?$AA@			; `string'
PUBLIC	_Dev_read
;	COMDAT ??_C@_09OJCCCDEJ@size?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_09OJCCCDEJ@size?5?$DO?$DN?50?$AA@ DB 'size >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOHPNJLC@buffer?$AA@
CONST	SEGMENT
??_C@_06HOHPNJLC@buffer?$AA@ DB 'buffer', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Dev_read
_TEXT	SEGMENT
_device$ = 8						; size = 4
_offset$ = 12						; size = 8
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_Dev_read PROC						; COMDAT

; 665  : {

  00000	55		 push	 ebp
  00001	57		 push	 edi

; 666  :     int             nr      = -1;    /*  number of read*/
; 667  :     int          (* read)(device_t *,offset_t,void *,int);
; 668  : 
; 669  :     ASSERT(device);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _device$[esp+4]
  00006	83 cd ff	 or	 ebp, -1
  00009	85 ff		 test	 edi, edi
  0000b	75 26		 jne	 SHORT $LN16@Dev_read
  0000d	68 9d 02 00 00	 push	 669			; 0000029dH
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_06CHPEJBOD@device?$AA@
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00021	e8 00 00 00 00	 call	 __printf
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0002b	e8 00 00 00 00	 call	 _Sys_halt
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$LN16@Dev_read:

; 670  :     ASSERT(buffer);

  00033	83 7c 24 18 00	 cmp	 DWORD PTR _buffer$[esp+4], 0
  00038	75 26		 jne	 SHORT $LN12@Dev_read
  0003a	68 9e 02 00 00	 push	 670			; 0000029eH
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_06HOHPNJLC@buffer?$AA@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0004e	e8 00 00 00 00	 call	 __printf
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00058	e8 00 00 00 00	 call	 _Sys_halt
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@Dev_read:

; 671  :     ASSERT(size >= 0 );

  00060	83 7c 24 1c 00	 cmp	 DWORD PTR _size$[esp+4], 0
  00065	7d 26		 jge	 SHORT $LN8@Dev_read
  00067	68 9f 02 00 00	 push	 671			; 0000029fH
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_09OJCCCDEJ@size?5?$DO?$DN?50?$AA@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0007b	e8 00 00 00 00	 call	 __printf
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00085	e8 00 00 00 00	 call	 _Sys_halt
  0008a	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@Dev_read:

; 672  : #ifdef _CFG_CHECK_PARAMETER_
; 673  :     if( NULL == device  )

  0008d	85 ff		 test	 edi, edi
  0008f	75 11		 jne	 SHORT $LN5@Dev_read

; 674  :     {
; 675  :         PROC_SET_ERR(ERR_DEV_INVALID);

  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00097	b8 08 05 00 00	 mov	 eax, 1288		; 00000508H
  0009c	5f		 pop	 edi
  0009d	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  000a0	5d		 pop	 ebp

; 688  : }

  000a1	c3		 ret	 0
$LN5@Dev_read:
  000a2	53		 push	 ebx

; 676  :         return ERR_DEV_INVALID;
; 677  :     }
; 678  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 679  :     read = device->dev_ddo.ddo_read;

  000a3	8b 5f 3c	 mov	 ebx, DWORD PTR [edi+60]

; 680  :     if( read )

  000a6	85 db		 test	 ebx, ebx
  000a8	74 2d		 je	 SHORT $LN1@Dev_read
  000aa	56		 push	 esi

; 681  :     {
; 682  :         DEV_LOCK(device);

  000ab	8d 77 24	 lea	 esi, DWORD PTR [edi+36]
  000ae	56		 push	 esi
  000af	e8 00 00 00 00	 call	 _Lck_lock

; 683  :         nr = read(device,offset,buffer,size);

  000b4	8b 54 24 28	 mov	 edx, DWORD PTR _size$[esp+16]
  000b8	8b 44 24 24	 mov	 eax, DWORD PTR _buffer$[esp+16]
  000bc	8b 4c 24 20	 mov	 ecx, DWORD PTR _offset$[esp+20]
  000c0	52		 push	 edx
  000c1	8b 54 24 20	 mov	 edx, DWORD PTR _offset$[esp+20]
  000c5	50		 push	 eax
  000c6	51		 push	 ecx
  000c7	52		 push	 edx
  000c8	57		 push	 edi
  000c9	ff d3		 call	 ebx

; 684  :         DEV_FREE(device);

  000cb	56		 push	 esi
  000cc	8b e8		 mov	 ebp, eax
  000ce	e8 00 00 00 00	 call	 _Lck_free
  000d3	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d6	5e		 pop	 esi
$LN1@Dev_read:
  000d7	5b		 pop	 ebx
  000d8	5f		 pop	 edi

; 685  :     }
; 686  : 
; 687  :     return nr;

  000d9	8b c5		 mov	 eax, ebp
  000db	5d		 pop	 ebp

; 688  : }

  000dc	c3		 ret	 0
_Dev_read ENDP
_TEXT	ENDS
PUBLIC	_Dev_write
; Function compile flags: /Ogtpy
;	COMDAT _Dev_write
_TEXT	SEGMENT
_device$ = 8						; size = 4
_offset$ = 12						; size = 8
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_Dev_write PROC						; COMDAT

; 714  : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 715  :     int             nw      = -1;   /*  number of write*/
; 716  :     int          (* write)(device_t *,offset_t,const void *,int);
; 717  : 
; 718  :     ASSERT(device);

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _device$[esp+4]
  00006	83 cd ff	 or	 ebp, -1
  00009	85 f6		 test	 esi, esi
  0000b	75 26		 jne	 SHORT $LN12@Dev_write
  0000d	68 ce 02 00 00	 push	 718			; 000002ceH
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_06CHPEJBOD@device?$AA@
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00021	e8 00 00 00 00	 call	 __printf
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0002b	e8 00 00 00 00	 call	 _Sys_halt
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@Dev_write:

; 719  :     ASSERT(buffer);

  00033	83 7c 24 18 00	 cmp	 DWORD PTR _buffer$[esp+4], 0
  00038	75 26		 jne	 SHORT $LN8@Dev_write
  0003a	68 cf 02 00 00	 push	 719			; 000002cfH
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_08IOFIHHIH@device?4c?$AA@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_06HOHPNJLC@buffer?$AA@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0004e	e8 00 00 00 00	 call	 __printf
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00058	e8 00 00 00 00	 call	 _Sys_halt
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
$LN8@Dev_write:

; 720  : #ifdef _CFG_CHECK_PARAMETER_
; 721  :     if( NULL == device  )

  00060	85 f6		 test	 esi, esi
  00062	75 11		 jne	 SHORT $LN5@Dev_write

; 722  :     {
; 723  :         PROC_SET_ERR(ERR_DEV_INVALID);

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0006a	b8 08 05 00 00	 mov	 eax, 1288		; 00000508H
  0006f	5e		 pop	 esi
  00070	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00073	5d		 pop	 ebp

; 736  : }

  00074	c3		 ret	 0
$LN5@Dev_write:
  00075	53		 push	 ebx

; 724  :         return ERR_DEV_INVALID;
; 725  :     }
; 726  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 727  :     write   = device->dev_ddo.ddo_write;

  00076	8b 5e 40	 mov	 ebx, DWORD PTR [esi+64]

; 728  :     if( write )

  00079	85 db		 test	 ebx, ebx
  0007b	74 2d		 je	 SHORT $LN1@Dev_write
  0007d	57		 push	 edi

; 729  :     {
; 730  :         DEV_LOCK(device);

  0007e	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 _Lck_lock

; 731  :         nw = write(device,offset,buffer,size);

  00087	8b 54 24 28	 mov	 edx, DWORD PTR _size$[esp+16]
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR _buffer$[esp+16]
  0008f	8b 4c 24 20	 mov	 ecx, DWORD PTR _offset$[esp+20]
  00093	52		 push	 edx
  00094	8b 54 24 20	 mov	 edx, DWORD PTR _offset$[esp+20]
  00098	50		 push	 eax
  00099	51		 push	 ecx
  0009a	52		 push	 edx
  0009b	56		 push	 esi
  0009c	ff d3		 call	 ebx

; 732  :         DEV_FREE(device);

  0009e	57		 push	 edi
  0009f	8b e8		 mov	 ebp, eax
  000a1	e8 00 00 00 00	 call	 _Lck_free
  000a6	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a9	5f		 pop	 edi
$LN1@Dev_write:
  000aa	5b		 pop	 ebx
  000ab	5e		 pop	 esi

; 733  :     }
; 734  : 
; 735  :     return nw;

  000ac	8b c5		 mov	 eax, ebp
  000ae	5d		 pop	 ebp

; 736  : }

  000af	c3		 ret	 0
_Dev_write ENDP
_TEXT	ENDS
PUBLIC	_Dev_ctrl
; Function compile flags: /Ogtpy
;	COMDAT _Dev_ctrl
_TEXT	SEGMENT
_device$ = 8						; size = 4
_cmd$ = 12						; size = 1
_arg$ = 16						; size = 4
_Dev_ctrl PROC						; COMDAT

; 759  : {

  00000	55		 push	 ebp
  00001	56		 push	 esi

; 760  :     result_t                result      = RESULT_FAILED;
; 761  :     result_t              (*ctrl )(device_t *,byte_t,void *);
; 762  : 
; 763  : #ifdef _CFG_CHECK_PARAMETER_
; 764  :     if( NULL == device  )

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _device$[esp+4]
  00006	83 cd ff	 or	 ebp, -1
  00009	85 f6		 test	 esi, esi
  0000b	75 11		 jne	 SHORT $LN5@Dev_ctrl

; 765  :     {
; 766  :         PROC_SET_ERR(ERR_DEV_INVALID);

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00013	b8 08 05 00 00	 mov	 eax, 1288		; 00000508H
  00018	5e		 pop	 esi
  00019	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0001c	5d		 pop	 ebp

; 780  : }

  0001d	c3		 ret	 0
$LN5@Dev_ctrl:
  0001e	53		 push	 ebx

; 767  :         return ERR_DEV_INVALID;
; 768  :     }
; 769  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 770  : 
; 771  :     ctrl    = device->dev_ddo.ddo_ctrl;

  0001f	8b 5e 44	 mov	 ebx, DWORD PTR [esi+68]

; 772  :     if( ctrl )

  00022	85 db		 test	 ebx, ebx
  00024	74 23		 je	 SHORT $LN1@Dev_ctrl
  00026	57		 push	 edi

; 773  :     {
; 774  :         DEV_LOCK(device);

  00027	8d 7e 24	 lea	 edi, DWORD PTR [esi+36]
  0002a	57		 push	 edi
  0002b	e8 00 00 00 00	 call	 _Lck_lock

; 775  :         result = ctrl(device,cmd,arg);

  00030	8b 54 24 20	 mov	 edx, DWORD PTR _arg$[esp+16]
  00034	8b 44 24 1c	 mov	 eax, DWORD PTR _cmd$[esp+16]
  00038	52		 push	 edx
  00039	50		 push	 eax
  0003a	56		 push	 esi
  0003b	ff d3		 call	 ebx

; 776  :         DEV_FREE(device);

  0003d	57		 push	 edi
  0003e	8b e8		 mov	 ebp, eax
  00040	e8 00 00 00 00	 call	 _Lck_free
  00045	83 c4 14	 add	 esp, 20			; 00000014H
  00048	5f		 pop	 edi
$LN1@Dev_ctrl:
  00049	5b		 pop	 ebx
  0004a	5e		 pop	 esi

; 777  :     }
; 778  : 
; 779  :     return result;

  0004b	8b c5		 mov	 eax, ebp
  0004d	5d		 pop	 ebp

; 780  : }

  0004e	c3		 ret	 0
_Dev_ctrl ENDP
_TEXT	ENDS
PUBLIC	_Dev_sdl_first
; Function compile flags: /Ogtpy
;	COMDAT _Dev_sdl_first
_TEXT	SEGMENT
_Dev_sdl_first PROC					; COMDAT

; 807  :     return dev_sdl;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _dev_sdl

; 808  : }

  00005	c3		 ret	 0
_Dev_sdl_first ENDP
_TEXT	ENDS
PUBLIC	_Dev_sdl_next
; Function compile flags: /Ogtpy
;	COMDAT _Dev_sdl_next
_TEXT	SEGMENT
_device$ = 8						; size = 4
_Dev_sdl_next PROC					; COMDAT

; 828  :     if( NULL == device )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _device$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 01		 jne	 SHORT $LN1@Dev_sdl_ne

; 831  : }

  00008	c3		 ret	 0
$LN1@Dev_sdl_ne:

; 829  :         return NULL;
; 830  :     return device->dev_next;

  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 831  : }

  0000c	c3		 ret	 0
_Dev_sdl_next ENDP
_TEXT	ENDS
END
