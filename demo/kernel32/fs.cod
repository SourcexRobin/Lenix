; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\demo\kernel32\fs.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2044	DB	'fs: %08X mount: %08X', 0aH, 00H
	ORG $+2
$SG2045	DB	'attr: %08X   ', 00H
	ORG $+2
$SG2046	DB	'file size: %ld', 0aH, 00H
$SG2051	DB	'flag=%02X type=%02X start=%8d total=%8d', 0aH, 00H
	ORG $+3
$SG2056	DB	'total file system(partition): %d', 0aH, 00H
	ORG $+2
$SG2057	DB	'active file system: %d', 0aH, 00H
$SG2058	DB	'total file system driver: %d', 0aH, 00H
	ORG $+2
$SG2059	DB	'partition information:', 0aH, 00H
$SG2063	DB	'    type=%02X,start=%-10ld,total=%-10ld ', 0aH, 00H
	ORG $+2
$SG2154	DB	'fs.c', 00H
	ORG $+3
$SG2155	DB	'FS_PART_TYPE_UNDEF != fs_drv_pool[i].fs_type', 00H
	ORG $+3
$SG2156	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2157	DB	'assert failed', 00H
	ORG $+2
$SG2232	DB	'fs.c', 00H
	ORG $+3
$SG2233	DB	'fnode', 00H
	ORG $+2
$SG2234	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2235	DB	'assert failed', 00H
	ORG $+2
$SG2240	DB	'fs.c', 00H
	ORG $+3
$SG2241	DB	'fnode->fn_refcnt > 0', 00H
	ORG $+3
$SG2242	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2243	DB	'assert failed', 00H
	ORG $+2
$SG2273	DB	'fs.c', 00H
	ORG $+3
$SG2274	DB	'file', 00H
	ORG $+3
$SG2275	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2276	DB	'assert failed', 00H
	ORG $+2
$SG2281	DB	'fs.c', 00H
	ORG $+3
$SG2282	DB	'file->f_object', 00H
	ORG $+1
$SG2283	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2284	DB	'assert failed', 00H
	ORG $+2
$SG2299	DB	'fs.c', 00H
	ORG $+3
$SG2300	DB	'file', 00H
	ORG $+3
$SG2301	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2302	DB	'assert failed', 00H
	ORG $+2
$SG2324	DB	'open device flags:%08X', 0aH, 00H
$SG2328	DB	'open device failed!', 0aH, 00H
	ORG $+3
$SG2367	DB	'/../dev/', 00H
	ORG $+3
$SG2392	DB	'fs.c', 00H
	ORG $+3
$SG2393	DB	'fs && fs->fs_drv', 00H
	ORG $+3
$SG2394	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2395	DB	'assert failed', 00H
	ORG $+2
$SG2397	DB	'file not found!', 0aH, 00H
	ORG $+3
$SG2400	DB	'create new file failed!', 0aH, 00H
	ORG $+3
$SG2401	DB	'create new file OK!', 0aH, 00H
	ORG $+3
$SG2408	DB	'KOUM add failed!', 0aH, 00H
	ORG $+2
$SG2427	DB	'read deny', 0aH, 00H
	ORG $+1
$SG2429	DB	'device read', 0aH, 00H
	ORG $+3
$SG2431	DB	'file read', 0aH, 00H
	ORG $+1
$SG2442	DB	'fs.c', 00H
	ORG $+3
$SG2443	DB	'((byte_t *)(f->f_object) - (byte_t *)fs_fnode_pool) % si'
	DB	'zeof(fnode_t) == 0 && (uint_t)(f->f_object) > (uint_t)fs_fnod'
	DB	'e_pool', 00H
$SG2444	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2445	DB	'assert failed', 00H
	ORG $+2
$SG2455	DB	'fs.c', 00H
	ORG $+3
$SG2456	DB	'fs && fs->fs_drv', 00H
	ORG $+3
$SG2457	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2458	DB	'assert failed', 00H
	ORG $+2
$SG2463	DB	'file system initial...', 0aH, 00H
$SG2465	DB	'no active file system!', 0aH, 00H
$SG2467	DB	'file system initial OK!', 0aH, 00H
_DATA	ENDS
PUBLIC	_Fs_register
EXTRN	_Sys_halt:PROC
EXTRN	__printf:PROC
_BSS	SEGMENT
_fs_drv_cnt DD	01H DUP (?)
_fs_drv_pool DB	050H DUP (?)
; Function compile flags: /Odtp
; File e:\sourcexstudio\lenix\lenix\demo\kernel32\fs.c
_BSS	ENDS
_TEXT	SEGMENT
_i$ = -4						; size = 4
_fsreg$ = 8						; size = 4
_Fs_register PROC

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 177  :     int             i;
; 178  : 
; 179  :     for( i = 0 ; i < FS_DRV_MAX ; i++)

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN10@Fs_registe
$LN9@Fs_registe:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Fs_registe:
  00016	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0001a	7d 13		 jge	 SHORT $LN8@Fs_registe

; 180  :         if( FS_PART_TYPE_UNDEF == fs_drv_pool[i].fs_type )

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0001f	6b c9 14	 imul	 ecx, 20			; 00000014H
  00022	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _fs_drv_pool[ecx], 0
  00029	75 02		 jne	 SHORT $LN7@Fs_registe

; 181  :             break;

  0002b	eb 02		 jmp	 SHORT $LN8@Fs_registe
$LN7@Fs_registe:

; 182  :     if( i >= FS_DRV_MAX )

  0002d	eb de		 jmp	 SHORT $LN9@Fs_registe
$LN8@Fs_registe:
  0002f	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00033	7c 05		 jl	 SHORT $LN6@Fs_registe

; 183  :         return RESULT_FAILED;

  00035	83 c8 ff	 or	 eax, -1
  00038	eb 68		 jmp	 SHORT $LN11@Fs_registe
$LN6@Fs_registe:

; 184  :     if( fsreg(fs_drv_pool + i) == RESULT_FAILED )

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003d	6b d2 14	 imul	 edx, 20			; 00000014H
  00040	81 c2 00 00 00
	00		 add	 edx, OFFSET _fs_drv_pool
  00046	52		 push	 edx
  00047	ff 55 08	 call	 DWORD PTR _fsreg$[ebp]
  0004a	83 c4 04	 add	 esp, 4
  0004d	83 f8 ff	 cmp	 eax, -1
  00050	75 05		 jne	 SHORT $LN5@Fs_registe

; 185  :         return RESULT_FAILED;   

  00052	83 c8 ff	 or	 eax, -1
  00055	eb 4b		 jmp	 SHORT $LN11@Fs_registe
$LN5@Fs_registe:

; 186  :     fs_drv_cnt++;

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR _fs_drv_cnt
  0005c	83 c0 01	 add	 eax, 1
  0005f	a3 00 00 00 00	 mov	 DWORD PTR _fs_drv_cnt, eax
$LN4@Fs_registe:

; 187  :     ASSERT(FS_PART_TYPE_UNDEF != fs_drv_pool[i].fs_type);

  00064	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00067	6b c9 14	 imul	 ecx, 20			; 00000014H
  0006a	83 b9 00 00 00
	00 00		 cmp	 DWORD PTR _fs_drv_pool[ecx], 0
  00071	75 29		 jne	 SHORT $LN3@Fs_registe
  00073	68 bb 00 00 00	 push	 187			; 000000bbH
  00078	68 00 00 00 00	 push	 OFFSET $SG2154
  0007d	68 00 00 00 00	 push	 OFFSET $SG2155
  00082	68 00 00 00 00	 push	 OFFSET $SG2156
  00087	e8 00 00 00 00	 call	 __printf
  0008c	83 c4 10	 add	 esp, 16			; 00000010H
  0008f	68 00 00 00 00	 push	 OFFSET $SG2157
  00094	e8 00 00 00 00	 call	 _Sys_halt
  00099	83 c4 04	 add	 esp, 4
$LN3@Fs_registe:
  0009c	33 d2		 xor	 edx, edx
  0009e	75 c4		 jne	 SHORT $LN4@Fs_registe

; 188  :     return RESULT_SUCCEED;

  000a0	33 c0		 xor	 eax, eax
$LN11@Fs_registe:

; 189  : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
_Fs_register ENDP
_TEXT	ENDS
PUBLIC	__namecmpn
EXTRN	__up_case:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_name1$ = 8						; size = 4
_name2$ = 12						; size = 4
_n$ = 16						; size = 4
__namecmpn PROC

; 233  : {

  000b0	55		 push	 ebp
  000b1	8b ec		 mov	 ebp, esp
  000b3	56		 push	 esi
$LN3@namecmpn:

; 234  :     while( n )

  000b4	83 7d 10 00	 cmp	 DWORD PTR _n$[ebp], 0
  000b8	74 53		 je	 SHORT $LN2@namecmpn

; 235  :     {
; 236  :         if( _up_case(*name1) != _up_case(*name2 ) )

  000ba	8b 45 08	 mov	 eax, DWORD PTR _name1$[ebp]
  000bd	8a 08		 mov	 cl, BYTE PTR [eax]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 __up_case
  000c5	83 c4 04	 add	 esp, 4
  000c8	0f be f0	 movsx	 esi, al
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _name2$[ebp]
  000ce	8a 02		 mov	 al, BYTE PTR [edx]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 __up_case
  000d6	83 c4 04	 add	 esp, 4
  000d9	0f be c8	 movsx	 ecx, al
  000dc	3b f1		 cmp	 esi, ecx
  000de	74 10		 je	 SHORT $LN1@namecmpn

; 237  :             return *name1 - *name2;

  000e0	8b 55 08	 mov	 edx, DWORD PTR _name1$[ebp]
  000e3	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000e6	8b 4d 0c	 mov	 ecx, DWORD PTR _name2$[ebp]
  000e9	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000ec	2b c2		 sub	 eax, edx
  000ee	eb 1f		 jmp	 SHORT $LN4@namecmpn
$LN1@namecmpn:

; 238  :         name1++;

  000f0	8b 45 08	 mov	 eax, DWORD PTR _name1$[ebp]
  000f3	83 c0 01	 add	 eax, 1
  000f6	89 45 08	 mov	 DWORD PTR _name1$[ebp], eax

; 239  :         name2++;

  000f9	8b 4d 0c	 mov	 ecx, DWORD PTR _name2$[ebp]
  000fc	83 c1 01	 add	 ecx, 1
  000ff	89 4d 0c	 mov	 DWORD PTR _name2$[ebp], ecx

; 240  :         n--;

  00102	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  00105	83 ea 01	 sub	 edx, 1
  00108	89 55 10	 mov	 DWORD PTR _n$[ebp], edx

; 241  :     }

  0010b	eb a7		 jmp	 SHORT $LN3@namecmpn
$LN2@namecmpn:

; 242  :     return 0;

  0010d	33 c0		 xor	 eax, eax
$LN4@namecmpn:

; 243  : }

  0010f	5e		 pop	 esi
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
__namecmpn ENDP
_TEXT	ENDS
PUBLIC	_Fs_open
EXTRN	_Koum_add:PROC
EXTRN	__printk:PROC
EXTRN	_Lck_free:PROC
EXTRN	_Lck_lock:PROC
_BSS	SEGMENT
_fs_root DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv162 = -300						; size = 4
tv136 = -296						; size = 4
_handle$ = -292						; size = 4
_path$ = -288						; size = 4
_result$ = -284						; size = 4
_fs$ = -280						; size = 4
_file$ = -276						; size = 4
_subpath$ = -272					; size = 256
_fsdrv$ = -16						; size = 4
_device$ = -12						; size = 4
_fnode$ = -8						; size = 4
_parents$ = -4						; size = 4
_pathname$ = 8						; size = 4
_flags$ = 12						; size = 4
_Fs_open PROC

; 404  : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH

; 405  :     char            subpath[256];
; 406  :     const char    * path    = pathname;

  00129	8b 45 08	 mov	 eax, DWORD PTR _pathname$[ebp]
  0012c	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], eax

; 407  :     fs_t          * fs      = NULL;

  00132	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _fs$[ebp], 0

; 408  :     fnode_t       * fnode   = NULL,

  0013c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fnode$[ebp], 0

; 409  :                   * parents = NULL;

  00143	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _parents$[ebp], 0

; 410  :     fsdrv_t       * fsdrv   = NULL;

  0014a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fsdrv$[ebp], 0

; 411  :     device_t      * device  = NULL;

  00151	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _device$[ebp], 0

; 412  :     file_t        * file    = NULL;

  00158	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _file$[ebp], 0

; 413  :     result_t        result  = RESULT_FAILED;

  00162	c7 85 e4 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _result$[ebp], -1

; 414  :     handle_t        handle  = INVALID_HANDLE;

  0016c	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _handle$[ebp], 0
$LN34@Fs_open:

; 415  : 
; 416  :     FS_TRIM_SPACE(path);

  00176	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp]
  0017c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0017f	85 d2		 test	 edx, edx
  00181	74 1f		 je	 SHORT $LN36@Fs_open
  00183	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00189	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0018c	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0018f	75 11		 jne	 SHORT $LN36@Fs_open
  00191	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _path$[ebp]
  00197	83 c2 01	 add	 edx, 1
  0019a	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], edx
  001a0	eb d4		 jmp	 SHORT $LN34@Fs_open
$LN36@Fs_open:
  001a2	33 c0		 xor	 eax, eax
  001a4	75 d0		 jne	 SHORT $LN34@Fs_open

; 417  :     if( *path == '/' )

  001a6	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp]
  001ac	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001af	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  001b2	75 3f		 jne	 SHORT $LN32@Fs_open
$LN28@Fs_open:

; 418  :     {
; 419  :         FS_TRIM_SEPARATOR(path);

  001b4	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  001ba	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001bd	85 c9		 test	 ecx, ecx
  001bf	74 1f		 je	 SHORT $LN30@Fs_open
  001c1	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _path$[ebp]
  001c7	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001ca	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  001cd	75 11		 jne	 SHORT $LN30@Fs_open
  001cf	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp]
  001d5	83 c1 01	 add	 ecx, 1
  001d8	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], ecx
  001de	eb d4		 jmp	 SHORT $LN28@Fs_open
$LN30@Fs_open:
  001e0	33 d2		 xor	 edx, edx
  001e2	75 d0		 jne	 SHORT $LN28@Fs_open

; 420  :         path--; /*  保留最后一个'/'符号 */

  001e4	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  001ea	83 e8 01	 sub	 eax, 1
  001ed	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], eax
$LN32@Fs_open:

; 421  :     }
; 422  :     /*  如果是设备路径前缀，转为打开设备 */
; 423  :     if( _namecmpn(path,"/../dev/",8) == 0 )

  001f3	6a 08		 push	 8
  001f5	68 00 00 00 00	 push	 OFFSET $SG2367
  001fa	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp]
  00200	51		 push	 ecx
  00201	e8 00 00 00 00	 call	 __namecmpn
  00206	83 c4 0c	 add	 esp, 12			; 0000000cH
  00209	85 c0		 test	 eax, eax
  0020b	75 1b		 jne	 SHORT $LN26@Fs_open

; 424  :         return Fs_open_device(path + 8,flags);

  0020d	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00210	52		 push	 edx
  00211	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00217	83 c0 08	 add	 eax, 8
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 _Fs_open_device
  00220	83 c4 08	 add	 esp, 8
  00223	e9 00 04 00 00	 jmp	 $LN38@Fs_open
$LN26@Fs_open:

; 425  :     /*
; 426  :      *  从路径解析出起始目录 
; 427  :      */
; 428  :     if( *path == '/' )

  00228	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _path$[ebp]
  0022e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00231	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00234	75 0a		 jne	 SHORT $LN25@Fs_open

; 429  :         parents = fs_root;

  00236	a1 00 00 00 00	 mov	 eax, DWORD PTR _fs_root
  0023b	89 45 fc	 mov	 DWORD PTR _parents$[ebp], eax

; 430  :     else

  0023e	eb 05		 jmp	 SHORT $LN24@Fs_open
$LN25@Fs_open:

; 431  :     {
; 432  :         /*  处理符号连接 * /
; 433  :         if( path = Fs_is_symbol(path)  )
; 434  :         {
; 435  :             parents = Fs_symbol();
; 436  :         }*/
; 437  :         goto fs_open_file_end; 

  00240	e9 d1 03 00 00	 jmp	 $fs_open_file_end$2370
$LN24@Fs_open:

; 438  :         /* parents = current->proc_current_path;   应获得相对目录 */
; 439  :     }
; 440  : 
; 441  :     //_printk("open file\n");
; 442  :     /*  需要使用一个额外的fnode空间*/
; 443  :     if( NULL == ( fnode = Fs_alloc_fnode() ) )

  00245	e8 00 00 00 00	 call	 _Fs_alloc_fnode
  0024a	89 45 f8	 mov	 DWORD PTR _fnode$[ebp], eax
  0024d	83 7d f8 00	 cmp	 DWORD PTR _fnode$[ebp], 0
  00251	75 05		 jne	 SHORT $LN22@Fs_open

; 444  :         goto fs_open_file_end;

  00253	e9 be 03 00 00	 jmp	 $fs_open_file_end$2370
$LN22@Fs_open:

; 445  :     FNODE_INC_REF_COUNT(parents);

  00258	8b 4d fc	 mov	 ecx, DWORD PTR _parents$[ebp]
  0025b	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0025e	83 c2 01	 add	 edx, 1
  00261	8b 45 fc	 mov	 eax, DWORD PTR _parents$[ebp]
  00264	89 50 38	 mov	 DWORD PTR [eax+56], edx
  00267	33 c9		 xor	 ecx, ecx
  00269	75 ed		 jne	 SHORT $LN22@Fs_open
$LN19@Fs_open:

; 446  :     /*  区分路径中和路径末尾，路径中需要找到目录，路径末尾需要找到文件 */
; 447  :     while( path = Fs_get_subpath(path,subpath) )

  0026b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _subpath$[ebp]
  00271	52		 push	 edx
  00272	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00278	50		 push	 eax
  00279	e8 00 00 00 00	 call	 _Fs_get_subpath
  0027e	83 c4 08	 add	 esp, 8
  00281	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], eax
  00287	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR _path$[ebp], 0
  0028e	0f 84 d6 00 00
	00		 je	 $LN18@Fs_open

; 448  :     {
; 449  :         fs = FNODE_GET_FS(parents);

  00294	8b 4d fc	 mov	 ecx, DWORD PTR _parents$[ebp]
  00297	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0029b	74 0e		 je	 SHORT $LN40@Fs_open
  0029d	8b 55 fc	 mov	 edx, DWORD PTR _parents$[ebp]
  002a0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002a3	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv136[ebp], eax
  002a9	eb 0c		 jmp	 SHORT $LN41@Fs_open
$LN40@Fs_open:
  002ab	8b 4d fc	 mov	 ecx, DWORD PTR _parents$[ebp]
  002ae	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002b1	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv136[ebp], edx
$LN41@Fs_open:
  002b7	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  002bd	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _fs$[ebp], eax

; 450  :         /*  需要使用一个额外的fnode空间*/
; 451  :         if( NULL == ( fnode = Fs_alloc_fnode() ) )

  002c3	e8 00 00 00 00	 call	 _Fs_alloc_fnode
  002c8	89 45 f8	 mov	 DWORD PTR _fnode$[ebp], eax
  002cb	83 7d f8 00	 cmp	 DWORD PTR _fnode$[ebp], 0
  002cf	75 05		 jne	 SHORT $LN17@Fs_open

; 452  :             goto fs_open_file_end;

  002d1	e9 40 03 00 00	 jmp	 $fs_open_file_end$2370
$LN17@Fs_open:

; 453  :         /*  锁文件系统 */
; 454  :         FS_LOCK(fs);

  002d6	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _fs$[ebp]
  002dc	81 c1 68 02 00
	00		 add	 ecx, 616		; 00000268H
  002e2	51		 push	 ecx
  002e3	e8 00 00 00 00	 call	 _Lck_lock
  002e8	83 c4 04	 add	 esp, 4

; 455  :         result = fs->fs_drv->fs_fnode_find(parents,subpath,flags,fnode);

  002eb	8b 55 f8	 mov	 edx, DWORD PTR _fnode$[ebp]
  002ee	52		 push	 edx
  002ef	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  002f2	50		 push	 eax
  002f3	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _subpath$[ebp]
  002f9	51		 push	 ecx
  002fa	8b 55 fc	 mov	 edx, DWORD PTR _parents$[ebp]
  002fd	52		 push	 edx
  002fe	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _fs$[ebp]
  00304	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00307	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0030a	ff d2		 call	 edx
  0030c	83 c4 10	 add	 esp, 16			; 00000010H
  0030f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _result$[ebp], eax

; 456  :         FS_FREE(fs);

  00315	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _fs$[ebp]
  0031b	05 68 02 00 00	 add	 eax, 616		; 00000268H
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 _Lck_free
  00326	83 c4 04	 add	 esp, 4

; 457  :         if( result != RESULT_SUCCEED )

  00329	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _result$[ebp], 0
  00330	74 05		 je	 SHORT $LN16@Fs_open

; 458  :             goto fs_open_file_end;

  00332	e9 df 02 00 00	 jmp	 $fs_open_file_end$2370
$LN16@Fs_open:

; 459  :         /*  找到的名字不是目录  */
; 460  :         if( !FNODE_IS_DIRECTORY(fnode) )

  00337	8b 4d f8	 mov	 ecx, DWORD PTR _fnode$[ebp]
  0033a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0033d	83 e2 01	 and	 edx, 1
  00340	75 11		 jne	 SHORT $LN15@Fs_open

; 461  :         {
; 462  :             Fs_free_fnode(fnode);

  00342	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  00345	50		 push	 eax
  00346	e8 00 00 00 00	 call	 _Fs_free_fnode
  0034b	83 c4 04	 add	 esp, 4

; 463  :             goto fs_open_file_end;

  0034e	e9 c3 02 00 00	 jmp	 $fs_open_file_end$2370
$LN15@Fs_open:

; 464  :         }
; 465  :         Fs_free_fnode(parents);

  00353	8b 4d fc	 mov	 ecx, DWORD PTR _parents$[ebp]
  00356	51		 push	 ecx
  00357	e8 00 00 00 00	 call	 _Fs_free_fnode
  0035c	83 c4 04	 add	 esp, 4

; 466  :         parents = fnode;

  0035f	8b 55 f8	 mov	 edx, DWORD PTR _fnode$[ebp]
  00362	89 55 fc	 mov	 DWORD PTR _parents$[ebp], edx

; 467  :         //_printk("subpath: %s-\n",subpath);
; 468  :     }

  00365	e9 01 ff ff ff	 jmp	 $LN19@Fs_open
$LN18@Fs_open:

; 469  : 
; 470  :     //_printk("filename: %s-\n",subpath);
; 471  :     if( NULL ==( fnode = Fs_alloc_fnode() ) )

  0036a	e8 00 00 00 00	 call	 _Fs_alloc_fnode
  0036f	89 45 f8	 mov	 DWORD PTR _fnode$[ebp], eax
  00372	83 7d f8 00	 cmp	 DWORD PTR _fnode$[ebp], 0
  00376	75 05		 jne	 SHORT $LN14@Fs_open

; 472  :         goto fs_open_file_end;

  00378	e9 99 02 00 00	 jmp	 $fs_open_file_end$2370
$LN14@Fs_open:

; 473  :     fs = FNODE_GET_FS(parents);

  0037d	8b 45 fc	 mov	 eax, DWORD PTR _parents$[ebp]
  00380	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00384	74 0e		 je	 SHORT $LN42@Fs_open
  00386	8b 4d fc	 mov	 ecx, DWORD PTR _parents$[ebp]
  00389	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0038c	89 95 d4 fe ff
	ff		 mov	 DWORD PTR tv162[ebp], edx
  00392	eb 0c		 jmp	 SHORT $LN43@Fs_open
$LN42@Fs_open:
  00394	8b 45 fc	 mov	 eax, DWORD PTR _parents$[ebp]
  00397	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0039a	89 8d d4 fe ff
	ff		 mov	 DWORD PTR tv162[ebp], ecx
$LN43@Fs_open:
  003a0	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR tv162[ebp]
  003a6	89 95 e8 fe ff
	ff		 mov	 DWORD PTR _fs$[ebp], edx
$LN13@Fs_open:

; 474  :     ASSERT(fs && fs->fs_drv);

  003ac	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR _fs$[ebp], 0
  003b3	74 0c		 je	 SHORT $LN9@Fs_open
  003b5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _fs$[ebp]
  003bb	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  003bf	75 29		 jne	 SHORT $LN12@Fs_open
$LN9@Fs_open:
  003c1	68 da 01 00 00	 push	 474			; 000001daH
  003c6	68 00 00 00 00	 push	 OFFSET $SG2392
  003cb	68 00 00 00 00	 push	 OFFSET $SG2393
  003d0	68 00 00 00 00	 push	 OFFSET $SG2394
  003d5	e8 00 00 00 00	 call	 __printf
  003da	83 c4 10	 add	 esp, 16			; 00000010H
  003dd	68 00 00 00 00	 push	 OFFSET $SG2395
  003e2	e8 00 00 00 00	 call	 _Sys_halt
  003e7	83 c4 04	 add	 esp, 4
$LN12@Fs_open:
  003ea	33 c9		 xor	 ecx, ecx
  003ec	75 be		 jne	 SHORT $LN13@Fs_open

; 475  :     FS_LOCK(fs);

  003ee	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _fs$[ebp]
  003f4	81 c2 68 02 00
	00		 add	 edx, 616		; 00000268H
  003fa	52		 push	 edx
  003fb	e8 00 00 00 00	 call	 _Lck_lock
  00400	83 c4 04	 add	 esp, 4

; 476  :     result = fs->fs_drv->fs_fnode_find(parents,subpath,flags,fnode);

  00403	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  00406	50		 push	 eax
  00407	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  0040a	51		 push	 ecx
  0040b	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _subpath$[ebp]
  00411	52		 push	 edx
  00412	8b 45 fc	 mov	 eax, DWORD PTR _parents$[ebp]
  00415	50		 push	 eax
  00416	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _fs$[ebp]
  0041c	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  0041f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00422	ff d0		 call	 eax
  00424	83 c4 10	 add	 esp, 16			; 00000010H
  00427	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _result$[ebp], eax

; 477  :     FS_FREE(fs);

  0042d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _fs$[ebp]
  00433	81 c1 68 02 00
	00		 add	 ecx, 616		; 00000268H
  00439	51		 push	 ecx
  0043a	e8 00 00 00 00	 call	 _Lck_free
  0043f	83 c4 04	 add	 esp, 4

; 478  :     if( result !=RESULT_SUCCEED)

  00442	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _result$[ebp], 0
  00449	0f 84 ad 00 00
	00		 je	 $LN8@Fs_open

; 479  :     {
; 480  :         _printk("file not found!\n");

  0044f	68 00 00 00 00	 push	 OFFSET $SG2397
  00454	e8 00 00 00 00	 call	 __printk
  00459	83 c4 04	 add	 esp, 4

; 481  :         /*
; 482  :          *  要求只打开已存在的文件的情况下，找不到文件则返回
; 483  :          */
; 484  :         if( flags & FS_OPEN_FLAG_EXIST )

  0045c	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  0045f	83 e2 01	 and	 edx, 1
  00462	74 11		 je	 SHORT $LN7@Fs_open

; 485  :         {
; 486  :             Fs_free_fnode(fnode);

  00464	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 _Fs_free_fnode
  0046d	83 c4 04	 add	 esp, 4

; 487  :             goto fs_open_file_end;

  00470	e9 a1 01 00 00	 jmp	 $fs_open_file_end$2370
$LN7@Fs_open:

; 488  :         }
; 489  :         FS_LOCK(fs);

  00475	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _fs$[ebp]
  0047b	81 c1 68 02 00
	00		 add	 ecx, 616		; 00000268H
  00481	51		 push	 ecx
  00482	e8 00 00 00 00	 call	 _Lck_lock
  00487	83 c4 04	 add	 esp, 4

; 490  :         result = fs->fs_drv->fs_fnode_create(parents,subpath,flags,fnode);

  0048a	8b 55 f8	 mov	 edx, DWORD PTR _fnode$[ebp]
  0048d	52		 push	 edx
  0048e	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00491	50		 push	 eax
  00492	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _subpath$[ebp]
  00498	51		 push	 ecx
  00499	8b 55 fc	 mov	 edx, DWORD PTR _parents$[ebp]
  0049c	52		 push	 edx
  0049d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _fs$[ebp]
  004a3	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  004a6	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  004a9	ff d2		 call	 edx
  004ab	83 c4 10	 add	 esp, 16			; 00000010H
  004ae	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _result$[ebp], eax

; 491  :         FS_FREE(fs);

  004b4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _fs$[ebp]
  004ba	05 68 02 00 00	 add	 eax, 616		; 00000268H
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 _Lck_free
  004c5	83 c4 04	 add	 esp, 4

; 492  :         if( result != RESULT_SUCCEED)

  004c8	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR _result$[ebp], 0
  004cf	74 1e		 je	 SHORT $LN6@Fs_open

; 493  :         {
; 494  :             _printk("create new file failed!\n");

  004d1	68 00 00 00 00	 push	 OFFSET $SG2400
  004d6	e8 00 00 00 00	 call	 __printk
  004db	83 c4 04	 add	 esp, 4

; 495  :             Fs_free_fnode(fnode);

  004de	8b 4d f8	 mov	 ecx, DWORD PTR _fnode$[ebp]
  004e1	51		 push	 ecx
  004e2	e8 00 00 00 00	 call	 _Fs_free_fnode
  004e7	83 c4 04	 add	 esp, 4

; 496  :             goto fs_open_file_end;

  004ea	e9 27 01 00 00	 jmp	 $fs_open_file_end$2370
$LN6@Fs_open:

; 497  :         }
; 498  :         _printk("create new file OK!\n");

  004ef	68 00 00 00 00	 push	 OFFSET $SG2401
  004f4	e8 00 00 00 00	 call	 __printk
  004f9	83 c4 04	 add	 esp, 4
$LN8@Fs_open:

; 499  :     }
; 500  :     /*
; 501  :      *  要求打开目录，但找到的不是目录，返回失败
; 502  :      *  没有要求打开目录，但找到的是目录，返回失败
; 503  :      */
; 504  :     if((flags&FS_OPEN_FLAG_DIRECTORY&&!(fnode->fn_attr&FNODE_ATTR_DIRECTORY))||
; 505  :         (!(flags&FS_OPEN_FLAG_DIRECTORY)&&fnode->fn_attr&FNODE_ATTR_DIRECTORY))

  004fc	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  004ff	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00505	74 0b		 je	 SHORT $LN3@Fs_open
  00507	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  0050a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0050d	83 e1 01	 and	 ecx, 1
  00510	74 16		 je	 SHORT $LN4@Fs_open
$LN3@Fs_open:
  00512	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  00515	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  0051b	75 1c		 jne	 SHORT $LN5@Fs_open
  0051d	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  00520	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00523	83 e1 01	 and	 ecx, 1
  00526	74 11		 je	 SHORT $LN5@Fs_open
$LN4@Fs_open:

; 506  :     {
; 507  :         Fs_free_fnode(fnode);

  00528	8b 55 f8	 mov	 edx, DWORD PTR _fnode$[ebp]
  0052b	52		 push	 edx
  0052c	e8 00 00 00 00	 call	 _Fs_free_fnode
  00531	83 c4 04	 add	 esp, 4

; 508  :         goto fs_open_file_end;

  00534	e9 dd 00 00 00	 jmp	 $fs_open_file_end$2370
$LN5@Fs_open:

; 509  :     }
; 510  : 
; 511  :     /*
; 512  :      *  分配文件对象，分配不成功则返回失败。
; 513  :      */
; 514  :     if( NULL == ( file = Fs_alloc_file() ) )

  00539	e8 00 00 00 00	 call	 _Fs_alloc_file
  0053e	89 85 ec fe ff
	ff		 mov	 DWORD PTR _file$[ebp], eax
  00544	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR _file$[ebp], 0
  0054b	75 11		 jne	 SHORT $LN2@Fs_open

; 515  :     {
; 516  :         Fs_free_fnode(fnode);

  0054d	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  00550	50		 push	 eax
  00551	e8 00 00 00 00	 call	 _Fs_free_fnode
  00556	83 c4 04	 add	 esp, 4

; 517  :         goto fs_open_file_end;

  00559	e9 b8 00 00 00	 jmp	 $fs_open_file_end$2370
$LN2@Fs_open:

; 518  :     }
; 519  :     /*  注意文件节点对象的属性与文件句柄的属性是两回事*/
; 520  :     file->f_object  = fnode;

  0055e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _file$[ebp]
  00564	8b 55 f8	 mov	 edx, DWORD PTR _fnode$[ebp]
  00567	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 521  :     file->f_ptr     = 0;

  0056a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  00570	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  00577	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 522  :     file->f_attr    = FILE_ATTR_RDWR;

  0057e	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _file$[ebp]
  00584	c7 41 04 06 00
	00 00		 mov	 DWORD PTR [ecx+4], 6

; 523  :     file->f_attr   &= (~FS_OPEN_FLAG_RDWR_MASK) | \
; 524  :                       (flags & FS_OPEN_FLAG_RDWR_MASK);

  0058b	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  0058e	83 e2 06	 and	 edx, 6
  00591	83 ca f9	 or	 edx, -7			; fffffff9H
  00594	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  0059a	23 50 04	 and	 edx, DWORD PTR [eax+4]
  0059d	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _file$[ebp]
  005a3	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 525  :     fnode->fn_attr &= (~FS_OPEN_FLAG_RDWR_MASK) | \
; 526  :                       (flags & FS_OPEN_FLAG_RDWR_MASK);

  005a6	8b 55 0c	 mov	 edx, DWORD PTR _flags$[ebp]
  005a9	83 e2 06	 and	 edx, 6
  005ac	83 ca f9	 or	 edx, -7			; fffffff9H
  005af	8b 45 f8	 mov	 eax, DWORD PTR _fnode$[ebp]
  005b2	23 50 20	 and	 edx, DWORD PTR [eax+32]
  005b5	8b 4d f8	 mov	 ecx, DWORD PTR _fnode$[ebp]
  005b8	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 527  :     Fs_fnode_information(fnode);

  005bb	8b 55 f8	 mov	 edx, DWORD PTR _fnode$[ebp]
  005be	52		 push	 edx
  005bf	e8 00 00 00 00	 call	 _Fs_fnode_information
  005c4	83 c4 04	 add	 esp, 4

; 528  :     /*
; 529  :      *  加入内核统一对象管理 
; 530  :      */
; 531  :     if( INVALID_HANDLE == (handle = Koum_add(file,Fs_release_file,kot_file,0)))

  005c7	6a 00		 push	 0
  005c9	6a 05		 push	 5
  005cb	68 00 00 00 00	 push	 OFFSET _Fs_release_file
  005d0	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _file$[ebp]
  005d6	50		 push	 eax
  005d7	e8 00 00 00 00	 call	 _Koum_add
  005dc	83 c4 10	 add	 esp, 16			; 00000010H
  005df	89 85 dc fe ff
	ff		 mov	 DWORD PTR _handle$[ebp], eax
  005e5	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _handle$[ebp], 0
  005ec	75 28		 jne	 SHORT $fs_open_file_end$2370

; 532  :     {
; 533  :         Fs_free_fnode(fnode);

  005ee	8b 4d f8	 mov	 ecx, DWORD PTR _fnode$[ebp]
  005f1	51		 push	 ecx
  005f2	e8 00 00 00 00	 call	 _Fs_free_fnode
  005f7	83 c4 04	 add	 esp, 4

; 534  :         Fs_free_file(file);

  005fa	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _file$[ebp]
  00600	52		 push	 edx
  00601	e8 00 00 00 00	 call	 _Fs_free_file
  00606	83 c4 04	 add	 esp, 4

; 535  :         _printk("KOUM add failed!\n");

  00609	68 00 00 00 00	 push	 OFFSET $SG2408
  0060e	e8 00 00 00 00	 call	 __printk
  00613	83 c4 04	 add	 esp, 4
$fs_open_file_end$2370:

; 536  :         goto fs_open_file_end;
; 537  :     }
; 538  :     //_printk("file open OK!\n");
; 539  : fs_open_file_end:
; 540  :     Fs_free_fnode(parents);

  00616	8b 45 fc	 mov	 eax, DWORD PTR _parents$[ebp]
  00619	50		 push	 eax
  0061a	e8 00 00 00 00	 call	 _Fs_free_fnode
  0061f	83 c4 04	 add	 esp, 4

; 541  :     return handle;

  00622	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _handle$[ebp]
$LN38@Fs_open:

; 542  : }

  00628	8b e5		 mov	 esp, ebp
  0062a	5d		 pop	 ebp
  0062b	c3		 ret	 0
_Fs_open ENDP
; Function compile flags: /Odtp
_fnode$ = 8						; size = 4
_Fs_fnode_information PROC

; 45   : {

  00630	55		 push	 ebp
  00631	8b ec		 mov	 ebp, esp

; 46   :     _printk("fs: %08X mount: %08X\n",fnode->fn_fs,fnode->fn_mount);

  00633	8b 45 08	 mov	 eax, DWORD PTR _fnode$[ebp]
  00636	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00639	51		 push	 ecx
  0063a	8b 55 08	 mov	 edx, DWORD PTR _fnode$[ebp]
  0063d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00640	50		 push	 eax
  00641	68 00 00 00 00	 push	 OFFSET $SG2044
  00646	e8 00 00 00 00	 call	 __printk
  0064b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 47   :     _printk("attr: %08X   ",fnode->fn_attr);

  0064e	8b 4d 08	 mov	 ecx, DWORD PTR _fnode$[ebp]
  00651	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00654	52		 push	 edx
  00655	68 00 00 00 00	 push	 OFFSET $SG2045
  0065a	e8 00 00 00 00	 call	 __printk
  0065f	83 c4 08	 add	 esp, 8

; 48   :     _printk("file size: %ld\n",fnode->fn_size);

  00662	8b 45 08	 mov	 eax, DWORD PTR _fnode$[ebp]
  00665	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00668	51		 push	 ecx
  00669	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0066c	52		 push	 edx
  0066d	68 00 00 00 00	 push	 OFFSET $SG2046
  00672	e8 00 00 00 00	 call	 __printk
  00677	83 c4 0c	 add	 esp, 12			; 0000000cH

; 49   : }

  0067a	5d		 pop	 ebp
  0067b	c3		 ret	 0
_Fs_fnode_information ENDP
; Function compile flags: /Odtp
_lastspace$ = -12					; size = 4
_sp$ = -8						; size = 4
_p$ = -4						; size = 4
_path$ = 8						; size = 4
_subpath$ = 12						; size = 4
_Fs_get_subpath PROC

; 201  : {

  00680	55		 push	 ebp
  00681	8b ec		 mov	 ebp, esp
  00683	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 202  :     const char * p          = path;

  00686	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00689	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 203  :     char       * sp         = subpath;

  0068c	8b 4d 0c	 mov	 ecx, DWORD PTR _subpath$[ebp]
  0068f	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx

; 204  :     char       * lastspace  = NULL;

  00692	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lastspace$[ebp], 0
$LN13@Fs_get_sub:

; 205  :     
; 206  :     FS_TRIM_SEPARATOR(p);

  00699	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0069c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0069f	85 c0		 test	 eax, eax
  006a1	74 16		 je	 SHORT $LN15@Fs_get_sub
  006a3	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  006a6	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  006a9	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  006ac	75 0b		 jne	 SHORT $LN15@Fs_get_sub
  006ae	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  006b1	83 c0 01	 add	 eax, 1
  006b4	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  006b7	eb e0		 jmp	 SHORT $LN13@Fs_get_sub
$LN15@Fs_get_sub:
  006b9	33 c9		 xor	 ecx, ecx
  006bb	75 dc		 jne	 SHORT $LN13@Fs_get_sub
$LN8@Fs_get_sub:

; 207  :     FS_TRIM_SPACE(p);

  006bd	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  006c0	0f be 02	 movsx	 eax, BYTE PTR [edx]
  006c3	85 c0		 test	 eax, eax
  006c5	74 16		 je	 SHORT $LN10@Fs_get_sub
  006c7	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  006ca	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  006cd	83 fa 20	 cmp	 edx, 32			; 00000020H
  006d0	75 0b		 jne	 SHORT $LN10@Fs_get_sub
  006d2	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  006d5	83 c0 01	 add	 eax, 1
  006d8	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  006db	eb e0		 jmp	 SHORT $LN8@Fs_get_sub
$LN10@Fs_get_sub:
  006dd	33 c9		 xor	 ecx, ecx
  006df	75 dc		 jne	 SHORT $LN8@Fs_get_sub
$LN6@Fs_get_sub:

; 208  :     while( *p && *p != '/' )

  006e1	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  006e4	0f be 02	 movsx	 eax, BYTE PTR [edx]
  006e7	85 c0		 test	 eax, eax
  006e9	74 49		 je	 SHORT $LN5@Fs_get_sub
  006eb	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  006ee	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  006f1	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  006f4	74 3e		 je	 SHORT $LN5@Fs_get_sub

; 209  :     {
; 210  :         if( *p == ' ' )

  006f6	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  006f9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  006fc	83 f9 20	 cmp	 ecx, 32			; 00000020H
  006ff	75 0e		 jne	 SHORT $LN4@Fs_get_sub

; 211  :         {
; 212  :             if( lastspace == NULL )

  00701	83 7d f4 00	 cmp	 DWORD PTR _lastspace$[ebp], 0
  00705	75 06		 jne	 SHORT $LN3@Fs_get_sub

; 213  :                 lastspace = sp;

  00707	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  0070a	89 55 f4	 mov	 DWORD PTR _lastspace$[ebp], edx
$LN3@Fs_get_sub:

; 214  :         }
; 215  :         else

  0070d	eb 07		 jmp	 SHORT $LN2@Fs_get_sub
$LN4@Fs_get_sub:

; 216  :             lastspace = NULL;

  0070f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lastspace$[ebp], 0
$LN2@Fs_get_sub:

; 217  :         *sp++ = *p++;

  00716	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00719	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0071c	8a 11		 mov	 dl, BYTE PTR [ecx]
  0071e	88 10		 mov	 BYTE PTR [eax], dl
  00720	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00723	83 c0 01	 add	 eax, 1
  00726	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax
  00729	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0072c	83 c1 01	 add	 ecx, 1
  0072f	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx

; 218  :     }

  00732	eb ad		 jmp	 SHORT $LN6@Fs_get_sub
$LN5@Fs_get_sub:

; 219  :     *sp = 0;

  00734	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  00737	c6 02 00	 mov	 BYTE PTR [edx], 0

; 220  :     if( lastspace )

  0073a	83 7d f4 00	 cmp	 DWORD PTR _lastspace$[ebp], 0
  0073e	74 06		 je	 SHORT $LN1@Fs_get_sub

; 221  :         *lastspace = 0;

  00740	8b 45 f4	 mov	 eax, DWORD PTR _lastspace$[ebp]
  00743	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN1@Fs_get_sub:

; 222  :     
; 223  :     return 0 == *p ? NULL : p;

  00746	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00749	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  0074c	f7 d8		 neg	 eax
  0074e	1b c0		 sbb	 eax, eax
  00750	23 45 fc	 and	 eax, DWORD PTR _p$[ebp]

; 224  : }

  00753	8b e5		 mov	 esp, ebp
  00755	5d		 pop	 ebp
  00756	c3		 ret	 0
_Fs_get_subpath ENDP
_TEXT	ENDS
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Cpu_disable_interrupt:PROC
_BSS	SEGMENT
_fs_fnode_pool DB 01200H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
___psw$ = -12						; size = 4
_i$ = -8						; size = 4
_fnode$ = -4						; size = 4
_Fs_alloc_fnode PROC

; 247  : {

  00760	55		 push	 ebp
  00761	8b ec		 mov	 ebp, esp
  00763	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 248  :     int             i       = 0;

  00766	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 249  :     fnode_t       * fnode   = fs_fnode_pool;

  0076d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fnode$[ebp], OFFSET _fs_fnode_pool
$LN7@Fs_alloc_f:

; 250  :     CRITICAL_DECLARE(fs_fnode_lock);
; 251  : 
; 252  :     CRITICAL_BEGIN();

  00774	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00779	89 45 f4	 mov	 DWORD PTR ___psw$[ebp], eax
  0077c	33 c0		 xor	 eax, eax
  0077e	75 f4		 jne	 SHORT $LN7@Fs_alloc_f

; 253  :     for( i = 0 ; i < FS_FNDOE_MAX ; i++,fnode++)

  00780	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00787	eb 12		 jmp	 SHORT $LN4@Fs_alloc_f
$LN3@Fs_alloc_f:
  00789	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0078c	83 c1 01	 add	 ecx, 1
  0078f	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
  00792	8b 55 fc	 mov	 edx, DWORD PTR _fnode$[ebp]
  00795	83 c2 48	 add	 edx, 72			; 00000048H
  00798	89 55 fc	 mov	 DWORD PTR _fnode$[ebp], edx
$LN4@Fs_alloc_f:
  0079b	83 7d f8 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  0079f	7d 3e		 jge	 SHORT $LN2@Fs_alloc_f

; 254  :     {
; 255  :         if( NULL == fnode->fn_fs && NULL == fnode->fn_mount )

  007a1	8b 45 fc	 mov	 eax, DWORD PTR _fnode$[ebp]
  007a4	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  007a8	75 33		 jne	 SHORT $LN1@Fs_alloc_f
  007aa	8b 4d fc	 mov	 ecx, DWORD PTR _fnode$[ebp]
  007ad	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  007b1	75 2a		 jne	 SHORT $LN1@Fs_alloc_f

; 256  :         {
; 257  :             fnode->fn_fs        = (fs_t *)-1;

  007b3	8b 55 fc	 mov	 edx, DWORD PTR _fnode$[ebp]
  007b6	c7 42 08 ff ff
	ff ff		 mov	 DWORD PTR [edx+8], -1

; 258  :             fnode->fn_mount     = NULL;

  007bd	8b 45 fc	 mov	 eax, DWORD PTR _fnode$[ebp]
  007c0	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 259  :             fnode->fn_refcnt    = 1; /*  分配后，立即引用*/

  007c7	8b 4d fc	 mov	 ecx, DWORD PTR _fnode$[ebp]
  007ca	c7 41 38 01 00
	00 00		 mov	 DWORD PTR [ecx+56], 1

; 260  :             fnode->fn_attr      = 0;

  007d1	8b 55 fc	 mov	 edx, DWORD PTR _fnode$[ebp]
  007d4	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 261  :             break;

  007db	eb 02		 jmp	 SHORT $LN2@Fs_alloc_f
$LN1@Fs_alloc_f:

; 262  :         }
; 263  :     }

  007dd	eb aa		 jmp	 SHORT $LN3@Fs_alloc_f
$LN2@Fs_alloc_f:

; 264  :     CRITICAL_END();

  007df	8b 45 f4	 mov	 eax, DWORD PTR ___psw$[ebp]
  007e2	50		 push	 eax
  007e3	e8 00 00 00 00	 call	 _Cpu_psw_set
  007e8	83 c4 04	 add	 esp, 4

; 265  : 
; 266  :     return i < FS_FNDOE_MAX ? fnode : NULL;

  007eb	33 c0		 xor	 eax, eax
  007ed	83 7d f8 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  007f1	0f 9d c0	 setge	 al
  007f4	83 e8 01	 sub	 eax, 1
  007f7	23 45 fc	 and	 eax, DWORD PTR _fnode$[ebp]

; 267  : }

  007fa	8b e5		 mov	 esp, ebp
  007fc	5d		 pop	 ebp
  007fd	c3		 ret	 0
_Fs_alloc_fnode ENDP
_TEXT	ENDS
EXTRN	__memzero:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
___psw$ = -4						; size = 4
_fnode$ = 8						; size = 4
_Fs_free_fnode PROC

; 271  : {

  00800	55		 push	 ebp
  00801	8b ec		 mov	 ebp, esp
  00803	51		 push	 ecx
$LN12@Fs_free_fn:

; 272  :     CRITICAL_DECLARE(fs_fnode_lock);
; 273  : 
; 274  :     ASSERT( fnode );

  00804	83 7d 08 00	 cmp	 DWORD PTR _fnode$[ebp], 0
  00808	75 29		 jne	 SHORT $LN11@Fs_free_fn
  0080a	68 12 01 00 00	 push	 274			; 00000112H
  0080f	68 00 00 00 00	 push	 OFFSET $SG2232
  00814	68 00 00 00 00	 push	 OFFSET $SG2233
  00819	68 00 00 00 00	 push	 OFFSET $SG2234
  0081e	e8 00 00 00 00	 call	 __printf
  00823	83 c4 10	 add	 esp, 16			; 00000010H
  00826	68 00 00 00 00	 push	 OFFSET $SG2235
  0082b	e8 00 00 00 00	 call	 _Sys_halt
  00830	83 c4 04	 add	 esp, 4
$LN11@Fs_free_fn:
  00833	33 c0		 xor	 eax, eax
  00835	75 cd		 jne	 SHORT $LN12@Fs_free_fn
$LN8@Fs_free_fn:

; 275  :     ASSERT( fnode->fn_refcnt > 0 );

  00837	8b 4d 08	 mov	 ecx, DWORD PTR _fnode$[ebp]
  0083a	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0083e	7f 29		 jg	 SHORT $LN7@Fs_free_fn
  00840	68 13 01 00 00	 push	 275			; 00000113H
  00845	68 00 00 00 00	 push	 OFFSET $SG2240
  0084a	68 00 00 00 00	 push	 OFFSET $SG2241
  0084f	68 00 00 00 00	 push	 OFFSET $SG2242
  00854	e8 00 00 00 00	 call	 __printf
  00859	83 c4 10	 add	 esp, 16			; 00000010H
  0085c	68 00 00 00 00	 push	 OFFSET $SG2243
  00861	e8 00 00 00 00	 call	 _Sys_halt
  00866	83 c4 04	 add	 esp, 4
$LN7@Fs_free_fn:
  00869	33 d2		 xor	 edx, edx
  0086b	75 ca		 jne	 SHORT $LN8@Fs_free_fn
$LN4@Fs_free_fn:

; 276  :     CRITICAL_BEGIN();

  0086d	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00872	89 45 fc	 mov	 DWORD PTR ___psw$[ebp], eax
  00875	33 c0		 xor	 eax, eax
  00877	75 f4		 jne	 SHORT $LN4@Fs_free_fn

; 277  :     /*  没有引用后立即释放  */
; 278  :     if( --fnode->fn_refcnt == 0 )

  00879	8b 4d 08	 mov	 ecx, DWORD PTR _fnode$[ebp]
  0087c	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0087f	83 ea 01	 sub	 edx, 1
  00882	8b 45 08	 mov	 eax, DWORD PTR _fnode$[ebp]
  00885	89 50 38	 mov	 DWORD PTR [eax+56], edx
  00888	8b 4d 08	 mov	 ecx, DWORD PTR _fnode$[ebp]
  0088b	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0088f	75 0e		 jne	 SHORT $LN1@Fs_free_fn

; 279  :         _memzero(fnode,sizeof(fnode_t));

  00891	6a 48		 push	 72			; 00000048H
  00893	8b 55 08	 mov	 edx, DWORD PTR _fnode$[ebp]
  00896	52		 push	 edx
  00897	e8 00 00 00 00	 call	 __memzero
  0089c	83 c4 08	 add	 esp, 8
$LN1@Fs_free_fn:

; 280  :     CRITICAL_END();

  0089f	8b 45 fc	 mov	 eax, DWORD PTR ___psw$[ebp]
  008a2	50		 push	 eax
  008a3	e8 00 00 00 00	 call	 _Cpu_psw_set
  008a8	83 c4 04	 add	 esp, 4

; 281  : }

  008ab	8b e5		 mov	 esp, ebp
  008ad	5d		 pop	 ebp
  008ae	c3		 ret	 0
_Fs_free_fnode ENDP
_TEXT	ENDS
_BSS	SEGMENT
_fs_file_pool DB 0300H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
tv79 = -12						; size = 4
___psw$ = -8						; size = 4
_i$ = -4						; size = 4
_Fs_alloc_file PROC

; 286  : {

  008b0	55		 push	 ebp
  008b1	8b ec		 mov	 ebp, esp
  008b3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 287  :     int             i = 0;

  008b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN7@Fs_alloc_f@2:

; 288  :     CRITICAL_DECLARE(fs_file_lock);
; 289  : 
; 290  :     CRITICAL_BEGIN();

  008bd	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  008c2	89 45 f8	 mov	 DWORD PTR ___psw$[ebp], eax
  008c5	33 c0		 xor	 eax, eax
  008c7	75 f4		 jne	 SHORT $LN7@Fs_alloc_f@2

; 291  :     for( i = 0 ; i < FS_FILE_MAX ; i++)

  008c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  008d0	eb 09		 jmp	 SHORT $LN4@Fs_alloc_f@2
$LN3@Fs_alloc_f@2:
  008d2	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  008d5	83 c1 01	 add	 ecx, 1
  008d8	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN4@Fs_alloc_f@2:
  008db	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  008df	7d 23		 jge	 SHORT $LN2@Fs_alloc_f@2

; 292  :     {
; 293  :         if( fs_file_pool[i].f_object == NULL )

  008e1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  008e4	6b d2 18	 imul	 edx, 24			; 00000018H
  008e7	83 ba 08 00 00
	00 00		 cmp	 DWORD PTR _fs_file_pool[edx+8], 0
  008ee	75 12		 jne	 SHORT $LN1@Fs_alloc_f@2

; 294  :         {
; 295  :             fs_file_pool[i].f_object = (void *)-1;

  008f0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  008f3	6b c0 18	 imul	 eax, 24			; 00000018H
  008f6	c7 80 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _fs_file_pool[eax+8], -1

; 296  :             break;

  00900	eb 02		 jmp	 SHORT $LN2@Fs_alloc_f@2
$LN1@Fs_alloc_f@2:

; 297  :         }
; 298  :     }

  00902	eb ce		 jmp	 SHORT $LN3@Fs_alloc_f@2
$LN2@Fs_alloc_f@2:

; 299  :     CRITICAL_END();

  00904	8b 4d f8	 mov	 ecx, DWORD PTR ___psw$[ebp]
  00907	51		 push	 ecx
  00908	e8 00 00 00 00	 call	 _Cpu_psw_set
  0090d	83 c4 04	 add	 esp, 4

; 300  : 
; 301  :     return i < FS_FILE_MAX ? fs_file_pool + i : NULL ;

  00910	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00914	7d 11		 jge	 SHORT $LN10@Fs_alloc_f@2
  00916	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00919	6b d2 18	 imul	 edx, 24			; 00000018H
  0091c	81 c2 00 00 00
	00		 add	 edx, OFFSET _fs_file_pool
  00922	89 55 f4	 mov	 DWORD PTR tv79[ebp], edx
  00925	eb 07		 jmp	 SHORT $LN11@Fs_alloc_f@2
$LN10@Fs_alloc_f@2:
  00927	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN11@Fs_alloc_f@2:
  0092e	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp]

; 302  : }

  00931	8b e5		 mov	 esp, ebp
  00933	5d		 pop	 ebp
  00934	c3		 ret	 0
_Fs_alloc_file ENDP
; Function compile flags: /Odtp
___psw$ = -4						; size = 4
_file$ = 8						; size = 4
_Fs_free_file PROC

; 307  : {

  00940	55		 push	 ebp
  00941	8b ec		 mov	 ebp, esp
  00943	51		 push	 ecx
$LN11@Fs_free_fi:

; 308  :     CRITICAL_DECLARE(fs_file_lock);
; 309  : 
; 310  :     ASSERT(file);

  00944	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00948	75 29		 jne	 SHORT $LN10@Fs_free_fi
  0094a	68 36 01 00 00	 push	 310			; 00000136H
  0094f	68 00 00 00 00	 push	 OFFSET $SG2273
  00954	68 00 00 00 00	 push	 OFFSET $SG2274
  00959	68 00 00 00 00	 push	 OFFSET $SG2275
  0095e	e8 00 00 00 00	 call	 __printf
  00963	83 c4 10	 add	 esp, 16			; 00000010H
  00966	68 00 00 00 00	 push	 OFFSET $SG2276
  0096b	e8 00 00 00 00	 call	 _Sys_halt
  00970	83 c4 04	 add	 esp, 4
$LN10@Fs_free_fi:
  00973	33 c0		 xor	 eax, eax
  00975	75 cd		 jne	 SHORT $LN11@Fs_free_fi
$LN7@Fs_free_fi:

; 311  :     ASSERT(file->f_object);

  00977	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0097a	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0097e	75 29		 jne	 SHORT $LN6@Fs_free_fi
  00980	68 37 01 00 00	 push	 311			; 00000137H
  00985	68 00 00 00 00	 push	 OFFSET $SG2281
  0098a	68 00 00 00 00	 push	 OFFSET $SG2282
  0098f	68 00 00 00 00	 push	 OFFSET $SG2283
  00994	e8 00 00 00 00	 call	 __printf
  00999	83 c4 10	 add	 esp, 16			; 00000010H
  0099c	68 00 00 00 00	 push	 OFFSET $SG2284
  009a1	e8 00 00 00 00	 call	 _Sys_halt
  009a6	83 c4 04	 add	 esp, 4
$LN6@Fs_free_fi:
  009a9	33 d2		 xor	 edx, edx
  009ab	75 ca		 jne	 SHORT $LN7@Fs_free_fi
$LN3@Fs_free_fi:

; 312  :     CRITICAL_BEGIN();

  009ad	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  009b2	89 45 fc	 mov	 DWORD PTR ___psw$[ebp], eax
  009b5	33 c0		 xor	 eax, eax
  009b7	75 f4		 jne	 SHORT $LN3@Fs_free_fi

; 313  :     _memzero(file,sizeof(file_t));

  009b9	6a 18		 push	 24			; 00000018H
  009bb	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  009be	51		 push	 ecx
  009bf	e8 00 00 00 00	 call	 __memzero
  009c4	83 c4 08	 add	 esp, 8

; 314  :     CRITICAL_END();

  009c7	8b 55 fc	 mov	 edx, DWORD PTR ___psw$[ebp]
  009ca	52		 push	 edx
  009cb	e8 00 00 00 00	 call	 _Cpu_psw_set
  009d0	83 c4 04	 add	 esp, 4

; 315  : }

  009d3	8b e5		 mov	 esp, ebp
  009d5	5d		 pop	 ebp
  009d6	c3		 ret	 0
_Fs_free_file ENDP
_TEXT	ENDS
EXTRN	_Dev_close:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_object$ = -4						; size = 4
_file$ = 8						; size = 4
_Fs_release_file PROC

; 320  : {

  009e0	55		 push	 ebp
  009e1	8b ec		 mov	 ebp, esp
  009e3	51		 push	 ecx

; 321  :     void          * object  = NULL;

  009e4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _object$[ebp], 0
$LN7@Fs_release:

; 322  : 
; 323  :     ASSERT(file);

  009eb	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  009ef	75 29		 jne	 SHORT $LN6@Fs_release
  009f1	68 43 01 00 00	 push	 323			; 00000143H
  009f6	68 00 00 00 00	 push	 OFFSET $SG2299
  009fb	68 00 00 00 00	 push	 OFFSET $SG2300
  00a00	68 00 00 00 00	 push	 OFFSET $SG2301
  00a05	e8 00 00 00 00	 call	 __printf
  00a0a	83 c4 10	 add	 esp, 16			; 00000010H
  00a0d	68 00 00 00 00	 push	 OFFSET $SG2302
  00a12	e8 00 00 00 00	 call	 _Sys_halt
  00a17	83 c4 04	 add	 esp, 4
$LN6@Fs_release:
  00a1a	33 c0		 xor	 eax, eax
  00a1c	75 cd		 jne	 SHORT $LN7@Fs_release

; 324  :     if( NULL == file )

  00a1e	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00a22	75 05		 jne	 SHORT $LN3@Fs_release

; 325  :         return RESULT_FAILED;

  00a24	83 c8 ff	 or	 eax, -1
  00a27	eb 44		 jmp	 SHORT $LN8@Fs_release
$LN3@Fs_release:

; 326  :     object = file->f_object;

  00a29	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00a2c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00a2f	89 55 fc	 mov	 DWORD PTR _object$[ebp], edx

; 327  :     Fs_free_file(file);

  00a32	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00a35	50		 push	 eax
  00a36	e8 00 00 00 00	 call	 _Fs_free_file
  00a3b	83 c4 04	 add	 esp, 4

; 328  :     if( file->f_attr & FILE_ATTR_DEVICE )

  00a3e	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00a41	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00a44	83 e2 01	 and	 edx, 1
  00a47	74 13		 je	 SHORT $LN2@Fs_release

; 329  :         return Dev_close(file->f_object);

  00a49	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00a4c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00a4f	51		 push	 ecx
  00a50	e8 00 00 00 00	 call	 _Dev_close
  00a55	83 c4 04	 add	 esp, 4
  00a58	eb 13		 jmp	 SHORT $LN8@Fs_release

; 330  :     else

  00a5a	eb 0f		 jmp	 SHORT $LN1@Fs_release
$LN2@Fs_release:

; 331  :         Fs_free_fnode(file->f_object);

  00a5c	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00a5f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00a62	50		 push	 eax
  00a63	e8 00 00 00 00	 call	 _Fs_free_fnode
  00a68	83 c4 04	 add	 esp, 4
$LN1@Fs_release:

; 332  :     return RESULT_SUCCEED;

  00a6b	33 c0		 xor	 eax, eax
$LN8@Fs_release:

; 333  : }

  00a6d	8b e5		 mov	 esp, ebp
  00a6f	5d		 pop	 ebp
  00a70	c3		 ret	 0
_Fs_release_file ENDP
_TEXT	ENDS
EXTRN	_Dev_open:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_handle$ = -16						; size = 4
_file$ = -12						; size = 4
_mode$ = -8						; size = 4
_device$ = -4						; size = 4
_name$ = 8						; size = 4
_flags$ = 12						; size = 4
_Fs_open_device PROC

; 344  : {

  00a80	55		 push	 ebp
  00a81	8b ec		 mov	 ebp, esp
  00a83	83 ec 10	 sub	 esp, 16			; 00000010H

; 345  :     file_t        * file        = NULL;

  00a86	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _file$[ebp], 0

; 346  :     device_t      * device      = NULL;

  00a8d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _device$[ebp], 0

; 347  :     handle_t        handle      = INVALID_HANDLE;

  00a94	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _handle$[ebp], 0

; 348  :     int             mode        = 0;

  00a9b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mode$[ebp], 0

; 349  : 
; 350  :     _printk("open device flags:%08X\n",flags);

  00aa2	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00aa5	50		 push	 eax
  00aa6	68 00 00 00 00	 push	 OFFSET $SG2324
  00aab	e8 00 00 00 00	 call	 __printk
  00ab0	83 c4 08	 add	 esp, 8

; 351  :     if( flags & FNODE_ATTR_READ )

  00ab3	8b 4d 0c	 mov	 ecx, DWORD PTR _flags$[ebp]
  00ab6	83 e1 02	 and	 ecx, 2
  00ab9	74 09		 je	 SHORT $LN5@Fs_open_de

; 352  :         mode |= DEV_MODE_READ;

  00abb	8b 55 f8	 mov	 edx, DWORD PTR _mode$[ebp]
  00abe	83 ca 04	 or	 edx, 4
  00ac1	89 55 f8	 mov	 DWORD PTR _mode$[ebp], edx
$LN5@Fs_open_de:

; 353  :     if( flags & FNODE_ATTR_WRITE)

  00ac4	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00ac7	83 e0 04	 and	 eax, 4
  00aca	74 09		 je	 SHORT $LN4@Fs_open_de

; 354  :         mode |= DEV_MODE_WRITE;

  00acc	8b 4d f8	 mov	 ecx, DWORD PTR _mode$[ebp]
  00acf	83 c9 02	 or	 ecx, 2
  00ad2	89 4d f8	 mov	 DWORD PTR _mode$[ebp], ecx
$LN4@Fs_open_de:

; 355  :     if( INVALID_HANDLE == ( device = Dev_open(name,mode) ) )

  00ad5	8b 55 f8	 mov	 edx, DWORD PTR _mode$[ebp]
  00ad8	52		 push	 edx
  00ad9	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00adc	50		 push	 eax
  00add	e8 00 00 00 00	 call	 _Dev_open
  00ae2	83 c4 08	 add	 esp, 8
  00ae5	89 45 fc	 mov	 DWORD PTR _device$[ebp], eax
  00ae8	83 7d fc 00	 cmp	 DWORD PTR _device$[ebp], 0
  00aec	75 14		 jne	 SHORT $LN3@Fs_open_de

; 356  :     {
; 357  :         _printk("open device failed!\n");

  00aee	68 00 00 00 00	 push	 OFFSET $SG2328
  00af3	e8 00 00 00 00	 call	 __printk
  00af8	83 c4 04	 add	 esp, 4

; 358  :         return INVALID_HANDLE;

  00afb	33 c0		 xor	 eax, eax
  00afd	e9 91 00 00 00	 jmp	 $LN6@Fs_open_de
$LN3@Fs_open_de:

; 359  :     }
; 360  :     if( NULL == ( file = Fs_alloc_file() ) )

  00b02	e8 00 00 00 00	 call	 _Fs_alloc_file
  00b07	89 45 f4	 mov	 DWORD PTR _file$[ebp], eax
  00b0a	83 7d f4 00	 cmp	 DWORD PTR _file$[ebp], 0
  00b0e	75 10		 jne	 SHORT $LN2@Fs_open_de

; 361  :     {
; 362  :         Dev_close(device);

  00b10	8b 4d fc	 mov	 ecx, DWORD PTR _device$[ebp]
  00b13	51		 push	 ecx
  00b14	e8 00 00 00 00	 call	 _Dev_close
  00b19	83 c4 04	 add	 esp, 4

; 363  :         return INVALID_HANDLE;

  00b1c	33 c0		 xor	 eax, eax
  00b1e	eb 73		 jmp	 SHORT $LN6@Fs_open_de
$LN2@Fs_open_de:

; 364  :     }
; 365  :     file->f_object  = device;

  00b20	8b 55 f4	 mov	 edx, DWORD PTR _file$[ebp]
  00b23	8b 45 fc	 mov	 eax, DWORD PTR _device$[ebp]
  00b26	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 366  :     file->f_ptr     = 0;

  00b29	8b 4d f4	 mov	 ecx, DWORD PTR _file$[ebp]
  00b2c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  00b33	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 367  :     file->f_attr    = FILE_ATTR_DEVICE;

  00b3a	8b 55 f4	 mov	 edx, DWORD PTR _file$[ebp]
  00b3d	c7 42 04 01 00
	00 00		 mov	 DWORD PTR [edx+4], 1

; 368  :     file->f_attr   |= flags & FS_OPEN_FLAG_RDWR_MASK;

  00b44	8b 45 0c	 mov	 eax, DWORD PTR _flags$[ebp]
  00b47	83 e0 06	 and	 eax, 6
  00b4a	8b 4d f4	 mov	 ecx, DWORD PTR _file$[ebp]
  00b4d	0b 41 04	 or	 eax, DWORD PTR [ecx+4]
  00b50	8b 55 f4	 mov	 edx, DWORD PTR _file$[ebp]
  00b53	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 369  : 
; 370  :     if( INVALID_HANDLE == (handle = Koum_add(file,Fs_release_file,kot_file,0)))

  00b56	6a 00		 push	 0
  00b58	6a 05		 push	 5
  00b5a	68 00 00 00 00	 push	 OFFSET _Fs_release_file
  00b5f	8b 45 f4	 mov	 eax, DWORD PTR _file$[ebp]
  00b62	50		 push	 eax
  00b63	e8 00 00 00 00	 call	 _Koum_add
  00b68	83 c4 10	 add	 esp, 16			; 00000010H
  00b6b	89 45 f0	 mov	 DWORD PTR _handle$[ebp], eax
  00b6e	83 7d f0 00	 cmp	 DWORD PTR _handle$[ebp], 0
  00b72	75 1c		 jne	 SHORT $LN1@Fs_open_de

; 371  :     {
; 372  :         Dev_close(device);

  00b74	8b 4d fc	 mov	 ecx, DWORD PTR _device$[ebp]
  00b77	51		 push	 ecx
  00b78	e8 00 00 00 00	 call	 _Dev_close
  00b7d	83 c4 04	 add	 esp, 4

; 373  :         Fs_free_file(file);

  00b80	8b 55 f4	 mov	 edx, DWORD PTR _file$[ebp]
  00b83	52		 push	 edx
  00b84	e8 00 00 00 00	 call	 _Fs_free_file
  00b89	83 c4 04	 add	 esp, 4

; 374  :         return INVALID_HANDLE;

  00b8c	33 c0		 xor	 eax, eax
  00b8e	eb 03		 jmp	 SHORT $LN6@Fs_open_de
$LN1@Fs_open_de:

; 375  :     }
; 376  : 
; 377  :     return handle;

  00b90	8b 45 f0	 mov	 eax, DWORD PTR _handle$[ebp]
$LN6@Fs_open_de:

; 378  : }

  00b93	8b e5		 mov	 esp, ebp
  00b95	5d		 pop	 ebp
  00b96	c3		 ret	 0
_Fs_open_device ENDP
_TEXT	ENDS
PUBLIC	_Fs_read
EXTRN	_Dev_read:PROC
EXTRN	_Koum_handle_object:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv134 = -20						; size = 4
_fs$ = -16						; size = 4
_nr$ = -12						; size = 4
_f$ = -8						; size = 4
_device$ = -4						; size = 4
_file$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_Fs_read PROC

; 550  : {

  00ba0	55		 push	 ebp
  00ba1	8b ec		 mov	 ebp, esp
  00ba3	83 ec 14	 sub	 esp, 20			; 00000014H

; 551  :     file_t        * f           = NULL;

  00ba6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _f$[ebp], 0

; 552  :     device_t      * device      = NULL;

  00bad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _device$[ebp], 0

; 553  :     fs_t          * fs          = NULL;

  00bb4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fs$[ebp], 0

; 554  :     int             nr          = -1;

  00bbb	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _nr$[ebp], -1

; 555  : 
; 556  :     if( NULL == ( f = Koum_handle_object(file) ) )

  00bc2	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00bc5	50		 push	 eax
  00bc6	e8 00 00 00 00	 call	 _Koum_handle_object
  00bcb	83 c4 04	 add	 esp, 4
  00bce	89 45 f8	 mov	 DWORD PTR _f$[ebp], eax
  00bd1	83 7d f8 00	 cmp	 DWORD PTR _f$[ebp], 0
  00bd5	75 05		 jne	 SHORT $LN14@Fs_read

; 557  :         goto fs_read_end;

  00bd7	e9 73 01 00 00	 jmp	 $fs_read_end$2425
$LN14@Fs_read:

; 558  :     /*  打开文件时，没有允许读  */
; 559  :     if( !( f->f_attr & FILE_ATTR_READ ) )

  00bdc	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  00bdf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00be2	83 e2 02	 and	 edx, 2
  00be5	75 12		 jne	 SHORT $LN13@Fs_read

; 560  :     {
; 561  :         _printk("read deny\n");

  00be7	68 00 00 00 00	 push	 OFFSET $SG2427
  00bec	e8 00 00 00 00	 call	 __printk
  00bf1	83 c4 04	 add	 esp, 4

; 562  :         goto fs_read_end;

  00bf4	e9 56 01 00 00	 jmp	 $fs_read_end$2425
$LN13@Fs_read:

; 563  :     }
; 564  :     if( f->f_attr & FILE_ATTR_DEVICE )

  00bf9	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00bfc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00bff	83 e1 01	 and	 ecx, 1
  00c02	74 37		 je	 SHORT $LN12@Fs_read

; 565  :     {
; 566  :         _printk("device read\n");

  00c04	68 00 00 00 00	 push	 OFFSET $SG2429
  00c09	e8 00 00 00 00	 call	 __printk
  00c0e	83 c4 04	 add	 esp, 4

; 567  :         nr = Dev_read(f->f_object,f->f_ptr,buffer,size);

  00c11	8b 55 10	 mov	 edx, DWORD PTR _size$[ebp]
  00c14	52		 push	 edx
  00c15	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00c18	50		 push	 eax
  00c19	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  00c1c	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00c1f	52		 push	 edx
  00c20	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00c23	50		 push	 eax
  00c24	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  00c27	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00c2a	52		 push	 edx
  00c2b	e8 00 00 00 00	 call	 _Dev_read
  00c30	83 c4 14	 add	 esp, 20			; 00000014H
  00c33	89 45 f4	 mov	 DWORD PTR _nr$[ebp], eax

; 568  :     }
; 569  :     else

  00c36	e9 14 01 00 00	 jmp	 $fs_read_end$2425
$LN12@Fs_read:

; 570  :     {
; 571  :         _printk("file read\n");

  00c3b	68 00 00 00 00	 push	 OFFSET $SG2431
  00c40	e8 00 00 00 00	 call	 __printk
  00c45	83 c4 04	 add	 esp, 4
$LN10@Fs_read:

; 572  :         FS_CHECK_FNODE(f->f_object);

  00c48	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00c4b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00c4e	2d 00 00 00 00	 sub	 eax, OFFSET _fs_fnode_pool
  00c53	33 d2		 xor	 edx, edx
  00c55	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00c5a	f7 f1		 div	 ecx
  00c5c	85 d2		 test	 edx, edx
  00c5e	75 0c		 jne	 SHORT $LN6@Fs_read
  00c60	8b 55 f8	 mov	 edx, DWORD PTR _f$[ebp]
  00c63	81 7a 08 00 00
	00 00		 cmp	 DWORD PTR [edx+8], OFFSET _fs_fnode_pool
  00c6a	77 29		 ja	 SHORT $LN9@Fs_read
$LN6@Fs_read:
  00c6c	68 3c 02 00 00	 push	 572			; 0000023cH
  00c71	68 00 00 00 00	 push	 OFFSET $SG2442
  00c76	68 00 00 00 00	 push	 OFFSET $SG2443
  00c7b	68 00 00 00 00	 push	 OFFSET $SG2444
  00c80	e8 00 00 00 00	 call	 __printf
  00c85	83 c4 10	 add	 esp, 16			; 00000010H
  00c88	68 00 00 00 00	 push	 OFFSET $SG2445
  00c8d	e8 00 00 00 00	 call	 _Sys_halt
  00c92	83 c4 04	 add	 esp, 4
$LN9@Fs_read:
  00c95	33 c0		 xor	 eax, eax
  00c97	75 af		 jne	 SHORT $LN10@Fs_read

; 573  :         fs = FNODE_GET_FS((fnode_t *)(f->f_object));

  00c99	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  00c9c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00c9f	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00ca3	74 0e		 je	 SHORT $LN17@Fs_read
  00ca5	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00ca8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00cab	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00cae	89 55 ec	 mov	 DWORD PTR tv134[ebp], edx
  00cb1	eb 0c		 jmp	 SHORT $LN18@Fs_read
$LN17@Fs_read:
  00cb3	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00cb6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00cb9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00cbc	89 55 ec	 mov	 DWORD PTR tv134[ebp], edx
$LN18@Fs_read:
  00cbf	8b 45 ec	 mov	 eax, DWORD PTR tv134[ebp]
  00cc2	89 45 f0	 mov	 DWORD PTR _fs$[ebp], eax
$LN5@Fs_read:

; 574  :         ASSERT(fs && fs->fs_drv);

  00cc5	83 7d f0 00	 cmp	 DWORD PTR _fs$[ebp], 0
  00cc9	74 09		 je	 SHORT $LN1@Fs_read
  00ccb	8b 4d f0	 mov	 ecx, DWORD PTR _fs$[ebp]
  00cce	83 79 60 00	 cmp	 DWORD PTR [ecx+96], 0
  00cd2	75 29		 jne	 SHORT $LN4@Fs_read
$LN1@Fs_read:
  00cd4	68 3e 02 00 00	 push	 574			; 0000023eH
  00cd9	68 00 00 00 00	 push	 OFFSET $SG2455
  00cde	68 00 00 00 00	 push	 OFFSET $SG2456
  00ce3	68 00 00 00 00	 push	 OFFSET $SG2457
  00ce8	e8 00 00 00 00	 call	 __printf
  00ced	83 c4 10	 add	 esp, 16			; 00000010H
  00cf0	68 00 00 00 00	 push	 OFFSET $SG2458
  00cf5	e8 00 00 00 00	 call	 _Sys_halt
  00cfa	83 c4 04	 add	 esp, 4
$LN4@Fs_read:
  00cfd	33 d2		 xor	 edx, edx
  00cff	75 c4		 jne	 SHORT $LN5@Fs_read

; 575  :         FS_LOCK(fs);

  00d01	8b 45 f0	 mov	 eax, DWORD PTR _fs$[ebp]
  00d04	05 68 02 00 00	 add	 eax, 616		; 00000268H
  00d09	50		 push	 eax
  00d0a	e8 00 00 00 00	 call	 _Lck_lock
  00d0f	83 c4 04	 add	 esp, 4

; 576  :         nr = fs->fs_drv->fs_fnode_read(FILE_FNODE(f),f->f_ptr,buffer,size);

  00d12	8b 4d 10	 mov	 ecx, DWORD PTR _size$[ebp]
  00d15	51		 push	 ecx
  00d16	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00d19	52		 push	 edx
  00d1a	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00d1d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00d20	51		 push	 ecx
  00d21	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00d24	52		 push	 edx
  00d25	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  00d28	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00d2b	51		 push	 ecx
  00d2c	8b 55 f0	 mov	 edx, DWORD PTR _fs$[ebp]
  00d2f	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00d32	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00d35	ff d1		 call	 ecx
  00d37	83 c4 14	 add	 esp, 20			; 00000014H
  00d3a	89 45 f4	 mov	 DWORD PTR _nr$[ebp], eax

; 577  :         FS_FREE(fs);

  00d3d	8b 55 f0	 mov	 edx, DWORD PTR _fs$[ebp]
  00d40	81 c2 68 02 00
	00		 add	 edx, 616		; 00000268H
  00d46	52		 push	 edx
  00d47	e8 00 00 00 00	 call	 _Lck_free
  00d4c	83 c4 04	 add	 esp, 4
$fs_read_end$2425:

; 578  :     }
; 579  : 
; 580  : fs_read_end:
; 581  :     return nr;

  00d4f	8b 45 f4	 mov	 eax, DWORD PTR _nr$[ebp]

; 582  : }

  00d52	8b e5		 mov	 esp, ebp
  00d54	5d		 pop	 ebp
  00d55	c3		 ret	 0
_Fs_read ENDP
_TEXT	ENDS
PUBLIC	_Fs_initial
EXTRN	_Fat32_register:PROC
_BSS	SEGMENT
_fs_pool DB	02780H DUP (?)
_fs_active DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_Fs_initial PROC

; 584  : {

  00d60	55		 push	 ebp
  00d61	8b ec		 mov	 ebp, esp

; 585  :     _printk("file system initial...\n");

  00d63	68 00 00 00 00	 push	 OFFSET $SG2463
  00d68	e8 00 00 00 00	 call	 __printk
  00d6d	83 c4 04	 add	 esp, 4

; 586  :     fs_active = -1;

  00d70	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR _fs_active, -1

; 587  :     Fs_detect_partition();

  00d7a	e8 00 00 00 00	 call	 _Fs_detect_partition

; 588  :     Fs_register(Fat32_register);

  00d7f	68 00 00 00 00	 push	 OFFSET _Fat32_register
  00d84	e8 00 00 00 00	 call	 _Fs_register
  00d89	83 c4 04	 add	 esp, 4

; 589  :     /*  逐个初始化分区 */
; 590  :     Fs_specify();

  00d8c	e8 00 00 00 00	 call	 _Fs_specify

; 591  :     if( fs_active == -1 )

  00d91	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _fs_active, -1
  00d98	75 0f		 jne	 SHORT $LN2@Fs_initial

; 592  :         _printk("no active file system!\n");

  00d9a	68 00 00 00 00	 push	 OFFSET $SG2465
  00d9f	e8 00 00 00 00	 call	 __printk
  00da4	83 c4 04	 add	 esp, 4

; 593  :     else

  00da7	eb 15		 jmp	 SHORT $LN1@Fs_initial
$LN2@Fs_initial:

; 594  :         fs_root = &fs_pool[fs_active].fs_root;

  00da9	a1 00 00 00 00	 mov	 eax, DWORD PTR _fs_active
  00dae	69 c0 78 02 00
	00		 imul	 eax, 632		; 00000278H
  00db4	05 18 00 00 00	 add	 eax, OFFSET _fs_pool+24
  00db9	a3 00 00 00 00	 mov	 DWORD PTR _fs_root, eax
$LN1@Fs_initial:

; 595  :     Fs_information();

  00dbe	e8 00 00 00 00	 call	 _Fs_information

; 596  :     _printk("file system initial OK!\n");

  00dc3	68 00 00 00 00	 push	 OFFSET $SG2467
  00dc8	e8 00 00 00 00	 call	 __printk
  00dcd	83 c4 04	 add	 esp, 4

; 597  : }

  00dd0	5d		 pop	 ebp
  00dd1	c3		 ret	 0
_Fs_initial ENDP
_TEXT	ENDS
_BSS	SEGMENT
_fs_cnt	DD	01H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Fs_information PROC

; 60   : {

  00de0	55		 push	 ebp
  00de1	8b ec		 mov	 ebp, esp
  00de3	51		 push	 ecx

; 61   :     int             i;
; 62   : 
; 63   :     _printk("total file system(partition): %d\n",fs_cnt);

  00de4	a1 00 00 00 00	 mov	 eax, DWORD PTR _fs_cnt
  00de9	50		 push	 eax
  00dea	68 00 00 00 00	 push	 OFFSET $SG2056
  00def	e8 00 00 00 00	 call	 __printk
  00df4	83 c4 08	 add	 esp, 8

; 64   :     _printk("active file system: %d\n",fs_active);

  00df7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fs_active
  00dfd	51		 push	 ecx
  00dfe	68 00 00 00 00	 push	 OFFSET $SG2057
  00e03	e8 00 00 00 00	 call	 __printk
  00e08	83 c4 08	 add	 esp, 8

; 65   :     _printk("total file system driver: %d\n",fs_drv_cnt);

  00e0b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _fs_drv_cnt
  00e11	52		 push	 edx
  00e12	68 00 00 00 00	 push	 OFFSET $SG2058
  00e17	e8 00 00 00 00	 call	 __printk
  00e1c	83 c4 08	 add	 esp, 8

; 66   :     _printk("partition information:\n");

  00e1f	68 00 00 00 00	 push	 OFFSET $SG2059
  00e24	e8 00 00 00 00	 call	 __printk
  00e29	83 c4 04	 add	 esp, 4

; 67   :     for( i = 0  ; i < fs_cnt ; i++)

  00e2c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e33	eb 09		 jmp	 SHORT $LN3@Fs_informa
$LN2@Fs_informa:
  00e35	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e38	83 c0 01	 add	 eax, 1
  00e3b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@Fs_informa:
  00e3e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00e41	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _fs_cnt
  00e47	7d 4d		 jge	 SHORT $LN4@Fs_informa

; 68   :     {
; 69   :         _printk("    type=%02X,start=%-10ld,total=%-10ld \n",
; 70   :             fs_pool[i].fs_part.fsp_type,
; 71   :             fs_pool[i].fs_part.fsp_start,
; 72   :             fs_pool[i].fs_part.fsp_total);

  00e49	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00e4c	69 d2 78 02 00
	00		 imul	 edx, 632		; 00000278H
  00e52	8b 82 14 00 00
	00		 mov	 eax, DWORD PTR _fs_pool[edx+20]
  00e58	50		 push	 eax
  00e59	8b 8a 10 00 00
	00		 mov	 ecx, DWORD PTR _fs_pool[edx+16]
  00e5f	51		 push	 ecx
  00e60	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00e63	69 d2 78 02 00
	00		 imul	 edx, 632		; 00000278H
  00e69	8b 82 0c 00 00
	00		 mov	 eax, DWORD PTR _fs_pool[edx+12]
  00e6f	50		 push	 eax
  00e70	8b 8a 08 00 00
	00		 mov	 ecx, DWORD PTR _fs_pool[edx+8]
  00e76	51		 push	 ecx
  00e77	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00e7a	69 d2 78 02 00
	00		 imul	 edx, 632		; 00000278H
  00e80	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _fs_pool[edx+4]
  00e86	50		 push	 eax
  00e87	68 00 00 00 00	 push	 OFFSET $SG2063
  00e8c	e8 00 00 00 00	 call	 __printk
  00e91	83 c4 18	 add	 esp, 24			; 00000018H

; 73   :     }

  00e94	eb 9f		 jmp	 SHORT $LN2@Fs_informa
$LN4@Fs_informa:

; 74   : }

  00e96	8b e5		 mov	 esp, ebp
  00e98	5d		 pop	 ebp
  00e99	c3		 ret	 0
_Fs_information ENDP
_TEXT	ENDS
EXTRN	_Bbuf_release:PROC
EXTRN	_Bbuf_read:PROC
EXTRN	_Dev_sdl_next:PROC
EXTRN	_Dev_sdl_first:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fs_part$ = -20						; size = 4
_blkdev$ = -16						; size = 4
_part$ = -12						; size = 4
_blkbuf$ = -8						; size = 4
_i$ = -4						; size = 4
_Fs_detect_partition PROC

; 109  : {

  00ea0	55		 push	 ebp
  00ea1	8b ec		 mov	 ebp, esp
  00ea3	83 ec 14	 sub	 esp, 20			; 00000014H

; 110  :     device_t      * blkdev      = NULL;

  00ea6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _blkdev$[ebp], 0

; 111  :     blkbuf_t      * blkbuf      = NULL;

  00ead	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _blkbuf$[ebp], 0

; 112  :     partition_t   * part        = NULL;

  00eb4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _part$[ebp], 0

; 113  :     fsp_t         * fs_part     = NULL;

  00ebb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _fs_part$[ebp], 0

; 114  :     int             i           = 0;

  00ec2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 115  : 
; 116  :     /*  注册文件系统驱动 */
; 117  : 
; 118  :     /*  初始化期间，不会有其他进程，因此不需要锁定系统设备列表  */
; 119  :     blkdev = Dev_sdl_first();

  00ec9	e8 00 00 00 00	 call	 _Dev_sdl_first
  00ece	89 45 f0	 mov	 DWORD PTR _blkdev$[ebp], eax

; 120  :     for( blkdev = Dev_sdl_first() ; blkdev ; blkdev = Dev_sdl_next(blkdev) )

  00ed1	e8 00 00 00 00	 call	 _Dev_sdl_first
  00ed6	89 45 f0	 mov	 DWORD PTR _blkdev$[ebp], eax
  00ed9	eb 0f		 jmp	 SHORT $LN12@Fs_detect_
$LN11@Fs_detect_:
  00edb	8b 45 f0	 mov	 eax, DWORD PTR _blkdev$[ebp]
  00ede	50		 push	 eax
  00edf	e8 00 00 00 00	 call	 _Dev_sdl_next
  00ee4	83 c4 04	 add	 esp, 4
  00ee7	89 45 f0	 mov	 DWORD PTR _blkdev$[ebp], eax
$LN12@Fs_detect_:
  00eea	83 7d f0 00	 cmp	 DWORD PTR _blkdev$[ebp], 0
  00eee	0f 84 51 01 00
	00		 je	 $LN13@Fs_detect_

; 121  :     {
; 122  :         if( !( blkdev->dev_flag & DEV_FLAG_BLOCK ) )

  00ef4	8b 4d f0	 mov	 ecx, DWORD PTR _blkdev$[ebp]
  00ef7	0f b6 51 1e	 movzx	 edx, BYTE PTR [ecx+30]
  00efb	83 e2 04	 and	 edx, 4
  00efe	75 02		 jne	 SHORT $LN9@Fs_detect_

; 123  :             continue;

  00f00	eb d9		 jmp	 SHORT $LN11@Fs_detect_
$LN9@Fs_detect_:

; 124  :         if( NULL == ( blkbuf  = Bbuf_read(blkdev,0) ) )

  00f02	6a 00		 push	 0
  00f04	6a 00		 push	 0
  00f06	8b 45 f0	 mov	 eax, DWORD PTR _blkdev$[ebp]
  00f09	50		 push	 eax
  00f0a	e8 00 00 00 00	 call	 _Bbuf_read
  00f0f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f12	89 45 f8	 mov	 DWORD PTR _blkbuf$[ebp], eax
  00f15	83 7d f8 00	 cmp	 DWORD PTR _blkbuf$[ebp], 0
  00f19	75 02		 jne	 SHORT $LN8@Fs_detect_

; 125  :             continue;

  00f1b	eb be		 jmp	 SHORT $LN11@Fs_detect_
$LN8@Fs_detect_:

; 126  :         part    = (partition_t *)((byte_t *)blkbuf->bb_buffer + 0x1BE );

  00f1d	8b 4d f8	 mov	 ecx, DWORD PTR _blkbuf$[ebp]
  00f20	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00f23	81 c2 be 01 00
	00		 add	 edx, 446		; 000001beH
  00f29	89 55 f4	 mov	 DWORD PTR _part$[ebp], edx

; 127  :         for( i = 0 ; i < 4 && fs_cnt < FS_PART_MAX; i++)

  00f2c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f33	eb 09		 jmp	 SHORT $LN7@Fs_detect_
$LN6@Fs_detect_:
  00f35	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00f38	83 c0 01	 add	 eax, 1
  00f3b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@Fs_detect_:
  00f3e	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  00f42	0f 8d ec 00 00
	00		 jge	 $LN5@Fs_detect_
  00f48	83 3d 00 00 00
	00 10		 cmp	 DWORD PTR _fs_cnt, 16	; 00000010H
  00f4f	0f 8d df 00 00
	00		 jge	 $LN5@Fs_detect_

; 128  :         {
; 129  :             if( fs_active == -1 && part[i].part_flag == FS_PART_FALG_ACTIVE)

  00f55	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR _fs_active, -1
  00f5c	75 20		 jne	 SHORT $LN4@Fs_detect_
  00f5e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00f61	c1 e1 04	 shl	 ecx, 4
  00f64	8b 55 f4	 mov	 edx, DWORD PTR _part$[ebp]
  00f67	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00f6b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00f70	75 0c		 jne	 SHORT $LN4@Fs_detect_

; 130  :                 fs_active = fs_cnt;

  00f72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fs_cnt
  00f78	89 0d 00 00 00
	00		 mov	 DWORD PTR _fs_active, ecx
$LN4@Fs_detect_:

; 131  :             if( part[i].part_type == FS_PART_TYPE_UNDEF )

  00f7e	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00f81	c1 e2 04	 shl	 edx, 4
  00f84	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  00f87	0f b6 4c 10 04	 movzx	 ecx, BYTE PTR [eax+edx+4]
  00f8c	85 c9		 test	 ecx, ecx
  00f8e	75 02		 jne	 SHORT $LN3@Fs_detect_

; 132  :                 continue;

  00f90	eb a3		 jmp	 SHORT $LN6@Fs_detect_
$LN3@Fs_detect_:

; 133  :             /*  对于FAT32扩展分区要特殊处理 */
; 134  :             if( part[i].part_type == FS_PART_TYPE_FAT32_EXT )

  00f92	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00f95	c1 e2 04	 shl	 edx, 4
  00f98	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  00f9b	0f b6 4c 10 04	 movzx	 ecx, BYTE PTR [eax+edx+4]
  00fa0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00fa3	75 1c		 jne	 SHORT $LN2@Fs_detect_

; 135  :                 Fs_fat32_ext(blkdev,part[i].part_rel_start);

  00fa5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00fa8	c1 e2 04	 shl	 edx, 4
  00fab	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  00fae	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  00fb2	51		 push	 ecx
  00fb3	8b 55 f0	 mov	 edx, DWORD PTR _blkdev$[ebp]
  00fb6	52		 push	 edx
  00fb7	e8 00 00 00 00	 call	 _Fs_fat32_ext
  00fbc	83 c4 08	 add	 esp, 8

; 136  :             else

  00fbf	eb 6e		 jmp	 SHORT $LN1@Fs_detect_
$LN2@Fs_detect_:

; 137  :             {
; 138  :                 fs_part = (fsp_t *)(fs_pool + fs_cnt++);

  00fc1	a1 00 00 00 00	 mov	 eax, DWORD PTR _fs_cnt
  00fc6	69 c0 78 02 00
	00		 imul	 eax, 632		; 00000278H
  00fcc	05 00 00 00 00	 add	 eax, OFFSET _fs_pool
  00fd1	89 45 ec	 mov	 DWORD PTR _fs_part$[ebp], eax
  00fd4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fs_cnt
  00fda	83 c1 01	 add	 ecx, 1
  00fdd	89 0d 00 00 00
	00		 mov	 DWORD PTR _fs_cnt, ecx

; 139  :                 fs_part->fsp_dev    = blkdev;

  00fe3	8b 55 ec	 mov	 edx, DWORD PTR _fs_part$[ebp]
  00fe6	8b 45 f0	 mov	 eax, DWORD PTR _blkdev$[ebp]
  00fe9	89 02		 mov	 DWORD PTR [edx], eax

; 140  :                 fs_part->fsp_type   = part[i].part_type;

  00feb	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00fee	c1 e1 04	 shl	 ecx, 4
  00ff1	8b 55 f4	 mov	 edx, DWORD PTR _part$[ebp]
  00ff4	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  00ff9	8b 4d ec	 mov	 ecx, DWORD PTR _fs_part$[ebp]
  00ffc	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 141  :                 fs_part->fsp_start  = part[i].part_rel_start;

  00fff	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  01002	c1 e2 04	 shl	 edx, 4
  01005	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  01008	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  0100c	33 d2		 xor	 edx, edx
  0100e	8b 45 ec	 mov	 eax, DWORD PTR _fs_part$[ebp]
  01011	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  01014	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 142  :                 fs_part->fsp_total  = part[i].part_total_sector;

  01017	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0101a	c1 e1 04	 shl	 ecx, 4
  0101d	8b 55 f4	 mov	 edx, DWORD PTR _part$[ebp]
  01020	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  01024	33 c9		 xor	 ecx, ecx
  01026	8b 55 ec	 mov	 edx, DWORD PTR _fs_part$[ebp]
  01029	89 42 10	 mov	 DWORD PTR [edx+16], eax
  0102c	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$LN1@Fs_detect_:

; 143  :             }
; 144  :         }

  0102f	e9 01 ff ff ff	 jmp	 $LN6@Fs_detect_
$LN5@Fs_detect_:

; 145  :         Bbuf_release(blkbuf);

  01034	8b 45 f8	 mov	 eax, DWORD PTR _blkbuf$[ebp]
  01037	50		 push	 eax
  01038	e8 00 00 00 00	 call	 _Bbuf_release
  0103d	83 c4 04	 add	 esp, 4

; 146  :     }

  01040	e9 96 fe ff ff	 jmp	 $LN11@Fs_detect_
$LN13@Fs_detect_:

; 147  : }

  01045	8b e5		 mov	 esp, ebp
  01047	5d		 pop	 ebp
  01048	c3		 ret	 0
_Fs_detect_partition ENDP
; Function compile flags: /Odtp
_fs_part$ = -16					; size = 4
_part$ = -12						; size = 4
_blkbuf$ = -8						; size = 4
_i$ = -4						; size = 4
_blkdev$ = 8						; size = 4
_start$ = 12						; size = 4
_Fs_fat32_ext PROC

; 79   : {

  01050	55		 push	 ebp
  01051	8b ec		 mov	 ebp, esp
  01053	83 ec 10	 sub	 esp, 16			; 00000010H

; 80   :     blkbuf_t      * blkbuf      = NULL;

  01056	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _blkbuf$[ebp], 0

; 81   :     partition_t   * part        = NULL;

  0105d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _part$[ebp], 0

; 82   :     fsp_t         * fs_part     = NULL;

  01064	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fs_part$[ebp], 0

; 83   :     int             i           = 0;

  0106b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 84   : 
; 85   :     if( NULL == ( blkbuf = Bbuf_read(blkdev,start) ) )

  01072	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  01075	33 c9		 xor	 ecx, ecx
  01077	51		 push	 ecx
  01078	50		 push	 eax
  01079	8b 55 08	 mov	 edx, DWORD PTR _blkdev$[ebp]
  0107c	52		 push	 edx
  0107d	e8 00 00 00 00	 call	 _Bbuf_read
  01082	83 c4 0c	 add	 esp, 12			; 0000000cH
  01085	89 45 f8	 mov	 DWORD PTR _blkbuf$[ebp], eax
  01088	83 7d f8 00	 cmp	 DWORD PTR _blkbuf$[ebp], 0
  0108c	75 05		 jne	 SHORT $LN7@Fs_fat32_e

; 86   :         return ;

  0108e	e9 f6 00 00 00	 jmp	 $LN8@Fs_fat32_e
$LN7@Fs_fat32_e:

; 87   :     part = (partition_t *)((byte_t *)BBUF_TO_SECTOR(blkbuf,start) + 0x1BE );

  01093	8b 45 0c	 mov	 eax, DWORD PTR _start$[ebp]
  01096	83 e0 07	 and	 eax, 7
  01099	c1 e0 09	 shl	 eax, 9
  0109c	8b 4d f8	 mov	 ecx, DWORD PTR _blkbuf$[ebp]
  0109f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  010a2	8d 84 02 be 01
	00 00		 lea	 eax, DWORD PTR [edx+eax+446]
  010a9	89 45 f4	 mov	 DWORD PTR _part$[ebp], eax
  010ac	eb 09		 jmp	 SHORT $LN6@Fs_fat32_e
$LN5@Fs_fat32_e:

; 88   :     for( ; i < 4 ; i++ )

  010ae	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  010b1	83 c1 01	 add	 ecx, 1
  010b4	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@Fs_fat32_e:
  010b7	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  010bb	0f 8d bc 00 00
	00		 jge	 $LN4@Fs_fat32_e

; 89   :     {
; 90   :         if( part[i].part_type == FS_PART_TYPE_UNDEF )

  010c1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  010c4	c1 e2 04	 shl	 edx, 4
  010c7	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  010ca	0f b6 4c 10 04	 movzx	 ecx, BYTE PTR [eax+edx+4]
  010cf	85 c9		 test	 ecx, ecx
  010d1	75 02		 jne	 SHORT $LN3@Fs_fat32_e

; 91   :             continue;

  010d3	eb d9		 jmp	 SHORT $LN5@Fs_fat32_e
$LN3@Fs_fat32_e:

; 92   :         if( part[i].part_type == FS_PART_TYPE_FAT32_EXT )

  010d5	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  010d8	c1 e2 04	 shl	 edx, 4
  010db	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  010de	0f b6 4c 10 04	 movzx	 ecx, BYTE PTR [eax+edx+4]
  010e3	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  010e6	75 1f		 jne	 SHORT $LN2@Fs_fat32_e

; 93   :             Fs_fat32_ext(blkdev,start + part[i].part_rel_start);

  010e8	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  010eb	c1 e2 04	 shl	 edx, 4
  010ee	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  010f1	8b 4d 0c	 mov	 ecx, DWORD PTR _start$[ebp]
  010f4	03 4c 10 08	 add	 ecx, DWORD PTR [eax+edx+8]
  010f8	51		 push	 ecx
  010f9	8b 55 08	 mov	 edx, DWORD PTR _blkdev$[ebp]
  010fc	52		 push	 edx
  010fd	e8 00 00 00 00	 call	 _Fs_fat32_ext
  01102	83 c4 08	 add	 esp, 8

; 94   :         else

  01105	eb 71		 jmp	 SHORT $LN1@Fs_fat32_e
$LN2@Fs_fat32_e:

; 95   :         {
; 96   :             fs_part = (fsp_t *)(fs_pool + fs_cnt++);

  01107	a1 00 00 00 00	 mov	 eax, DWORD PTR _fs_cnt
  0110c	69 c0 78 02 00
	00		 imul	 eax, 632		; 00000278H
  01112	05 00 00 00 00	 add	 eax, OFFSET _fs_pool
  01117	89 45 f0	 mov	 DWORD PTR _fs_part$[ebp], eax
  0111a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fs_cnt
  01120	83 c1 01	 add	 ecx, 1
  01123	89 0d 00 00 00
	00		 mov	 DWORD PTR _fs_cnt, ecx

; 97   :             fs_part->fsp_dev    = blkdev;

  01129	8b 55 f0	 mov	 edx, DWORD PTR _fs_part$[ebp]
  0112c	8b 45 08	 mov	 eax, DWORD PTR _blkdev$[ebp]
  0112f	89 02		 mov	 DWORD PTR [edx], eax

; 98   :             fs_part->fsp_type   = part[i].part_type;

  01131	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  01134	c1 e1 04	 shl	 ecx, 4
  01137	8b 55 f4	 mov	 edx, DWORD PTR _part$[ebp]
  0113a	0f b6 44 0a 04	 movzx	 eax, BYTE PTR [edx+ecx+4]
  0113f	8b 4d f0	 mov	 ecx, DWORD PTR _fs_part$[ebp]
  01142	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 99   :             fs_part->fsp_start  = part[i].part_rel_start + start;

  01145	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  01148	c1 e2 04	 shl	 edx, 4
  0114b	8b 45 f4	 mov	 eax, DWORD PTR _part$[ebp]
  0114e	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  01152	03 4d 0c	 add	 ecx, DWORD PTR _start$[ebp]
  01155	33 d2		 xor	 edx, edx
  01157	8b 45 f0	 mov	 eax, DWORD PTR _fs_part$[ebp]
  0115a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0115d	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 100  :             fs_part->fsp_total  = part[i].part_total_sector;

  01160	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  01163	c1 e1 04	 shl	 ecx, 4
  01166	8b 55 f4	 mov	 edx, DWORD PTR _part$[ebp]
  01169	8b 44 0a 0c	 mov	 eax, DWORD PTR [edx+ecx+12]
  0116d	33 c9		 xor	 ecx, ecx
  0116f	8b 55 f0	 mov	 edx, DWORD PTR _fs_part$[ebp]
  01172	89 42 10	 mov	 DWORD PTR [edx+16], eax
  01175	89 4a 14	 mov	 DWORD PTR [edx+20], ecx
$LN1@Fs_fat32_e:

; 101  :         }
; 102  :     }

  01178	e9 31 ff ff ff	 jmp	 $LN5@Fs_fat32_e
$LN4@Fs_fat32_e:

; 103  :     Bbuf_release(blkbuf);

  0117d	8b 45 f8	 mov	 eax, DWORD PTR _blkbuf$[ebp]
  01180	50		 push	 eax
  01181	e8 00 00 00 00	 call	 _Bbuf_release
  01186	83 c4 04	 add	 esp, 4
$LN8@Fs_fat32_e:

; 104  : }

  01189	8b e5		 mov	 esp, ebp
  0118b	5d		 pop	 ebp
  0118c	c3		 ret	 0
_Fs_fat32_ext ENDP
; Function compile flags: /Odtp
_i$ = -4						; size = 4
_Fs_specify PROC

; 164  : {

  01190	55		 push	 ebp
  01191	8b ec		 mov	 ebp, esp
  01193	51		 push	 ecx

; 165  :     int             i;
; 166  :     for( i = 0 ; i < fs_cnt ; i++)

  01194	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0119b	eb 09		 jmp	 SHORT $LN4@Fs_specify
$LN3@Fs_specify:
  0119d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  011a0	83 c0 01	 add	 eax, 1
  011a3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Fs_specify:
  011a6	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  011a9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _fs_cnt
  011af	7d 61		 jge	 SHORT $LN5@Fs_specify

; 167  :     {
; 168  :         fs_pool[i].fs_drv = Fs_get_driver(fs_pool[i].fs_part.fsp_type);

  011b1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  011b4	69 d2 78 02 00
	00		 imul	 edx, 632		; 00000278H
  011ba	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR _fs_pool[edx+4]
  011c0	50		 push	 eax
  011c1	e8 00 00 00 00	 call	 _Fs_get_driver
  011c6	83 c4 04	 add	 esp, 4
  011c9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  011cc	69 c9 78 02 00
	00		 imul	 ecx, 632		; 00000278H
  011d2	89 81 60 00 00
	00		 mov	 DWORD PTR _fs_pool[ecx+96], eax

; 169  :         if( NULL != fs_pool[i].fs_drv )

  011d8	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  011db	69 d2 78 02 00
	00		 imul	 edx, 632		; 00000278H
  011e1	83 ba 60 00 00
	00 00		 cmp	 DWORD PTR _fs_pool[edx+96], 0
  011e8	74 26		 je	 SHORT $LN1@Fs_specify

; 170  :             fs_pool[i].fs_drv->fs_initial(fs_pool + i);

  011ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  011ed	69 c0 78 02 00
	00		 imul	 eax, 632		; 00000278H
  011f3	05 00 00 00 00	 add	 eax, OFFSET _fs_pool
  011f8	50		 push	 eax
  011f9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  011fc	69 c9 78 02 00
	00		 imul	 ecx, 632		; 00000278H
  01202	8b 91 60 00 00
	00		 mov	 edx, DWORD PTR _fs_pool[ecx+96]
  01208	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0120b	ff d0		 call	 eax
  0120d	83 c4 04	 add	 esp, 4
$LN1@Fs_specify:

; 171  :     }

  01210	eb 8b		 jmp	 SHORT $LN3@Fs_specify
$LN5@Fs_specify:

; 172  : }

  01212	8b e5		 mov	 esp, ebp
  01214	5d		 pop	 ebp
  01215	c3		 ret	 0
_Fs_specify ENDP
; Function compile flags: /Odtp
_i$ = -4						; size = 4
_type$ = 8						; size = 4
_Fs_get_driver PROC

; 152  : {

  01220	55		 push	 ebp
  01221	8b ec		 mov	 ebp, esp
  01223	51		 push	 ecx

; 153  :     int             i = 0;

  01224	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 154  : 
; 155  :     for( i = 0 ; i < FS_DRV_MAX ; i++)

  0122b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01232	eb 09		 jmp	 SHORT $LN4@Fs_get_dri
$LN3@Fs_get_dri:
  01234	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  01237	83 c0 01	 add	 eax, 1
  0123a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Fs_get_dri:
  0123d	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  01241	7d 20		 jge	 SHORT $LN2@Fs_get_dri

; 156  :         if( type == fs_drv_pool[i].fs_type )

  01243	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  01246	6b c9 14	 imul	 ecx, 20			; 00000014H
  01249	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0124c	3b 91 00 00 00
	00		 cmp	 edx, DWORD PTR _fs_drv_pool[ecx]
  01252	75 0d		 jne	 SHORT $LN1@Fs_get_dri

; 157  :             return fs_drv_pool + i;

  01254	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  01257	6b c0 14	 imul	 eax, 20			; 00000014H
  0125a	05 00 00 00 00	 add	 eax, OFFSET _fs_drv_pool
  0125f	eb 04		 jmp	 SHORT $LN5@Fs_get_dri
$LN1@Fs_get_dri:

; 158  :     
; 159  :     return NULL;

  01261	eb d1		 jmp	 SHORT $LN3@Fs_get_dri
$LN2@Fs_get_dri:
  01263	33 c0		 xor	 eax, eax
$LN5@Fs_get_dri:

; 160  : }

  01265	8b e5		 mov	 esp, ebp
  01267	5d		 pop	 ebp
  01268	c3		 ret	 0
_Fs_get_driver ENDP
_TEXT	ENDS
END
