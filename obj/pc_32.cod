; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\asm\pc_32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_Irq_clock
EXTRN	_Syscall_exit:PROC
EXTRN	_machine_ivt:BYTE
EXTRN	_Machine_interrupt_mis:PROC
EXTRN	_Io_outb:PROC
EXTRN	_interrupt_nest:BYTE
EXTRN	_ticks:DWORD
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\asm\pc_32.c
;	COMDAT _Irq_clock
_TEXT	SEGMENT
_Irq_clock PROC						; COMDAT

; 51   :     I386_ISP_ENTER();

  00000	60		 pushad
  00001	1e		 push	 ds
  00002	06		 push	 es
  00003	0f a0		 push	 fs
  00005	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0000a	66 8e d8	 mov	 ds, ax
  0000d	66 8e c0	 mov	 es, ax
  00010	66 8e e0	 mov	 fs, ax

; 52   :     ++ticks;

  00013	bb 01 00 00 00	 mov	 ebx, 1
  00018	01 1d 00 00 00
	00		 add	 DWORD PTR _ticks, ebx

; 53   :     ++interrupt_nest;                   /*  增加中断嵌套计数        */

  0001e	00 1d 00 00 00
	00		 add	 BYTE PTR _interrupt_nest, bl

; 54   :     Io_outb((void *)0x20,0x20);         /*  重新开放主8259A         */

  00024	6a 20		 push	 32			; 00000020H
  00026	6a 20		 push	 32			; 00000020H
  00028	e8 00 00 00 00	 call	 _Io_outb
  0002d	83 c4 08	 add	 esp, 8

; 55   :     if( interrupt_nest >= IRQ_NEST_MAX) /*  中断嵌套超过196则丢弃   */

  00030	80 3d 00 00 00
	00 c4		 cmp	 BYTE PTR _interrupt_nest, 196 ; 000000c4H
  00037	72 07		 jb	 SHORT $LN5@Irq_clock

; 56   :         Machine_interrupt_mis();        /*  这个中断                */

  00039	e8 00 00 00 00	 call	 _Machine_interrupt_mis

; 57   :     else

  0003e	eb 0d		 jmp	 SHORT $LN4@Irq_clock
$LN5@Irq_clock:

; 58   :         machine_ivt[0](0,0);            /*  处理中断                */

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR _machine_ivt
  0004a	83 c4 08	 add	 esp, 8
$LN4@Irq_clock:

; 59   :     --interrupt_nest;                   /*  递减中断嵌套计数        */

  0004d	80 05 00 00 00
	00 ff		 add	 BYTE PTR _interrupt_nest, 255 ; 000000ffH

; 60   :     Syscall_exit(SCEXIT_TYPE_IRQ,1);    /*  中断退出前都要调用      */

  00054	53		 push	 ebx
  00055	53		 push	 ebx
  00056	e8 00 00 00 00	 call	 _Syscall_exit
  0005b	83 c4 08	 add	 esp, 8

; 61   :     I386_ISP_LEAVE();

  0005e	0f a1		 pop	 fs
  00060	07		 pop	 es
  00061	1f		 pop	 ds
  00062	61		 popad
  00063	cf		 iretd
_Irq_clock ENDP
_TEXT	ENDS
EXTRN	_e0e1:DWORD
EXTRN	_Io_inb:PROC
; Function compile flags: /Ogtpy
;	COMDAT __Irq_keyboard
_TEXT	SEGMENT
__Irq_keyboard PROC					; COMDAT

; 83   : {

  00000	53		 push	 ebx

; 84   :     byte_t                  sc = 0;     /*  系统扫描码,scan code    */
; 85   :     
; 86   :     sc = Io_inb((void*)0x60);

  00001	6a 60		 push	 96			; 00000060H
  00003	e8 00 00 00 00	 call	 _Io_inb

; 87   :     Io_outb((void *)0x20,0x20);         /*  重新开放主8259A         */

  00008	6a 20		 push	 32			; 00000020H
  0000a	6a 20		 push	 32			; 00000020H
  0000c	8a d8		 mov	 bl, al
  0000e	e8 00 00 00 00	 call	 _Io_outb
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   :     if( interrupt_nest >= IRQ_NEST_MAX )

  00016	80 3d 00 00 00
	00 c4		 cmp	 BYTE PTR _interrupt_nest, 196 ; 000000c4H
  0001d	72 06		 jb	 SHORT $LN6@Irq_keyboa
  0001f	5b		 pop	 ebx

; 89   :     {
; 90   :         Machine_interrupt_mis();

  00020	e9 00 00 00 00	 jmp	 _Machine_interrupt_mis
$LN6@Irq_keyboa:

; 91   :         return ;
; 92   :     }
; 93   :     switch(sc)

  00025	0f b6 cb	 movzx	 ecx, bl
  00028	8b c1		 mov	 eax, ecx
  0002a	2d e0 00 00 00	 sub	 eax, 224		; 000000e0H
  0002f	74 1c		 je	 SHORT $LN3@Irq_keyboa
  00031	83 e8 01	 sub	 eax, 1
  00034	74 0e		 je	 SHORT $LN2@Irq_keyboa

; 97   :     default:    machine_ivt[1](0,sc);

  00036	51		 push	 ecx
  00037	6a 00		 push	 0
  00039	ff 15 04 00 00
	00		 call	 DWORD PTR _machine_ivt+4
  0003f	83 c4 08	 add	 esp, 8
  00042	5b		 pop	 ebx

; 98   :     }
; 99   : }

  00043	c3		 ret	 0
$LN2@Irq_keyboa:

; 96   :     case 0xE1:  e0e1 |= 2;  break;

  00044	83 0d 00 00 00
	00 02		 or	 DWORD PTR _e0e1, 2
  0004b	5b		 pop	 ebx

; 98   :     }
; 99   : }

  0004c	c3		 ret	 0
$LN3@Irq_keyboa:

; 94   :     {
; 95   :     case 0xE0:  e0e1 |= 1;  break;

  0004d	83 0d 00 00 00
	00 01		 or	 DWORD PTR _e0e1, 1
  00054	5b		 pop	 ebx

; 98   :     }
; 99   : }

  00055	c3		 ret	 0
__Irq_keyboard ENDP
_TEXT	ENDS
PUBLIC	_Irq_keyboard
; Function compile flags: /Ogtpy
;	COMDAT _Irq_keyboard
_TEXT	SEGMENT
_Irq_keyboard PROC					; COMDAT

; 118  :     I386_ISP_ENTER();

  00000	60		 pushad
  00001	1e		 push	 ds
  00002	06		 push	 es
  00003	0f a0		 push	 fs
  00005	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  0000a	66 8e d8	 mov	 ds, ax
  0000d	66 8e c0	 mov	 es, ax
  00010	66 8e e0	 mov	 fs, ax

; 119  :     ++interrupt_nest;                   /*  增加中断嵌套计数        */

  00013	80 05 00 00 00
	00 01		 add	 BYTE PTR _interrupt_nest, 1

; 120  :     _Irq_keyboard();

  0001a	e8 00 00 00 00	 call	 __Irq_keyboard

; 121  :     --interrupt_nest;                   /*  递减中断嵌套计数        */

  0001f	80 05 00 00 00
	00 ff		 add	 BYTE PTR _interrupt_nest, 255 ; 000000ffH

; 122  :     Syscall_exit(SCEXIT_TYPE_IRQ,0);    /*  中断退出前都要调用      */

  00026	6a 00		 push	 0
  00028	6a 01		 push	 1
  0002a	e8 00 00 00 00	 call	 _Syscall_exit
  0002f	83 c4 08	 add	 esp, 8

; 123  :     I386_ISP_LEAVE();

  00032	0f a1		 pop	 fs
  00034	07		 pop	 es
  00035	1f		 pop	 ds
  00036	61		 popad
  00037	cf		 iretd
_Irq_keyboard ENDP
_TEXT	ENDS
PUBLIC	_Irq_com1
; Function compile flags: /Ogtpy
;	COMDAT _Irq_com1
_TEXT	SEGMENT
_Irq_com1 PROC						; COMDAT

; 129  :     __asm iretd

  00000	cf		 iretd
_Irq_com1 ENDP
_TEXT	ENDS
END
