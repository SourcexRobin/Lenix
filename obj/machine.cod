; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\machine\machine.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_Handle_graydot
PUBLIC	_Handle_gray0
PUBLIC	_Handle_gray3
PUBLIC	_Handle_gray2
PUBLIC	_Handle_gray1
PUBLIC	_Handle_plus
PUBLIC	_Handle_gray6
PUBLIC	_Handle_gray5
PUBLIC	_Handle_gray4
PUBLIC	_Handle_minor
PUBLIC	_Handle_gray9
PUBLIC	_Handle_gray8
PUBLIC	_Handle_gray7
PUBLIC	_Handle_scrlck
PUBLIC	_Handle_numlock
PUBLIC	_Handle_caps_lock
PUBLIC	_Handle_left_alt
PUBLIC	_Handle_right_shift
PUBLIC	_Handle_left_shift
PUBLIC	_Handle_left_ctrl
PUBLIC	_HandleNormal
PUBLIC	_none
PUBLIC	_pc_com
PUBLIC	_kb_handle_tab
PUBLIC	_keyboard_status
_DATA	SEGMENT
COMM	_machine_ivt:DWORD:010H
COMM	_interrupt_nest:BYTE
COMM	_e0e1:DWORD
COMM	_gray:DWORD
COMM	_machine_imr:WORD
COMM	_keyboard_do_irq:DWORD
COMM	_led:BYTE
COMM	_physical_memory:DWORD
_DATA	ENDS
_BSS	SEGMENT
_con_pos DD	01H DUP (?)
?cnt@?1??Proc_sched_msg@@9@9 DD 01H DUP (?)		; `Proc_sched_msg'::`2'::cnt
_BSS	ENDS
CONST	SEGMENT
_kb_handle_tab DD FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_Handle_left_ctrl
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_Handle_left_shift
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_Handle_right_shift
	DD	FLAT:_HandleNormal
	DD	FLAT:_Handle_left_alt
	DD	FLAT:_HandleNormal
	DD	FLAT:_Handle_caps_lock
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_none
	DD	FLAT:_HandleNormal
	DD	FLAT:_HandleNormal
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_Handle_numlock
	DD	FLAT:_Handle_scrlck
	DD	FLAT:_Handle_gray7
	DD	FLAT:_Handle_gray8
	DD	FLAT:_Handle_gray9
	DD	FLAT:_Handle_minor
	DD	FLAT:_Handle_gray4
	DD	FLAT:_Handle_gray5
	DD	FLAT:_Handle_gray6
	DD	FLAT:_Handle_plus
	DD	FLAT:_Handle_gray1
	DD	FLAT:_Handle_gray2
	DD	FLAT:_Handle_gray3
	DD	FLAT:_Handle_gray0
	DD	FLAT:_Handle_graydot
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
	DD	FLAT:_none
_ascii_tab DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	08H
	DB	09H
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	00H
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03bH
	DB	027H
	DB	060H
	DB	00H
	DB	05cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	0ffH
	DB	02aH
	DB	0ffH
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_ascii_tabs DB	00H
	DB	01bH
	DB	021H
	DB	040H
	DB	023H
	DB	024H
	DB	025H
	DB	05eH
	DB	026H
	DB	02aH
	DB	028H
	DB	029H
	DB	05fH
	DB	02bH
	DB	08H
	DB	09H
	DB	051H
	DB	057H
	DB	045H
	DB	052H
	DB	054H
	DB	059H
	DB	055H
	DB	049H
	DB	04fH
	DB	050H
	DB	07bH
	DB	07dH
	DB	0dH
	DB	0ffH
	DB	041H
	DB	053H
	DB	044H
	DB	046H
	DB	047H
	DB	048H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	03aH
	DB	022H
	DB	07eH
	DB	0ffH
	DB	07cH
	DB	05aH
	DB	058H
	DB	043H
	DB	056H
	DB	042H
	DB	04eH
	DB	04dH
	DB	03cH
	DB	02eH
	DB	03fH
	DB	0ffH
	DB	02aH
	DB	0ffH
	DB	020H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
_pc_com	DD	03f8H
	DD	02f8H
	DD	03e8H
	DD	03f8H
_con_attr DW	0700H
	ORG $+2
_con_x_scale DD	050H
_con_y_scale DD	019H
_keyboard_status DD 0ffffffffH
_DATA	ENDS
PUBLIC	_Machine_physical_memory
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\machine.c
;	COMDAT _Machine_physical_memory
_TEXT	SEGMENT
_Machine_physical_memory PROC				; COMDAT

; 69   :     return physical_memory;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _physical_memory

; 70   : }

  00005	c3		 ret	 0
_Machine_physical_memory ENDP
_TEXT	ENDS
PUBLIC	_Machine_isp_default
; Function compile flags: /Ogtpy
;	COMDAT _Machine_isp_default
_TEXT	SEGMENT
_nest$ = 8						; size = 4
_param$ = 12						; size = 4
_Machine_isp_default PROC				; COMDAT

; 74   :     nest  = nest;   /*  避免某些编译器发出变量未使用警告    */
; 75   :     param = param;
; 76   :     return 0;

  00000	33 c0		 xor	 eax, eax

; 77   : }

  00002	c3		 ret	 0
_Machine_isp_default ENDP
_TEXT	ENDS
PUBLIC	_Machine_interrupt_mis
_BSS	SEGMENT
_interrupt_mis_count DD 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Machine_interrupt_mis
_TEXT	SEGMENT
_Machine_interrupt_mis PROC				; COMDAT

; 82   :     ++interrupt_mis_count;

  00000	83 05 00 00 00
	00 01		 add	 DWORD PTR _interrupt_mis_count, 1

; 83   :     //ASSERT(interrupt_mis_count == 0);
; 84   : }

  00007	c3		 ret	 0
_Machine_interrupt_mis ENDP
_TEXT	ENDS
PUBLIC	_Machine_interrup_mis_get
; Function compile flags: /Ogtpy
;	COMDAT _Machine_interrup_mis_get
_TEXT	SEGMENT
_Machine_interrup_mis_get PROC				; COMDAT

; 88   :     return interrupt_mis_count;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _interrupt_mis_count

; 89   : }

  00005	c3		 ret	 0
_Machine_interrup_mis_get ENDP
_TEXT	ENDS
PUBLIC	_Machine_ivt_get
; Function compile flags: /Ogtpy
;	COMDAT _Machine_ivt_get
_TEXT	SEGMENT
_ivtid$ = 8						; size = 4
_Machine_ivt_get PROC					; COMDAT

; 169  :     return machine_ivt[ivtid & 0xF ];

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ivtid$[esp-4]
  00004	83 e0 0f	 and	 eax, 15			; 0000000fH
  00007	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR _machine_ivt[eax*4]

; 170  : }

  0000e	c3		 ret	 0
_Machine_ivt_get ENDP
_TEXT	ENDS
PUBLIC	_Machine_clock_frequency_get
_BSS	SEGMENT
_clk_frequency DW 01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Machine_clock_frequency_get
_TEXT	SEGMENT
_Machine_clock_frequency_get PROC			; COMDAT

; 225  :     return clk_frequency;

  00000	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _clk_frequency

; 226  : }

  00006	c3		 ret	 0
_Machine_clock_frequency_get ENDP
_TEXT	ENDS
PUBLIC	_Millisecond_to_ticks
; Function compile flags: /Ogtpy
;	COMDAT _Millisecond_to_ticks
_TEXT	SEGMENT
_millisecond$ = 8					; size = 4
_Millisecond_to_ticks PROC				; COMDAT

; 231  :     return (uint32_t)(MILIONSECOND_TO_TICKS(millisecond));

  00000	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR _clk_frequency
  00007	0f af 4c 24 04	 imul	 ecx, DWORD PTR _millisecond$[esp-4]
  0000c	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00011	f7 e1		 mul	 ecx
  00013	c1 ea 06	 shr	 edx, 6
  00016	8b c2		 mov	 eax, edx

; 232  : }

  00018	c3		 ret	 0
_Millisecond_to_ticks ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Pc_pic_mask_convert
_TEXT	SEGMENT
_Pc_pic_mask_convert PROC				; COMDAT
; _mask$ = eax

; 315  :     return mask;
; 316  : }

  00000	c3		 ret	 0
_Pc_pic_mask_convert ENDP
_TEXT	ENDS
PUBLIC	_Machine_imr_get
EXTRN	_Io_inb:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Machine_imr_get
_TEXT	SEGMENT
_Machine_imr_get PROC					; COMDAT

; 319  : {

  00000	56		 push	 esi

; 320  :     return Io_inb((void *)0xA1) * 0x100 + Io_inb((void *)0x21);

  00001	68 a1 00 00 00	 push	 161			; 000000a1H
  00006	e8 00 00 00 00	 call	 _Io_inb
  0000b	0f b6 f0	 movzx	 esi, al
  0000e	6a 21		 push	 33			; 00000021H
  00010	c1 e6 08	 shl	 esi, 8
  00013	e8 00 00 00 00	 call	 _Io_inb
  00018	0f b6 c0	 movzx	 eax, al
  0001b	83 c4 08	 add	 esp, 8
  0001e	03 c6		 add	 eax, esi
  00020	5e		 pop	 esi

; 321  : }

  00021	c3		 ret	 0
_Machine_imr_get ENDP
_TEXT	ENDS
PUBLIC	_Machine_imr_set
EXTRN	_Io_outb:PROC
EXTRN	_Cpu_hlt:PROC
EXTRN	_Cpu_tas_i:PROC
_BSS	SEGMENT
	ALIGN	4

_pic_lock DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Machine_imr_set
_TEXT	SEGMENT
_imr$ = 8						; size = 2
_Machine_imr_set PROC					; COMDAT

; 349  :     imr_t                   oimr    = 0; //  old mask
; 350  : 
; 351  :     /*
; 352  :      *  这里应该是原子操作，不能被打断。
; 353  :      *  但是，这个函数会在进程初始化之前调用，因此这里实现原子操作的方式有点特殊。
; 354  :      *  只能使用tas机制
; 355  :      */
; 356  :     while(Cpu_tas(&pic_lock,0,1)) 

  00000	6a 01		 push	 1
  00002	6a 00		 push	 0
  00004	68 00 00 00 00	 push	 OFFSET _pic_lock
  00009	e8 00 00 00 00	 call	 _Cpu_tas_i
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	85 c0		 test	 eax, eax
  00013	74 1a		 je	 SHORT $LN1@Machine_im
$LL2@Machine_im:

; 357  :         Cpu_hlt();

  00015	e8 00 00 00 00	 call	 _Cpu_hlt
  0001a	6a 01		 push	 1
  0001c	6a 00		 push	 0
  0001e	68 00 00 00 00	 push	 OFFSET _pic_lock
  00023	e8 00 00 00 00	 call	 _Cpu_tas_i
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	85 c0		 test	 eax, eax
  0002d	75 e6		 jne	 SHORT $LL2@Machine_im
$LN1@Machine_im:
  0002f	56		 push	 esi

; 358  : 
; 359  :     oimr    = Io_inb((void *)0xA1) * 0x100 + Io_inb((void *)0x21);

  00030	68 a1 00 00 00	 push	 161			; 000000a1H
  00035	e8 00 00 00 00	 call	 _Io_inb
  0003a	66 0f b6 f0	 movzx	 si, al
  0003e	6a 21		 push	 33			; 00000021H
  00040	66 c1 e6 08	 shl	 si, 8
  00044	e8 00 00 00 00	 call	 _Io_inb

; 360  : 
; 361  :     imr     = Pc_pic_mask_convert(imr);
; 362  : 
; 363  :     Io_outb((void *)0x21,(byte_t)( imr       & 0xFF));

  00049	8b 4c 24 10	 mov	 ecx, DWORD PTR _imr$[esp+8]
  0004d	66 0f b6 c0	 movzx	 ax, al
  00051	51		 push	 ecx
  00052	66 03 c6	 add	 ax, si
  00055	6a 21		 push	 33			; 00000021H
  00057	0f b7 f0	 movzx	 esi, ax
  0005a	e8 00 00 00 00	 call	 _Io_outb

; 364  :     Io_outb((void *)0xA1,(byte_t)((imr >> 8) & 0xFF));

  0005f	8b 54 24 19	 mov	 edx, DWORD PTR _imr$[esp+17]
  00063	52		 push	 edx
  00064	68 a1 00 00 00	 push	 161			; 000000a1H
  00069	e8 00 00 00 00	 call	 _Io_outb
  0006e	83 c4 18	 add	 esp, 24			; 00000018H

; 365  : 
; 366  :     pic_lock = 0;
; 367  : 
; 368  :     return oimr;

  00071	66 8b c6	 mov	 ax, si
  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _pic_lock, 0
  0007e	5e		 pop	 esi

; 369  : }

  0007f	c3		 ret	 0
_Machine_imr_set ENDP
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\pc.c
_TEXT	ENDS
;	COMDAT _Pc_read_cmos
_TEXT	SEGMENT
_Pc_read_cmos PROC					; COMDAT
; _reg$ = eax

; 42   :     Io_outb((void *)0x70,reg);

  00000	50		 push	 eax
  00001	6a 70		 push	 112			; 00000070H
  00003	e8 00 00 00 00	 call	 _Io_outb

; 43   :     return Io_inb((void *)0x71);

  00008	6a 71		 push	 113			; 00000071H
  0000a	e8 00 00 00 00	 call	 _Io_inb
  0000f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : }

  00012	c3		 ret	 0
_Pc_read_cmos ENDP
_TEXT	ENDS
PUBLIC	_Pc_clock_frequency
; Function compile flags: /Ogtpy
;	COMDAT _Pc_clock_frequency
_TEXT	SEGMENT
_frequency$ = 8						; size = 2
_Pc_clock_frequency PROC				; COMDAT

; 48   : #define CLK0_INPUT_FREQUENCY 1193200
; 49   :     frequency = CLK0_INPUT_FREQUENCY / frequency ;

  00000	0f b7 4c 24 04	 movzx	 ecx, WORD PTR _frequency$[esp-4]
  00005	b8 f0 34 12 00	 mov	 eax, 1193200		; 001234f0H
  0000a	99		 cdq
  0000b	f7 f9		 idiv	 ecx
  0000d	56		 push	 esi

; 50   : 
; 51   :     Io_outb((void *)0x43,0x36);

  0000e	6a 36		 push	 54			; 00000036H
  00010	6a 43		 push	 67			; 00000043H
  00012	0f b7 f0	 movzx	 esi, ax
  00015	89 74 24 10	 mov	 DWORD PTR _frequency$[esp+8], esi
  00019	e8 00 00 00 00	 call	 _Io_outb

; 52   :     Io_outb((void *)0x40,(byte_t)( frequency    &0xff));

  0001e	56		 push	 esi
  0001f	6a 40		 push	 64			; 00000040H
  00021	e8 00 00 00 00	 call	 _Io_outb

; 53   :     Io_outb((void *)0x40,(byte_t)((frequency>>8)&0xff));

  00026	8b 54 24 19	 mov	 edx, DWORD PTR _frequency$[esp+17]
  0002a	52		 push	 edx
  0002b	6a 40		 push	 64			; 00000040H
  0002d	e8 00 00 00 00	 call	 _Io_outb
  00032	83 c4 18	 add	 esp, 24			; 00000018H
  00035	5e		 pop	 esi

; 54   : }

  00036	c3		 ret	 0
_Pc_clock_frequency ENDP
_TEXT	ENDS
PUBLIC	_Machine_clock_frequency_set_hook
; Function compile flags: /Ogtpy
;	COMDAT _Machine_clock_frequency_set_hook
_TEXT	SEGMENT
$T2750 = -8						; size = 2
_frequency$ = 8						; size = 2
_Machine_clock_frequency_set_hook PROC			; COMDAT

; 57   : {

  00000	83 ec 08	 sub	 esp, 8

; 58   :     Pc_clock_frequency(frequency);

  00003	0f b7 4c 24 0c	 movzx	 ecx, WORD PTR _frequency$[esp+4]
  00008	b8 f0 34 12 00	 mov	 eax, 1193200		; 001234f0H
  0000d	99		 cdq
  0000e	f7 f9		 idiv	 ecx
  00010	56		 push	 esi
  00011	6a 36		 push	 54			; 00000036H
  00013	6a 43		 push	 67			; 00000043H
  00015	0f b7 f0	 movzx	 esi, ax
  00018	89 74 24 0c	 mov	 DWORD PTR $T2750[esp+20], esi
  0001c	e8 00 00 00 00	 call	 _Io_outb
  00021	56		 push	 esi
  00022	6a 40		 push	 64			; 00000040H
  00024	e8 00 00 00 00	 call	 _Io_outb
  00029	8b 54 24 15	 mov	 edx, DWORD PTR $T2750[esp+29]
  0002d	52		 push	 edx
  0002e	6a 40		 push	 64			; 00000040H
  00030	e8 00 00 00 00	 call	 _Io_outb
  00035	83 c4 18	 add	 esp, 24			; 00000018H

; 59   : 
; 60   :     return 0;

  00038	66 33 c0	 xor	 ax, ax
  0003b	5e		 pop	 esi

; 61   : }

  0003c	83 c4 08	 add	 esp, 8
  0003f	c3		 ret	 0
_Machine_clock_frequency_set_hook ENDP
_TEXT	ENDS
PUBLIC	_Pc_physical_memory
; Function compile flags: /Ogtpy
;	COMDAT _Pc_physical_memory
_TEXT	SEGMENT
_Pc_physical_memory PROC				; COMDAT

; 64   : {

  00000	53		 push	 ebx

; 65   :     return (((uint32_t)Pc_read_cmos(0x36) * 0x100 + 
; 66   :              (uint32_t)Pc_read_cmos(0x35)) + 1)*K ;

  00001	6a 36		 push	 54			; 00000036H
  00003	6a 70		 push	 112			; 00000070H
  00005	e8 00 00 00 00	 call	 _Io_outb
  0000a	6a 71		 push	 113			; 00000071H
  0000c	e8 00 00 00 00	 call	 _Io_inb
  00011	6a 35		 push	 53			; 00000035H
  00013	6a 70		 push	 112			; 00000070H
  00015	8a d8		 mov	 bl, al
  00017	e8 00 00 00 00	 call	 _Io_outb
  0001c	6a 71		 push	 113			; 00000071H
  0001e	e8 00 00 00 00	 call	 _Io_inb
  00023	0f b6 cb	 movzx	 ecx, bl
  00026	0f b6 c0	 movzx	 eax, al
  00029	c1 e1 08	 shl	 ecx, 8
  0002c	83 c4 18	 add	 esp, 24			; 00000018H
  0002f	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]
  00033	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00036	5b		 pop	 ebx

; 67   : }

  00037	c3		 ret	 0
_Pc_physical_memory ENDP
_TEXT	ENDS
PUBLIC	_Machine_time_get
EXTRN	_Bcd_to_bin:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Machine_time_get
_TEXT	SEGMENT
$T2789 = 8						; size = 1
$T2782 = 8						; size = 1
$T2775 = 8						; size = 1
$T2768 = 8						; size = 1
_time$ = 8						; size = 4
_Machine_time_get PROC					; COMDAT

; 70   : {

  00000	56		 push	 esi

; 71   :     if( NULL == time )

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _time$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 07		 jne	 SHORT $LL17@Machine_ti

; 72   :         return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	5e		 pop	 esi

; 83   : }

  0000c	c3		 ret	 0
  0000d	8d 49 00	 npad	 3
$LL17@Machine_ti:

; 73   :     CMOS_WAIT_TIME();

  00010	6a 0a		 push	 10			; 0000000aH
  00012	6a 70		 push	 112			; 00000070H
  00014	e8 00 00 00 00	 call	 _Io_outb
  00019	6a 71		 push	 113			; 00000071H
  0001b	e8 00 00 00 00	 call	 _Io_inb
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	84 c0		 test	 al, al
  00025	78 e9		 js	 SHORT $LL17@Machine_ti

; 74   :     time->time_week     = Bcd_to_bin(Pc_read_cmos(6));

  00027	6a 06		 push	 6
  00029	6a 70		 push	 112			; 00000070H
  0002b	e8 00 00 00 00	 call	 _Io_outb
  00030	6a 71		 push	 113			; 00000071H
  00032	e8 00 00 00 00	 call	 _Io_inb
  00037	88 44 24 14	 mov	 BYTE PTR $T2768[esp+12], al
  0003b	8b 44 24 14	 mov	 eax, DWORD PTR $T2768[esp+12]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _Bcd_to_bin
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	88 46 03	 mov	 BYTE PTR [esi+3], al
  0004b	eb 03 8d 49 00	 npad	 5
$LL12@Machine_ti:

; 75   :     CMOS_WAIT_TIME();

  00050	6a 0a		 push	 10			; 0000000aH
  00052	6a 70		 push	 112			; 00000070H
  00054	e8 00 00 00 00	 call	 _Io_outb
  00059	6a 71		 push	 113			; 00000071H
  0005b	e8 00 00 00 00	 call	 _Io_inb
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	84 c0		 test	 al, al
  00065	78 e9		 js	 SHORT $LL12@Machine_ti

; 76   :     time->time_second   = Bcd_to_bin(Pc_read_cmos(0));

  00067	6a 00		 push	 0
  00069	6a 70		 push	 112			; 00000070H
  0006b	e8 00 00 00 00	 call	 _Io_outb
  00070	6a 71		 push	 113			; 00000071H
  00072	e8 00 00 00 00	 call	 _Io_inb
  00077	88 44 24 14	 mov	 BYTE PTR $T2775[esp+12], al
  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR $T2775[esp+12]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _Bcd_to_bin
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	88 46 02	 mov	 BYTE PTR [esi+2], al
  0008b	eb 03 8d 49 00	 npad	 5
$LL7@Machine_ti:

; 77   :     CMOS_WAIT_TIME();

  00090	6a 0a		 push	 10			; 0000000aH
  00092	6a 70		 push	 112			; 00000070H
  00094	e8 00 00 00 00	 call	 _Io_outb
  00099	6a 71		 push	 113			; 00000071H
  0009b	e8 00 00 00 00	 call	 _Io_inb
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	84 c0		 test	 al, al
  000a5	78 e9		 js	 SHORT $LL7@Machine_ti

; 78   :     time->time_minute   = Bcd_to_bin(Pc_read_cmos(2));

  000a7	6a 02		 push	 2
  000a9	6a 70		 push	 112			; 00000070H
  000ab	e8 00 00 00 00	 call	 _Io_outb
  000b0	6a 71		 push	 113			; 00000071H
  000b2	e8 00 00 00 00	 call	 _Io_inb
  000b7	88 44 24 14	 mov	 BYTE PTR $T2782[esp+12], al
  000bb	8b 54 24 14	 mov	 edx, DWORD PTR $T2782[esp+12]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _Bcd_to_bin
  000c5	83 c4 10	 add	 esp, 16			; 00000010H
  000c8	88 46 01	 mov	 BYTE PTR [esi+1], al
  000cb	eb 03 8d 49 00	 npad	 5
$LL2@Machine_ti:

; 79   :     CMOS_WAIT_TIME();

  000d0	6a 0a		 push	 10			; 0000000aH
  000d2	6a 70		 push	 112			; 00000070H
  000d4	e8 00 00 00 00	 call	 _Io_outb
  000d9	6a 71		 push	 113			; 00000071H
  000db	e8 00 00 00 00	 call	 _Io_inb
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e3	84 c0		 test	 al, al
  000e5	78 e9		 js	 SHORT $LL2@Machine_ti

; 80   :     time->time_hour     = Bcd_to_bin(Pc_read_cmos(4));

  000e7	6a 04		 push	 4
  000e9	6a 70		 push	 112			; 00000070H
  000eb	e8 00 00 00 00	 call	 _Io_outb
  000f0	6a 71		 push	 113			; 00000071H
  000f2	e8 00 00 00 00	 call	 _Io_inb
  000f7	88 44 24 14	 mov	 BYTE PTR $T2789[esp+12], al
  000fb	8b 44 24 14	 mov	 eax, DWORD PTR $T2789[esp+12]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _Bcd_to_bin
  00105	88 06		 mov	 BYTE PTR [esi], al
  00107	83 c4 10	 add	 esp, 16			; 00000010H

; 81   : 
; 82   :     return time;

  0010a	8b c6		 mov	 eax, esi
  0010c	5e		 pop	 esi

; 83   : }

  0010d	c3		 ret	 0
_Machine_time_get ENDP
_TEXT	ENDS
PUBLIC	_Machine_time_set
; Function compile flags: /Ogtpy
;	COMDAT _Machine_time_set
_TEXT	SEGMENT
_time$ = 8						; size = 4
_Machine_time_set PROC					; COMDAT

; 86   :     return RESULT_FAILED;

  00000	83 c8 ff	 or	 eax, -1

; 87   : }

  00003	c3		 ret	 0
_Machine_time_set ENDP
_TEXT	ENDS
PUBLIC	_Machine_date_get
; Function compile flags: /Ogtpy
;	COMDAT _Machine_date_get
_TEXT	SEGMENT
$T2818 = 8						; size = 1
$T2811 = 8						; size = 1
$T2804 = 8						; size = 1
_date$ = 8						; size = 4
_Machine_date_get PROC					; COMDAT

; 89   : {

  00000	56		 push	 esi

; 90   :     if( NULL == date )

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _date$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 07		 jne	 SHORT $LL12@Machine_da

; 91   :         return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	5e		 pop	 esi

; 100  : }

  0000c	c3		 ret	 0
  0000d	8d 49 00	 npad	 3
$LL12@Machine_da:

; 92   :     CMOS_WAIT_TIME();

  00010	6a 0a		 push	 10			; 0000000aH
  00012	6a 70		 push	 112			; 00000070H
  00014	e8 00 00 00 00	 call	 _Io_outb
  00019	6a 71		 push	 113			; 00000071H
  0001b	e8 00 00 00 00	 call	 _Io_inb
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	84 c0		 test	 al, al
  00025	78 e9		 js	 SHORT $LL12@Machine_da

; 93   :     date->date_day      = Bcd_to_bin(Pc_read_cmos(7));

  00027	6a 07		 push	 7
  00029	6a 70		 push	 112			; 00000070H
  0002b	e8 00 00 00 00	 call	 _Io_outb
  00030	6a 71		 push	 113			; 00000071H
  00032	e8 00 00 00 00	 call	 _Io_inb
  00037	88 44 24 14	 mov	 BYTE PTR $T2804[esp+12], al
  0003b	8b 44 24 14	 mov	 eax, DWORD PTR $T2804[esp+12]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _Bcd_to_bin
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	88 46 03	 mov	 BYTE PTR [esi+3], al
  0004b	eb 03 8d 49 00	 npad	 5
$LL7@Machine_da:

; 94   :     CMOS_WAIT_TIME();

  00050	6a 0a		 push	 10			; 0000000aH
  00052	6a 70		 push	 112			; 00000070H
  00054	e8 00 00 00 00	 call	 _Io_outb
  00059	6a 71		 push	 113			; 00000071H
  0005b	e8 00 00 00 00	 call	 _Io_inb
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	84 c0		 test	 al, al
  00065	78 e9		 js	 SHORT $LL7@Machine_da

; 95   :     date->date_month    = Bcd_to_bin(Pc_read_cmos(8));

  00067	6a 08		 push	 8
  00069	6a 70		 push	 112			; 00000070H
  0006b	e8 00 00 00 00	 call	 _Io_outb
  00070	6a 71		 push	 113			; 00000071H
  00072	e8 00 00 00 00	 call	 _Io_inb
  00077	88 44 24 14	 mov	 BYTE PTR $T2811[esp+12], al
  0007b	8b 4c 24 14	 mov	 ecx, DWORD PTR $T2811[esp+12]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 _Bcd_to_bin
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	88 46 02	 mov	 BYTE PTR [esi+2], al
  0008b	eb 03 8d 49 00	 npad	 5
$LL2@Machine_da:

; 96   :     CMOS_WAIT_TIME();

  00090	6a 0a		 push	 10			; 0000000aH
  00092	6a 70		 push	 112			; 00000070H
  00094	e8 00 00 00 00	 call	 _Io_outb
  00099	6a 71		 push	 113			; 00000071H
  0009b	e8 00 00 00 00	 call	 _Io_inb
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	84 c0		 test	 al, al
  000a5	78 e9		 js	 SHORT $LL2@Machine_da

; 97   :     date->date_year     = Bcd_to_bin(Pc_read_cmos(9)) + 2000;

  000a7	6a 09		 push	 9
  000a9	6a 70		 push	 112			; 00000070H
  000ab	e8 00 00 00 00	 call	 _Io_outb
  000b0	6a 71		 push	 113			; 00000071H
  000b2	e8 00 00 00 00	 call	 _Io_inb
  000b7	88 44 24 14	 mov	 BYTE PTR $T2818[esp+12], al
  000bb	8b 54 24 14	 mov	 edx, DWORD PTR $T2818[esp+12]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 _Bcd_to_bin
  000c5	66 0f b6 c0	 movzx	 ax, al
  000c9	66 05 d0 07	 add	 ax, 2000		; 000007d0H
  000cd	66 89 06	 mov	 WORD PTR [esi], ax
  000d0	83 c4 10	 add	 esp, 16			; 00000010H

; 98   : 
; 99   :     return date;

  000d3	8b c6		 mov	 eax, esi
  000d5	5e		 pop	 esi

; 100  : }

  000d6	c3		 ret	 0
_Machine_date_get ENDP
_TEXT	ENDS
PUBLIC	_Machine_date_set
; Function compile flags: /Ogtpy
;	COMDAT _Machine_date_set
_TEXT	SEGMENT
_date$ = 8						; size = 4
_Machine_date_set PROC					; COMDAT

; 103  :     return RESULT_FAILED;

  00000	83 c8 ff	 or	 eax, -1

; 104  : }

  00003	c3		 ret	 0
_Machine_date_set ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GMALNMBL@OK?$CB?6?$AA@			; `string'
PUBLIC	??_C@_0BG@BADFNDM@PC?5pic?5initial?4?4?4?5?5?5?5?$AA@ ; `string'
PUBLIC	_Pic_initial
EXTRN	_Io_delay:PROC
EXTRN	__printk:PROC
;	COMDAT ??_C@_04GMALNMBL@OK?$CB?6?$AA@
CONST	SEGMENT
??_C@_04GMALNMBL@OK?$CB?6?$AA@ DB 'OK!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BADFNDM@PC?5pic?5initial?4?4?4?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@BADFNDM@PC?5pic?5initial?4?4?4?5?5?5?5?$AA@ DB 'PC pic initial.'
	DB	'..    ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Pic_initial
_TEXT	SEGMENT
_Pic_initial PROC					; COMDAT

; 113  :     // 初始化主8259A
; 114  :     _printk("PC pic initial...    ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BADFNDM@PC?5pic?5initial?4?4?4?5?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 115  :     Io_outb((void *)0x20,0x11       );Io_delay();Io_delay();

  0000a	6a 11		 push	 17			; 00000011H
  0000c	6a 20		 push	 32			; 00000020H
  0000e	e8 00 00 00 00	 call	 _Io_outb
  00013	e8 00 00 00 00	 call	 _Io_delay
  00018	e8 00 00 00 00	 call	 _Io_delay

; 116  :     Io_outb((void *)0x21,IRQ_BASE   );Io_delay();Io_delay(); // 设置中断向量

  0001d	6a 20		 push	 32			; 00000020H
  0001f	6a 21		 push	 33			; 00000021H
  00021	e8 00 00 00 00	 call	 _Io_outb
  00026	e8 00 00 00 00	 call	 _Io_delay
  0002b	e8 00 00 00 00	 call	 _Io_delay

; 117  :     Io_outb((void *)0x21,0x04       );Io_delay();Io_delay();

  00030	6a 04		 push	 4
  00032	6a 21		 push	 33			; 00000021H
  00034	e8 00 00 00 00	 call	 _Io_outb
  00039	e8 00 00 00 00	 call	 _Io_delay
  0003e	e8 00 00 00 00	 call	 _Io_delay

; 118  :     Io_outb((void *)0x21,0x01       );Io_delay();Io_delay();    

  00043	6a 01		 push	 1
  00045	6a 21		 push	 33			; 00000021H
  00047	e8 00 00 00 00	 call	 _Io_outb
  0004c	e8 00 00 00 00	 call	 _Io_delay
  00051	e8 00 00 00 00	 call	 _Io_delay

; 119  : 
; 120  :     // 初始化从8259A    
; 121  :     Io_outb((void *)0xa0,0x11       );Io_delay();Io_delay();

  00056	6a 11		 push	 17			; 00000011H
  00058	68 a0 00 00 00	 push	 160			; 000000a0H
  0005d	e8 00 00 00 00	 call	 _Io_outb
  00062	e8 00 00 00 00	 call	 _Io_delay
  00067	e8 00 00 00 00	 call	 _Io_delay

; 122  :     Io_outb((void *)0xa1,IRQ_BASE+8 );Io_delay();Io_delay();

  0006c	6a 28		 push	 40			; 00000028H
  0006e	68 a1 00 00 00	 push	 161			; 000000a1H
  00073	e8 00 00 00 00	 call	 _Io_outb
  00078	e8 00 00 00 00	 call	 _Io_delay
  0007d	e8 00 00 00 00	 call	 _Io_delay

; 123  :     Io_outb((void *)0xa1,0x02       );Io_delay();Io_delay();

  00082	6a 02		 push	 2
  00084	68 a1 00 00 00	 push	 161			; 000000a1H
  00089	e8 00 00 00 00	 call	 _Io_outb
  0008e	e8 00 00 00 00	 call	 _Io_delay
  00093	e8 00 00 00 00	 call	 _Io_delay

; 124  :     Io_outb((void *)0xa1,0x01       );Io_delay();Io_delay();

  00098	6a 01		 push	 1
  0009a	68 a1 00 00 00	 push	 161			; 000000a1H
  0009f	e8 00 00 00 00	 call	 _Io_outb
  000a4	83 c4 44	 add	 esp, 68			; 00000044H
  000a7	e8 00 00 00 00	 call	 _Io_delay
  000ac	e8 00 00 00 00	 call	 _Io_delay

; 125  : 
; 126  :     Io_outb((void *)0x21,0xFB); // 屏蔽所有中断

  000b1	68 fb 00 00 00	 push	 251			; 000000fbH
  000b6	6a 21		 push	 33			; 00000021H
  000b8	e8 00 00 00 00	 call	 _Io_outb

; 127  :     Io_outb((void *)0xa1,0xFF); // 屏蔽所有中断    

  000bd	68 ff 00 00 00	 push	 255			; 000000ffH
  000c2	68 a1 00 00 00	 push	 161			; 000000a1H
  000c7	e8 00 00 00 00	 call	 _Io_outb

; 128  :     _printk("OK!\n");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  000d1	e8 00 00 00 00	 call	 __printk
  000d6	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : }

  000d9	c3		 ret	 0
_Pic_initial ENDP
_TEXT	ENDS
PUBLIC	_Pc_enable_clock
; Function compile flags: /Ogtpy
;	COMDAT _Pc_enable_clock
_TEXT	SEGMENT
_Pc_enable_clock PROC					; COMDAT

; 139  :     Io_outb((void *)0x21,(byte_t)(Io_inb((void *)0x21) & 0xFE));

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 e0 fe	 and	 eax, -2			; fffffffeH
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 140  : }

  00015	c3		 ret	 0
_Pc_enable_clock ENDP
_TEXT	ENDS
PUBLIC	_Pc_disable_clock
; Function compile flags: /Ogtpy
;	COMDAT _Pc_disable_clock
_TEXT	SEGMENT
_Pc_disable_clock PROC					; COMDAT

; 144  :     Io_outb((void *)0x21,(byte_t)(Io_inb((void *)0x21) | 0x01));

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 c8 01	 or	 eax, 1
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : }

  00015	c3		 ret	 0
_Pc_disable_clock ENDP
_TEXT	ENDS
PUBLIC	_Pc_enable_keyboard
; Function compile flags: /Ogtpy
;	COMDAT _Pc_enable_keyboard
_TEXT	SEGMENT
_Pc_enable_keyboard PROC				; COMDAT

; 149  :     Io_outb((void *)0x21,(byte_t)(Io_inb((void *)0x21) & 0xFD));

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 e0 fd	 and	 eax, -3			; fffffffdH
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 150  : }

  00015	c3		 ret	 0
_Pc_enable_keyboard ENDP
_TEXT	ENDS
PUBLIC	_Pc_disable_keyboard
; Function compile flags: /Ogtpy
;	COMDAT _Pc_disable_keyboard
_TEXT	SEGMENT
_Pc_disable_keyboard PROC				; COMDAT

; 154  :     Io_outb((void *)0x21,(byte_t)(Io_inb((void *)0x21) | 0x02));

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 c8 02	 or	 eax, 2
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : }

  00015	c3		 ret	 0
_Pc_disable_keyboard ENDP
_TEXT	ENDS
PUBLIC	_Pc_enable_com1
; Function compile flags: /Ogtpy
;	COMDAT _Pc_enable_com1
_TEXT	SEGMENT
_Pc_enable_com1 PROC					; COMDAT

; 162  :     Io_outb((void *)0x21,(byte_t)(Io_inb((void *)0x21) & 0xEF));

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 e0 ef	 and	 eax, -17		; ffffffefH
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : }

  00015	c3		 ret	 0
_Pc_enable_com1 ENDP
_TEXT	ENDS
PUBLIC	_Pc_disable_com1
; Function compile flags: /Ogtpy
;	COMDAT _Pc_disable_com1
_TEXT	SEGMENT
_Pc_disable_com1 PROC					; COMDAT

; 166  :     Io_outb((void *)0x21,(byte_t)(Io_inb((void *)0x21) | 0x10));

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 c8 10	 or	 eax, 16			; 00000010H
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : }

  00015	c3		 ret	 0
_Pc_disable_com1 ENDP
_TEXT	ENDS
PUBLIC	_Lenix_start_hook
; Function compile flags: /Ogtpy
;	COMDAT _Lenix_start_hook
_TEXT	SEGMENT
_Lenix_start_hook PROC					; COMDAT

; 206  :     Pc_enable_clock();

  00000	6a 21		 push	 33			; 00000021H
  00002	e8 00 00 00 00	 call	 _Io_inb
  00007	83 e0 fe	 and	 eax, -2			; fffffffeH
  0000a	50		 push	 eax
  0000b	6a 21		 push	 33			; 00000021H
  0000d	e8 00 00 00 00	 call	 _Io_outb

; 207  :     Pc_enable_keyboard();

  00012	6a 21		 push	 33			; 00000021H
  00014	e8 00 00 00 00	 call	 _Io_inb
  00019	83 e0 fd	 and	 eax, -3			; fffffffdH
  0001c	50		 push	 eax
  0001d	6a 21		 push	 33			; 00000021H
  0001f	e8 00 00 00 00	 call	 _Io_outb
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 208  :     //Pc_enable_com1();
; 209  : }

  00027	c3		 ret	 0
_Lenix_start_hook ENDP
_TEXT	ENDS
PUBLIC	_Rs_botrate
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\com.c
;	COMDAT _Rs_botrate
_TEXT	SEGMENT
_uart$ = 8						; size = 4
_rate$ = 12						; size = 4
_Rs_botrate PROC					; COMDAT

; 49   :     uart = uart;
; 50   :     rate = rate;
; 51   :     return 0;

  00000	33 c0		 xor	 eax, eax

; 52   : }

  00002	c3		 ret	 0
_Rs_botrate ENDP
_TEXT	ENDS
PUBLIC	_Pc_rdb_set
_BSS	SEGMENT
_rs_rdb	DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Pc_rdb_set
_TEXT	SEGMENT
_com$ = 8						; size = 4
_Pc_rdb_set PROC					; COMDAT

; 57   :     int ret = rs_rdb;
; 58   :     rs_rdb = com & 3;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _com$[esp-4]
  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR _rs_rdb
  00009	83 e1 03	 and	 ecx, 3
  0000c	89 0d 00 00 00
	00		 mov	 DWORD PTR _rs_rdb, ecx

; 59   :     return ret;
; 60   : }

  00012	c3		 ret	 0
_Pc_rdb_set ENDP
_TEXT	ENDS
PUBLIC	_Pc_com_setup
; Function compile flags: /Ogtpy
;	COMDAT _Pc_com_setup
_TEXT	SEGMENT
_com$ = 8						; size = 4
_bps$ = 12						; size = 4
_Pc_com_setup PROC					; COMDAT

; 63   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 64   :     uart_t uart = pc_com[com & 3];

  00004	8b 7c 24 14	 mov	 edi, DWORD PTR _com$[esp+12]
  00008	83 e7 03	 and	 edi, 3
  0000b	8b 1c bd 00 00
	00 00		 mov	 ebx, DWORD PTR _pc_com[edi*4]

; 65   : 
; 66   :     RS_DLAB_SET(uart);

  00012	8d 73 03	 lea	 esi, DWORD PTR [ebx+3]
  00015	56		 push	 esi
  00016	e8 00 00 00 00	 call	 _Io_inb
  0001b	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 _Io_outb

; 67   :     Io_outb(uart,(byte_t)bps);

  00027	8b 6c 24 24	 mov	 ebp, DWORD PTR _bps$[esp+24]
  0002b	55		 push	 ebp
  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 _Io_outb

; 68   :     Io_outb(UART_IRQ_ENABLE(uart),(byte_t)(bps>>8));

  00032	c1 fd 08	 sar	 ebp, 8
  00035	55		 push	 ebp
  00036	83 c3 01	 add	 ebx, 1
  00039	53		 push	 ebx
  0003a	e8 00 00 00 00	 call	 _Io_outb

; 69   :     RS_DLAB_RESET(uart);

  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 _Io_inb
  00045	25 7f ff ff ff	 and	 eax, -129		; ffffff7fH
  0004a	50		 push	 eax
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 _Io_outb
  00051	83 c4 28	 add	 esp, 40			; 00000028H

; 70   : 
; 71   :     return com & 3;

  00054	8b c7		 mov	 eax, edi
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5d		 pop	 ebp
  00059	5b		 pop	 ebx

; 72   : }

  0005a	c3		 ret	 0
_Pc_com_setup ENDP
_TEXT	ENDS
PUBLIC	_Pc_com_resv
; Function compile flags: /Ogtpy
;	COMDAT _Pc_com_resv
_TEXT	SEGMENT
_uart$ = 8						; size = 4
_com$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_Pc_com_resv PROC					; COMDAT

; 75   :     uart_t                  uart    = pc_com[com & 3];

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _com$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 76   :     byte_t              *   buf     = buffer;
; 77   :     size_t                  cnt     = 0;
; 78   :     int                     retry   = 0;
; 79   : 
; 80   :     while( cnt < size )

  00006	8b 6c 24 14	 mov	 ebp, DWORD PTR _size$[esp+4]
  0000a	83 e0 03	 and	 eax, 3
  0000d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _pc_com[eax*4]
  00014	33 db		 xor	 ebx, ebx
  00016	85 ed		 test	 ebp, ebp
  00018	57		 push	 edi
  00019	8b 7c 24 14	 mov	 edi, DWORD PTR _buffer$[esp+8]
  0001d	89 4c 24 10	 mov	 DWORD PTR _uart$[esp+8], ecx
  00021	76 5b		 jbe	 SHORT $LN16@Pc_com_res
  00023	56		 push	 esi
$LL5@Pc_com_res:

; 81   :     {
; 82   :         retry = 1000;
; 83   :         while( --retry && !RS_CAN_RESV(uart) )

  00024	be e7 03 00 00	 mov	 esi, 999		; 000003e7H
  00029	8d a4 24 00 00
	00 00		 npad	 7
$LL3@Pc_com_res:
  00030	8b 44 24 14	 mov	 eax, DWORD PTR _uart$[esp+12]
  00034	83 c0 05	 add	 eax, 5
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 _Io_inb
  0003d	83 c4 04	 add	 esp, 4
  00040	a8 01		 test	 al, 1
  00042	75 11		 jne	 SHORT $LN2@Pc_com_res

; 84   :             Io_delay();

  00044	e8 00 00 00 00	 call	 _Io_delay
  00049	83 ee 01	 sub	 esi, 1
  0004c	75 e2		 jne	 SHORT $LL3@Pc_com_res
  0004e	5e		 pop	 esi
  0004f	5f		 pop	 edi

; 89   :     }
; 90   : 
; 91   :     return size;

  00050	8b c5		 mov	 eax, ebp
  00052	5d		 pop	 ebp
  00053	5b		 pop	 ebx

; 92   : }

  00054	c3		 ret	 0
$LN2@Pc_com_res:

; 85   :         if( retry == 0 )

  00055	85 f6		 test	 esi, esi
  00057	74 1e		 je	 SHORT $LN15@Pc_com_res

; 86   :             break;
; 87   :         *buf++ = RS_RESV(uart);

  00059	8b 54 24 14	 mov	 edx, DWORD PTR _uart$[esp+12]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _Io_inb
  00063	88 07		 mov	 BYTE PTR [edi], al
  00065	83 c4 04	 add	 esp, 4
  00068	83 c7 01	 add	 edi, 1
  0006b	e8 00 00 00 00	 call	 _Io_delay

; 88   :         cnt++;

  00070	83 c3 01	 add	 ebx, 1
  00073	3b dd		 cmp	 ebx, ebp
  00075	72 ad		 jb	 SHORT $LL5@Pc_com_res
$LN15@Pc_com_res:
  00077	5e		 pop	 esi
  00078	5f		 pop	 edi

; 89   :     }
; 90   : 
; 91   :     return size;

  00079	8b c5		 mov	 eax, ebp
  0007b	5d		 pop	 ebp
  0007c	5b		 pop	 ebx

; 92   : }

  0007d	c3		 ret	 0
$LN16@Pc_com_res:
  0007e	5f		 pop	 edi

; 89   :     }
; 90   : 
; 91   :     return size;

  0007f	8b c5		 mov	 eax, ebp
  00081	5d		 pop	 ebp
  00082	5b		 pop	 ebx

; 92   : }

  00083	c3		 ret	 0
_Pc_com_resv ENDP
_TEXT	ENDS
PUBLIC	_Pc_com_send
; Function compile flags: /Ogtpy
;	COMDAT _Pc_com_send
_TEXT	SEGMENT
_uart$ = 8						; size = 4
_com$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_Pc_com_send PROC					; COMDAT

; 96   :     uart_t                  uart    = pc_com[com & 3];

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _com$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 97   :     const byte_t        *   buf     = buffer;

  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR _buffer$[esp+4]
  0000a	83 e0 03	 and	 eax, 3
  0000d	57		 push	 edi
  0000e	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR _pc_com[eax*4]

; 98   :     size_t                  cnt     = 0;

  00015	33 db		 xor	 ebx, ebx

; 99   :     int                     retry   = 1000;
; 100  : 
; 101  :     while( cnt < size )

  00017	39 5c 24 18	 cmp	 DWORD PTR _size$[esp+8], ebx
  0001b	89 7c 24 10	 mov	 DWORD PTR _uart$[esp+8], edi
  0001f	76 63		 jbe	 SHORT $LN19@Pc_com_sen
  00021	83 c7 05	 add	 edi, 5
  00024	56		 push	 esi
$LL7@Pc_com_sen:

; 102  :     {
; 103  :         retry = 1000;
; 104  :         /*  重复测试一定次数  */
; 105  :         while( --retry && !RS_CAN_SEND(uart) )

  00025	be e7 03 00 00	 mov	 esi, 999		; 000003e7H
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL5@Pc_com_sen:
  00030	57		 push	 edi
  00031	e8 00 00 00 00	 call	 _Io_inb
  00036	83 c4 04	 add	 esp, 4
  00039	a8 20		 test	 al, 32			; 00000020H
  0003b	75 11		 jne	 SHORT $LN4@Pc_com_sen

; 106  :             Io_delay();

  0003d	e8 00 00 00 00	 call	 _Io_delay
  00042	83 ee 01	 sub	 esi, 1
  00045	75 e9		 jne	 SHORT $LL5@Pc_com_sen
  00047	5e		 pop	 esi
  00048	5f		 pop	 edi
  00049	5d		 pop	 ebp

; 115  :     }
; 116  : 
; 117  :     return cnt;

  0004a	8b c3		 mov	 eax, ebx
  0004c	5b		 pop	 ebx

; 118  : }

  0004d	c3		 ret	 0
$LN4@Pc_com_sen:

; 107  :         /*  重试次数到达以后，终止发送  */
; 108  :         if( retry == 0 )

  0004e	85 f6		 test	 esi, esi
  00050	74 2b		 je	 SHORT $LN18@Pc_com_sen

; 109  :             break;
; 110  :         RS_SEND(uart,*buf++);

  00052	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  00056	8b 4c 24 14	 mov	 ecx, DWORD PTR _uart$[esp+12]
  0005a	50		 push	 eax
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _Io_outb
  00061	83 c4 08	 add	 esp, 8
  00064	83 c5 01	 add	 ebp, 1
$LL2@Pc_com_sen:

; 111  :         /*  等待数据发送完毕  */
; 112  :         while(!(RS_STATUS(uart) & UART_LS_SEND_SHIFT_EMPTY))

  00067	57		 push	 edi
  00068	e8 00 00 00 00	 call	 _Io_inb
  0006d	83 c4 04	 add	 esp, 4
  00070	a8 40		 test	 al, 64			; 00000040H
  00072	74 f3		 je	 SHORT $LL2@Pc_com_sen

; 113  :             ;
; 114  :         cnt++;

  00074	83 c3 01	 add	 ebx, 1
  00077	3b 5c 24 1c	 cmp	 ebx, DWORD PTR _size$[esp+12]
  0007b	72 a8		 jb	 SHORT $LL7@Pc_com_sen
$LN18@Pc_com_sen:
  0007d	5e		 pop	 esi
  0007e	5f		 pop	 edi
  0007f	5d		 pop	 ebp

; 115  :     }
; 116  : 
; 117  :     return cnt;

  00080	8b c3		 mov	 eax, ebx
  00082	5b		 pop	 ebx

; 118  : }

  00083	c3		 ret	 0
$LN19@Pc_com_sen:
  00084	5f		 pop	 edi
  00085	5d		 pop	 ebp

; 115  :     }
; 116  : 
; 117  :     return cnt;

  00086	8b c3		 mov	 eax, ebx
  00088	5b		 pop	 ebx

; 118  : }

  00089	c3		 ret	 0
_Pc_com_send ENDP
_TEXT	ENDS
PUBLIC	_Pc_tty_hook_rdb
; Function compile flags: /Ogtpy
;	COMDAT _Pc_tty_hook_rdb
_TEXT	SEGMENT
_c$ = 8							; size = 1
_Pc_tty_hook_rdb PROC					; COMDAT

; 122  :     if( rs_rdb ) Pc_com_send(rs_rdb,&c,1);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _rs_rdb
  00005	85 c0		 test	 eax, eax
  00007	74 10		 je	 SHORT $LN1@Pc_tty_hoo
  00009	6a 01		 push	 1
  0000b	8d 4c 24 08	 lea	 ecx, DWORD PTR _c$[esp]
  0000f	51		 push	 ecx
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _Pc_com_send
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Pc_tty_hoo:

; 123  : }

  00019	c3		 ret	 0
_Pc_tty_hook_rdb ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@ODLDDBCJ@com?5resive?5data?3?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@KAALOMMJ@com?5wakeup?5sender?6?$AA@	; `string'
PUBLIC	??_C@_0BG@BKLBHKMG@com1?5irq?5flags?3?5?$CF02X?6?$AA@ ; `string'
PUBLIC	_Com1_do_irq
EXTRN	__printf:PROC
;	COMDAT ??_C@_0BF@ODLDDBCJ@com?5resive?5data?3?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BF@ODLDDBCJ@com?5resive?5data?3?5?$CFX?6?$AA@ DB 'com resive data:'
	DB	' %X', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KAALOMMJ@com?5wakeup?5sender?6?$AA@
CONST	SEGMENT
??_C@_0BD@KAALOMMJ@com?5wakeup?5sender?6?$AA@ DB 'com wakeup sender', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKLBHKMG@com1?5irq?5flags?3?5?$CF02X?6?$AA@
CONST	SEGMENT
??_C@_0BG@BKLBHKMG@com1?5irq?5flags?3?5?$CF02X?6?$AA@ DB 'com1 irq flags:'
	DB	' %02X', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Com1_do_irq
_TEXT	SEGMENT
_data$ = 8						; size = 4
_flags$ = 12						; size = 4
_Com1_do_irq PROC					; COMDAT

; 129  : {

  00000	56		 push	 esi

; 130  :     //Tty_put_char(TTY_RDB,0);
; 131  : 
; 132  :     _printf("com1 irq flags: %02X\n",flags & 0xFF);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _flags$[esp]
  00005	8b c6		 mov	 eax, esi
  00007	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BKLBHKMG@com1?5irq?5flags?3?5?$CF02X?6?$AA@
  00012	e8 00 00 00 00	 call	 __printf

; 133  : 
; 134  :     switch( flags & 0xFE )

  00017	81 e6 fe 00 00
	00		 and	 esi, 254		; 000000feH
  0001d	83 c4 08	 add	 esp, 8
  00020	83 ee 01	 sub	 esi, 1
  00023	74 16		 je	 SHORT $LN2@Com1_do_ir
  00025	83 ee 01	 sub	 esi, 1
  00028	75 24		 jne	 SHORT $LN7@Com1_do_ir

; 138  :         break;
; 139  :     case UART_IE_SEND_REG_EMPTY:
; 140  :         _printf("com wakeup sender\n");

  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KAALOMMJ@com?5wakeup?5sender?6?$AA@
  0002f	e8 00 00 00 00	 call	 __printf
  00034	83 c4 04	 add	 esp, 4

; 141  :         break;
; 142  :     }
; 143  : 
; 144  :     return 0;

  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 145  : }

  0003a	c3		 ret	 0
$LN2@Com1_do_ir:

; 135  :     {
; 136  :     case UART_IE_RESV_RDY:
; 137  :         _printf("com resive data: %X\n",(byte_t)data);

  0003b	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR _data$[esp]
  00040	51		 push	 ecx
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@ODLDDBCJ@com?5resive?5data?3?5?$CFX?6?$AA@
  00046	e8 00 00 00 00	 call	 __printf
  0004b	83 c4 08	 add	 esp, 8
$LN7@Com1_do_ir:

; 141  :         break;
; 142  :     }
; 143  : 
; 144  :     return 0;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 145  : }

  00051	c3		 ret	 0
_Com1_do_irq ENDP
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\consol.c
_TEXT	ENDS
;	COMDAT _Con_read_reg
_TEXT	SEGMENT
_Con_read_reg PROC					; COMDAT
; _idx$ = eax

; 56   :     Io_outb(PC_CON_REG_IDX,(byte_t)idx);

  00000	50		 push	 eax
  00001	68 d4 03 00 00	 push	 980			; 000003d4H
  00006	e8 00 00 00 00	 call	 _Io_outb

; 57   :     return Io_inb(PC_CON_REG_DATA);

  0000b	68 d5 03 00 00	 push	 981			; 000003d5H
  00010	e8 00 00 00 00	 call	 _Io_inb
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 58   : 
; 59   : }

  00018	c3		 ret	 0
_Con_read_reg ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Con_write_reg
_TEXT	SEGMENT
_data$ = 8						; size = 1
_Con_write_reg PROC					; COMDAT
; _idx$ = eax

; 64   :     Io_outb(PC_CON_REG_IDX,(byte_t)idx);

  00000	50		 push	 eax
  00001	68 d4 03 00 00	 push	 980			; 000003d4H
  00006	e8 00 00 00 00	 call	 _Io_outb

; 65   :     Io_outb(PC_CON_REG_DATA,data);

  0000b	8b 4c 24 0c	 mov	 ecx, DWORD PTR _data$[esp+4]
  0000f	51		 push	 ecx
  00010	68 d5 03 00 00	 push	 981			; 000003d5H
  00015	e8 00 00 00 00	 call	 _Io_outb
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 66   : }

  0001d	c3		 ret	 0
_Con_write_reg ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Con_set_cursor
_TEXT	SEGMENT
_Con_set_cursor PROC					; COMDAT
; _pos$ = edi

; 101  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 102  :     int pcp;    /* 原光标位置.prev cursor position*/
; 103  : 
; 104  :     pcp = Con_read_reg(0x0E) * 0x100 + Con_read_reg(0x0F);

  00002	6a 0e		 push	 14			; 0000000eH
  00004	68 d4 03 00 00	 push	 980			; 000003d4H
  00009	e8 00 00 00 00	 call	 _Io_outb
  0000e	68 d5 03 00 00	 push	 981			; 000003d5H
  00013	e8 00 00 00 00	 call	 _Io_inb
  00018	6a 0f		 push	 15			; 0000000fH
  0001a	68 d4 03 00 00	 push	 980			; 000003d4H
  0001f	8a d8		 mov	 bl, al
  00021	e8 00 00 00 00	 call	 _Io_outb
  00026	68 d5 03 00 00	 push	 981			; 000003d5H
  0002b	e8 00 00 00 00	 call	 _Io_inb
  00030	0f b6 f0	 movzx	 esi, al
  00033	0f b6 c3	 movzx	 eax, bl
  00036	c1 e0 08	 shl	 eax, 8

; 105  : 
; 106  :     Con_write_reg(0xE,(byte_t)(((pos) >> 8)&0xFF));

  00039	6a 0e		 push	 14			; 0000000eH
  0003b	68 d4 03 00 00	 push	 980			; 000003d4H
  00040	03 f0		 add	 esi, eax
  00042	e8 00 00 00 00	 call	 _Io_outb
  00047	8b cf		 mov	 ecx, edi
  00049	c1 f9 08	 sar	 ecx, 8
  0004c	51		 push	 ecx
  0004d	68 d5 03 00 00	 push	 981			; 000003d5H
  00052	e8 00 00 00 00	 call	 _Io_outb

; 107  :     Con_write_reg(0xF,(byte_t)((pos)&0xFF));

  00057	6a 0f		 push	 15			; 0000000fH
  00059	68 d4 03 00 00	 push	 980			; 000003d4H
  0005e	e8 00 00 00 00	 call	 _Io_outb
  00063	57		 push	 edi
  00064	68 d5 03 00 00	 push	 981			; 000003d5H
  00069	e8 00 00 00 00	 call	 _Io_outb
  0006e	83 c4 38	 add	 esp, 56			; 00000038H

; 108  : 
; 109  :     return pcp;

  00071	8b c6		 mov	 eax, esi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx

; 110  : }

  00075	c3		 ret	 0
_Con_set_cursor ENDP
_TEXT	ENDS
PUBLIC	_Con_set_byte
; Function compile flags: /Ogtpy
;	COMDAT _Con_set_byte
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_dat$ = 12						; size = 1
_attr$ = 16						; size = 1
_Con_set_byte PROC					; COMDAT

; 133  :     VGA_TEXT_BUFFER[pos] = ( ((word_t)attr) << 8 ) | dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _pos$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	8a 64 24 0c	 mov	 ah, BYTE PTR _attr$[esp-4]
  0000a	8a 44 24 08	 mov	 al, BYTE PTR _dat$[esp-4]
  0000e	66 89 04 4d 00
	80 0b 00	 mov	 WORD PTR [ecx*2+753664], ax

; 134  : }

  00016	c3		 ret	 0
_Con_set_byte ENDP
_TEXT	ENDS
PUBLIC	_Con_get_byte
; Function compile flags: /Ogtpy
;	COMDAT _Con_get_byte
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_Con_get_byte PROC					; COMDAT

; 138  :     return (byte_t)(VGA_TEXT_BUFFER[pos]);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _pos$[esp-4]
  00004	8a 84 00 00 80
	0b 00		 mov	 al, BYTE PTR [eax+eax+753664]

; 139  : }

  0000b	c3		 ret	 0
_Con_get_byte ENDP
_TEXT	ENDS
PUBLIC	_Con_attr_set
; Function compile flags: /Ogtpy
;	COMDAT _Con_attr_set
_TEXT	SEGMENT
_attr$ = 8						; size = 1
_Con_attr_set PROC					; COMDAT

; 143  :     byte_t  pca; /*  原属性,prev consol attr*/
; 144  :     
; 145  :     pca = (byte_t)(con_attr >> 8);

  00000	a0 01 00 00 00	 mov	 al, BYTE PTR _con_attr+1

; 146  :     con_attr = attr << 8 ;

  00005	33 c9		 xor	 ecx, ecx
  00007	8a 6c 24 04	 mov	 ch, BYTE PTR _attr$[esp-4]
  0000b	66 89 0d 00 00
	00 00		 mov	 WORD PTR _con_attr, cx

; 147  :     return pca;
; 148  : }

  00012	c3		 ret	 0
_Con_attr_set ENDP
_TEXT	ENDS
PUBLIC	_Con_cls
; Function compile flags: /Ogtpy
;	COMDAT _Con_cls
_TEXT	SEGMENT
_Con_cls PROC						; COMDAT

; 154  :     int                     x       = 0;
; 155  :     word_t                  attr    = con_attr;
; 156  : 
; 157  :     while ( x < con_x_scale * con_y_scale )

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_y_scale
  00006	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _con_x_scale
  0000d	85 c9		 test	 ecx, ecx
  0000f	57		 push	 edi
  00010	7e 21		 jle	 SHORT $LN2@Con_cls
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_attr
  00017	83 c8 20	 or	 eax, 32			; 00000020H
  0001a	66 8b d0	 mov	 dx, ax
  0001d	bf 00 80 0b 00	 mov	 edi, 753664		; 000b8000H
  00022	c1 e2 10	 shl	 edx, 16			; 00000010H
  00025	66 8b d0	 mov	 dx, ax
  00028	d1 e9		 shr	 ecx, 1
  0002a	8b c2		 mov	 eax, edx
  0002c	f3 ab		 rep stosd
  0002e	13 c9		 adc	 ecx, ecx
  00030	66 f3 ab	 rep stosw
$LN2@Con_cls:

; 158  :          CON_SET_BYTE(x++,0x20,attr);
; 159  : 
; 160  :     con_pos = 0;
; 161  :     Con_set_cursor(con_pos);

  00033	33 ff		 xor	 edi, edi
  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _con_pos, 0
  0003f	e8 00 00 00 00	 call	 _Con_set_cursor
  00044	5f		 pop	 edi

; 162  : }

  00045	c3		 ret	 0
_Con_cls ENDP
_TEXT	ENDS
PUBLIC	_Con_corsur
; Function compile flags: /Ogtpy
;	COMDAT _Con_corsur
_TEXT	SEGMENT
_Con_corsur PROC					; COMDAT

; 168  : {

  00000	57		 push	 edi

; 169  :     Con_set_cursor(con_pos);

  00001	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _con_pos
  00007	e8 00 00 00 00	 call	 _Con_set_cursor
  0000c	5f		 pop	 edi

; 170  : }

  0000d	c3		 ret	 0
_Con_corsur ENDP
_TEXT	ENDS
PUBLIC	_Con_scroll_up
; Function compile flags: /Ogtpy
;	COMDAT _Con_scroll_up
_TEXT	SEGMENT
_lines$ = 8						; size = 4
_Con_scroll_up PROC					; COMDAT

; 177  :     word_t FAR          *   vbuf    = VGA_TEXT_BUFFER;
; 178  :     int                     src     = 0,
; 179  :                             des     = 0,
; 180  :                             ncopy   = 0;
; 181  :     word_t                  attr    = con_attr;
; 182  : 
; 183  :     if( lines < 1 )

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _lines$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	83 f9 01	 cmp	 ecx, 1
  00009	0f 8c 7e 00 00
	00		 jl	 $LN7@Con_scroll
  0000f	53		 push	 ebx
  00010	56		 push	 esi

; 184  :         return ;
; 185  : 
; 186  :     src     = con_x_scale * lines ;

  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _con_x_scale
  00017	8b de		 mov	 ebx, esi
  00019	0f af d9	 imul	 ebx, ecx

; 187  :     ncopy   = (25 - MIN(lines,25)) * con_x_scale ;

  0001c	83 f9 19	 cmp	 ecx, 25			; 00000019H
  0001f	57		 push	 edi
  00020	8b d1		 mov	 edx, ecx
  00022	7c 05		 jl	 SHORT $LN10@Con_scroll
  00024	ba 19 00 00 00	 mov	 edx, 25			; 00000019H
$LN10@Con_scroll:
  00029	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  0002e	2b ca		 sub	 ecx, edx
  00030	0f af ce	 imul	 ecx, esi

; 188  : 
; 189  :     for( ; des < ncopy ; des++)

  00033	85 c9		 test	 ecx, ecx
  00035	7e 1e		 jle	 SHORT $LN3@Con_scroll

; 187  :     ncopy   = (25 - MIN(lines,25)) * con_x_scale ;

  00037	8d 94 1b 00 80
	0b 00		 lea	 edx, DWORD PTR [ebx+ebx+753664]
  0003e	8b ff		 npad	 2
$LL5@Con_scroll:

; 190  :         vbuf[des] = vbuf[src + des];

  00040	66 8b 3a	 mov	 di, WORD PTR [edx]
  00043	66 89 3c 45 00
	80 0b 00	 mov	 WORD PTR [eax*2+753664], di
  0004b	83 c0 01	 add	 eax, 1
  0004e	83 c2 02	 add	 edx, 2
  00051	3b c1		 cmp	 eax, ecx
  00053	7c eb		 jl	 SHORT $LL5@Con_scroll
$LN3@Con_scroll:

; 191  :     
; 192  :     ncopy = con_x_scale * con_y_scale;

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_y_scale
  0005b	0f af ce	 imul	 ecx, esi

; 193  : 
; 194  :     while( des < ncopy )

  0005e	3b c1		 cmp	 eax, ecx
  00060	7d 22		 jge	 SHORT $LN2@Con_scroll
  00062	2b c8		 sub	 ecx, eax
  00064	8d bc 00 00 80
	0b 00		 lea	 edi, DWORD PTR [eax+eax+753664]
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_attr
  00070	66 8b d0	 mov	 dx, ax
  00073	c1 e2 10	 shl	 edx, 16			; 00000010H
  00076	66 8b d0	 mov	 dx, ax
  00079	d1 e9		 shr	 ecx, 1
  0007b	8b c2		 mov	 eax, edx
  0007d	f3 ab		 rep stosd
  0007f	13 c9		 adc	 ecx, ecx
  00081	66 f3 ab	 rep stosw
$LN2@Con_scroll:

; 195  :         vbuf[des++] = attr;  
; 196  : 
; 197  :     con_pos -= lines * con_x_scale;

  00084	29 1d 00 00 00
	00		 sub	 DWORD PTR _con_pos, ebx
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
$LN7@Con_scroll:

; 198  : }

  0008d	c3		 ret	 0
_Con_scroll_up ENDP
_TEXT	ENDS
PUBLIC	_Con_cr
; Function compile flags: /Ogtpy
;	COMDAT _Con_cr
_TEXT	SEGMENT
_Con_cr	PROC						; COMDAT

; 205  : }

  00000	c3		 ret	 0
_Con_cr	ENDP
_TEXT	ENDS
PUBLIC	_Con_nl
; Function compile flags: /Ogtpy
;	COMDAT _Con_nl
_TEXT	SEGMENT
_Con_nl	PROC						; COMDAT

; 210  : {

  00000	53		 push	 ebx

; 211  :     int                     pad     = 0;
; 212  :     word_t                  attr    = con_attr;
; 213  : 
; 214  :     pad = con_x_scale - con_pos % con_x_scale;

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _con_pos
  00007	8b c3		 mov	 eax, ebx
  00009	55		 push	 ebp
  0000a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _con_x_scale
  00010	99		 cdq
  00011	f7 fd		 idiv	 ebp

; 215  : 
; 216  :     CON_SET_BYTE(con_pos++,0x20,attr);

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_attr
  00018	56		 push	 esi
  00019	8b c8		 mov	 ecx, eax
  0001b	83 c9 20	 or	 ecx, 32			; 00000020H
  0001e	8b f5		 mov	 esi, ebp
  00020	66 89 0c 5d 00
	80 0b 00	 mov	 WORD PTR [ebx*2+753664], cx
  00028	83 c3 01	 add	 ebx, 1
  0002b	89 1d 00 00 00
	00		 mov	 DWORD PTR _con_pos, ebx
  00031	2b f2		 sub	 esi, edx

; 217  : 
; 218  :     while(--pad)

  00033	83 ee 01	 sub	 esi, 1
  00036	74 27		 je	 SHORT $LN3@Con_nl
  00038	66 8b d0	 mov	 dx, ax
  0003b	57		 push	 edi
  0003c	8b ce		 mov	 ecx, esi
  0003e	8d bc 1b 00 80
	0b 00		 lea	 edi, DWORD PTR [ebx+ebx+753664]
  00045	c1 e2 10	 shl	 edx, 16			; 00000010H
  00048	66 8b d0	 mov	 dx, ax
  0004b	d1 e9		 shr	 ecx, 1
  0004d	8b c2		 mov	 eax, edx
  0004f	f3 ab		 rep stosd
  00051	13 c9		 adc	 ecx, ecx
  00053	03 de		 add	 ebx, esi
  00055	66 f3 ab	 rep stosw
  00058	89 1d 00 00 00
	00		 mov	 DWORD PTR _con_pos, ebx
  0005e	5f		 pop	 edi
$LN3@Con_nl:

; 219  :          CON_SET_BYTE(con_pos++,0,attr);
; 220  : 
; 221  :     if( con_pos >= con_y_scale * con_x_scale )

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_y_scale
  00064	0f af c5	 imul	 eax, ebp
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp
  00069	3b d8		 cmp	 ebx, eax
  0006b	5b		 pop	 ebx
  0006c	7c 08		 jl	 SHORT $LN1@Con_nl

; 222  :         Con_scroll_up(1);

  0006e	6a 01		 push	 1
  00070	e8 00 00 00 00	 call	 _Con_scroll_up
  00075	59		 pop	 ecx
$LN1@Con_nl:

; 223  : }

  00076	c3		 ret	 0
_Con_nl	ENDP
_TEXT	ENDS
PUBLIC	_Con_tab
; Function compile flags: /Ogtpy
;	COMDAT _Con_tab
_TEXT	SEGMENT
_pad$ = -4						; size = 4
_Con_tab PROC						; COMDAT

; 228  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 229  :     int                     pad     = 0;
; 230  :     word_t                  attr    = con_attr;
; 231  : 
; 232  :     pad = 8 - con_pos % 8;

  00002	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _con_pos
  00008	8b c6		 mov	 eax, esi
  0000a	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0000f	57		 push	 edi
  00010	79 05		 jns	 SHORT $LN24@Con_tab
  00012	48		 dec	 eax
  00013	83 c8 f8	 or	 eax, -8			; fffffff8H
  00016	40		 inc	 eax
$LN24@Con_tab:

; 233  : 
; 234  :     Con_set_byte(con_pos++,0x20,(byte_t)attr);

  00017	33 c9		 xor	 ecx, ecx
  00019	8a 2d 00 00 00
	00		 mov	 ch, BYTE PTR _con_attr
  0001f	bf 08 00 00 00	 mov	 edi, 8
  00024	2b f8		 sub	 edi, eax
  00026	8b c6		 mov	 eax, esi
  00028	83 c6 01	 add	 esi, 1
  0002b	89 35 00 00 00
	00		 mov	 DWORD PTR _con_pos, esi
  00031	83 c9 20	 or	 ecx, 32			; 00000020H

; 235  : 
; 236  :     while(--pad)

  00034	83 ef 01	 sub	 edi, 1
  00037	66 89 0c 45 00
	80 0b 00	 mov	 WORD PTR [eax*2+753664], cx
  0003f	89 7c 24 08	 mov	 DWORD PTR _pad$[esp+12], edi
  00043	0f 84 9b 00 00
	00		 je	 $LN2@Con_tab
  00049	53		 push	 ebx
  0004a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _con_x_scale
  00050	55		 push	 ebp
  00051	8b eb		 mov	 ebp, ebx
  00053	0f af 2d 00 00
	00 00		 imul	 ebp, DWORD PTR _con_y_scale
  0005a	8d 9b 00 00 00
	00		 npad	 6
$LL3@Con_tab:

; 237  :     {
; 238  :         CON_SET_BYTE(con_pos++,0,attr);

  00060	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR _con_attr
  00067	66 89 14 75 00
	80 0b 00	 mov	 WORD PTR [esi*2+753664], dx
  0006f	83 c6 01	 add	 esi, 1

; 239  :         if( con_pos >= con_y_scale * con_x_scale )

  00072	3b f5		 cmp	 esi, ebp
  00074	7c 5d		 jl	 SHORT $LN14@Con_tab

; 240  :             Con_scroll_up(1);

  00076	8d 0c 5b	 lea	 ecx, DWORD PTR [ebx+ebx*2]
  00079	03 c9		 add	 ecx, ecx
  0007b	03 c9		 add	 ecx, ecx
  0007d	03 c9		 add	 ecx, ecx
  0007f	33 c0		 xor	 eax, eax
  00081	85 c9		 test	 ecx, ecx
  00083	7e 20		 jle	 SHORT $LN10@Con_tab
  00085	8d 94 1b 00 80
	0b 00		 lea	 edx, DWORD PTR [ebx+ebx+753664]
  0008c	8d 64 24 00	 npad	 4
$LL12@Con_tab:
  00090	66 8b 3a	 mov	 di, WORD PTR [edx]
  00093	66 89 3c 45 00
	80 0b 00	 mov	 WORD PTR [eax*2+753664], di
  0009b	83 c0 01	 add	 eax, 1
  0009e	83 c2 02	 add	 edx, 2
  000a1	3b c1		 cmp	 eax, ecx
  000a3	7c eb		 jl	 SHORT $LL12@Con_tab
$LN10@Con_tab:
  000a5	3b c5		 cmp	 eax, ebp
  000a7	7d 24		 jge	 SHORT $LN9@Con_tab
  000a9	8d bc 00 00 80
	0b 00		 lea	 edi, DWORD PTR [eax+eax+753664]
  000b0	8b cd		 mov	 ecx, ebp
  000b2	2b c8		 sub	 ecx, eax
  000b4	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_attr
  000b9	66 8b d0	 mov	 dx, ax
  000bc	c1 e2 10	 shl	 edx, 16			; 00000010H
  000bf	66 8b d0	 mov	 dx, ax
  000c2	d1 e9		 shr	 ecx, 1
  000c4	8b c2		 mov	 eax, edx
  000c6	f3 ab		 rep stosd
  000c8	13 c9		 adc	 ecx, ecx
  000ca	66 f3 ab	 rep stosw
$LN9@Con_tab:
  000cd	8b 7c 24 10	 mov	 edi, DWORD PTR _pad$[esp+20]
  000d1	2b f3		 sub	 esi, ebx
$LN14@Con_tab:
  000d3	83 ef 01	 sub	 edi, 1
  000d6	89 7c 24 10	 mov	 DWORD PTR _pad$[esp+20], edi
  000da	75 84		 jne	 SHORT $LL3@Con_tab
  000dc	5d		 pop	 ebp
  000dd	89 35 00 00 00
	00		 mov	 DWORD PTR _con_pos, esi
  000e3	5b		 pop	 ebx
$LN2@Con_tab:
  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi

; 241  :     }
; 242  : }

  000e6	59		 pop	 ecx
  000e7	c3		 ret	 0
_Con_tab ENDP
_TEXT	ENDS
PUBLIC	_Con_back
; Function compile flags: /Ogtpy
;	COMDAT _Con_back
_TEXT	SEGMENT
_Con_back PROC						; COMDAT

; 248  :     word_t                  attr = con_attr;
; 249  : 
; 250  :     if( con_pos <= 0 )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_pos
  00005	85 c0		 test	 eax, eax
  00007	7e 43		 jle	 SHORT $LN5@Con_back

; 251  :         return ;
; 252  : 
; 253  :     while( --con_pos)

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_attr
  0000f	83 e8 01	 sub	 eax, 1
  00012	a3 00 00 00 00	 mov	 DWORD PTR _con_pos, eax
  00017	74 28		 je	 SHORT $LN10@Con_back
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL3@Con_back:

; 254  :     {
; 255  :         if( Con_get_byte(con_pos) )     /*  规定遇到0，则要继续执行退格  */

  00020	80 bc 00 00 80
	0b 00 00	 cmp	 BYTE PTR [eax+eax+753664], 0
  00028	75 12		 jne	 SHORT $LN12@Con_back

; 256  :             break;
; 257  :          CON_SET_BYTE(con_pos,0x20,attr);

  0002a	8b d1		 mov	 edx, ecx
  0002c	83 ca 20	 or	 edx, 32			; 00000020H
  0002f	83 e8 01	 sub	 eax, 1
  00032	66 89 14 45 02
	80 0b 00	 mov	 WORD PTR [eax*2+753666], dx
  0003a	75 e4		 jne	 SHORT $LL3@Con_back
$LN12@Con_back:

; 251  :         return ;
; 252  : 
; 253  :     while( --con_pos)

  0003c	a3 00 00 00 00	 mov	 DWORD PTR _con_pos, eax
$LN10@Con_back:

; 258  :     }
; 259  : 
; 260  :     CON_SET_BYTE(con_pos,0x20,attr);

  00041	83 c9 20	 or	 ecx, 32			; 00000020H
  00044	66 89 0c 45 00
	80 0b 00	 mov	 WORD PTR [eax*2+753664], cx
$LN5@Con_back:

; 261  : }

  0004c	c3		 ret	 0
_Con_back ENDP
_TEXT	ENDS
PUBLIC	_Con_del
; Function compile flags: /Ogtpy
;	COMDAT _Con_del
_TEXT	SEGMENT
_Con_del PROC						; COMDAT

; 268  : }

  00000	c3		 ret	 0
_Con_del ENDP
_TEXT	ENDS
PUBLIC	_Con_write_char
; Function compile flags: /Ogtpy
;	COMDAT _Con_write_char
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_c$ = 12						; size = 1
_attr$ = 16						; size = 1
_Con_write_char PROC					; COMDAT

; 272  :     word_t                  ta = ((word_t)attr) << 8;
; 273  : 
; 274  :     switch(c)

  00000	8a 54 24 08	 mov	 dl, BYTE PTR _c$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	8a 64 24 0c	 mov	 ah, BYTE PTR _attr$[esp-4]
  0000a	0f b7 c8	 movzx	 ecx, ax
  0000d	0f b6 c2	 movzx	 eax, dl
  00010	83 c0 f8	 add	 eax, -8			; fffffff8H
  00013	83 f8 77	 cmp	 eax, 119		; 00000077H
  00016	77 0e		 ja	 SHORT $LN1@Con_write_
  00018	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN7@Con_write_[eax]
  0001f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN8@Con_write_[eax*4]
$LN1@Con_write_:

; 275  :     {
; 276  :     case CHAR_NL:
; 277  :     case CHAR_CR:
; 278  :     case CHAR_TAB:    
; 279  :     case CHAR_BACK:
; 280  :     case CHAR_DEL:
; 281  :         break;
; 282  :     default:
; 283  :         CON_SET_BYTE(pos,c,ta);

  00026	8b 44 24 04	 mov	 eax, DWORD PTR _pos$[esp-4]
  0002a	66 0f b6 d2	 movzx	 dx, dl
  0002e	66 0b d1	 or	 dx, cx
  00031	66 89 14 45 00
	80 0b 00	 mov	 WORD PTR [eax*2+753664], dx
$LN3@Con_write_:

; 284  :         break;
; 285  :     }
; 286  : }

  00039	c3		 ret	 0
  0003a	8b ff		 npad	 2
$LN8@Con_write_:
  0003c	00 00 00 00	 DD	 $LN3@Con_write_
  00040	00 00 00 00	 DD	 $LN1@Con_write_
$LN7@Con_write_:
  00044	00		 DB	 0
  00045	00		 DB	 0
  00046	00		 DB	 0
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	00		 DB	 0
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	01		 DB	 1
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	01		 DB	 1
  00050	01		 DB	 1
  00051	01		 DB	 1
  00052	01		 DB	 1
  00053	01		 DB	 1
  00054	01		 DB	 1
  00055	01		 DB	 1
  00056	01		 DB	 1
  00057	01		 DB	 1
  00058	01		 DB	 1
  00059	01		 DB	 1
  0005a	01		 DB	 1
  0005b	01		 DB	 1
  0005c	01		 DB	 1
  0005d	01		 DB	 1
  0005e	01		 DB	 1
  0005f	01		 DB	 1
  00060	01		 DB	 1
  00061	01		 DB	 1
  00062	01		 DB	 1
  00063	01		 DB	 1
  00064	01		 DB	 1
  00065	01		 DB	 1
  00066	01		 DB	 1
  00067	01		 DB	 1
  00068	01		 DB	 1
  00069	01		 DB	 1
  0006a	01		 DB	 1
  0006b	01		 DB	 1
  0006c	01		 DB	 1
  0006d	01		 DB	 1
  0006e	01		 DB	 1
  0006f	01		 DB	 1
  00070	01		 DB	 1
  00071	01		 DB	 1
  00072	01		 DB	 1
  00073	01		 DB	 1
  00074	01		 DB	 1
  00075	01		 DB	 1
  00076	01		 DB	 1
  00077	01		 DB	 1
  00078	01		 DB	 1
  00079	01		 DB	 1
  0007a	01		 DB	 1
  0007b	01		 DB	 1
  0007c	01		 DB	 1
  0007d	01		 DB	 1
  0007e	01		 DB	 1
  0007f	01		 DB	 1
  00080	01		 DB	 1
  00081	01		 DB	 1
  00082	01		 DB	 1
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	01		 DB	 1
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	01		 DB	 1
  00090	01		 DB	 1
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	01		 DB	 1
  00098	01		 DB	 1
  00099	01		 DB	 1
  0009a	01		 DB	 1
  0009b	01		 DB	 1
  0009c	01		 DB	 1
  0009d	01		 DB	 1
  0009e	01		 DB	 1
  0009f	01		 DB	 1
  000a0	01		 DB	 1
  000a1	01		 DB	 1
  000a2	01		 DB	 1
  000a3	01		 DB	 1
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	01		 DB	 1
  000a7	01		 DB	 1
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	01		 DB	 1
  000ad	01		 DB	 1
  000ae	01		 DB	 1
  000af	01		 DB	 1
  000b0	01		 DB	 1
  000b1	01		 DB	 1
  000b2	01		 DB	 1
  000b3	01		 DB	 1
  000b4	01		 DB	 1
  000b5	01		 DB	 1
  000b6	01		 DB	 1
  000b7	01		 DB	 1
  000b8	01		 DB	 1
  000b9	01		 DB	 1
  000ba	01		 DB	 1
  000bb	00		 DB	 0
_Con_write_char ENDP
_TEXT	ENDS
PUBLIC	_Con_write_string
; Function compile flags: /Ogtpy
;	COMDAT _Con_write_string
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_string$ = 16						; size = 4
_attr$ = 20						; size = 1
_Con_write_string PROC					; COMDAT

; 294  :     const char          *   str     = string;
; 295  : 
; 296  :     x  += y * con_x_scale;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_x_scale
  00005	0f af 44 24 08	 imul	 eax, DWORD PTR _y$[esp-4]
  0000a	55		 push	 ebp
  0000b	8b 6c 24 10	 mov	 ebp, DWORD PTR _string$[esp]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b 7c 24 10	 mov	 edi, DWORD PTR _x$[esp+8]
  00015	03 f8		 add	 edi, eax

; 297  :     
; 298  :     while( *str )

  00017	0f b6 45 00	 movzx	 eax, BYTE PTR [ebp]
  0001b	84 c0		 test	 al, al
  0001d	8b f5		 mov	 esi, ebp
  0001f	74 1e		 je	 SHORT $LN1@Con_write_@2
  00021	53		 push	 ebx
  00022	8b 5c 24 20	 mov	 ebx, DWORD PTR _attr$[esp+12]
$LL2@Con_write_@2:

; 299  :         Con_write_char(x++,(byte_t)*str++,attr);

  00026	53		 push	 ebx
  00027	50		 push	 eax
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 _Con_write_char
  0002e	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  00031	83 c6 01	 add	 esi, 1
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
  00037	83 c7 01	 add	 edi, 1
  0003a	84 c0		 test	 al, al
  0003c	75 e8		 jne	 SHORT $LL2@Con_write_@2
  0003e	5b		 pop	 ebx
$LN1@Con_write_@2:
  0003f	5f		 pop	 edi

; 300  :     
; 301  :     return str - string;

  00040	8b c6		 mov	 eax, esi
  00042	5e		 pop	 esi
  00043	2b c5		 sub	 eax, ebp
  00045	5d		 pop	 ebp

; 302  : }

  00046	c3		 ret	 0
_Con_write_string ENDP
_TEXT	ENDS
PUBLIC	_Con_write
; Function compile flags: /Ogtpy
;	COMDAT _Con_write
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_buffer$ = 16						; size = 4
_size$ = 20						; size = 4
_attr$ = 24						; size = 1
_Con_write PROC						; COMDAT

; 309  :     const byte_t        *   buf     = buffer;
; 310  : 
; 311  :     x  += y * con_x_scale;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_x_scale
  00005	0f af 44 24 08	 imul	 eax, DWORD PTR _y$[esp-4]
  0000a	53		 push	 ebx
  0000b	8b 5c 24 10	 mov	 ebx, DWORD PTR _buffer$[esp]
  0000f	56		 push	 esi

; 312  :     
; 313  :     for( ;size--; )

  00010	8b 74 24 18	 mov	 esi, DWORD PTR _size$[esp+4]
  00014	57		 push	 edi
  00015	8b 7c 24 10	 mov	 edi, DWORD PTR _x$[esp+8]
  00019	03 f8		 add	 edi, eax
  0001b	85 f6		 test	 esi, esi
  0001d	74 21		 je	 SHORT $LN6@Con_write
  0001f	55		 push	 ebp
  00020	8b 6c 24 24	 mov	 ebp, DWORD PTR _attr$[esp+12]
$LL2@Con_write:

; 314  :         Con_write_char(x++,*buf++,attr);

  00024	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00027	55		 push	 ebp
  00028	50		 push	 eax
  00029	57		 push	 edi
  0002a	83 ee 01	 sub	 esi, 1
  0002d	e8 00 00 00 00	 call	 _Con_write_char
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	83 c7 01	 add	 edi, 1
  00038	83 c3 01	 add	 ebx, 1
  0003b	85 f6		 test	 esi, esi
  0003d	75 e5		 jne	 SHORT $LL2@Con_write
  0003f	5d		 pop	 ebp
$LN6@Con_write:
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 315  : }

  00043	c3		 ret	 0
_Con_write ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Con_print
_TEXT	SEGMENT
_attr$ = 8						; size = 1
_Con_print PROC						; COMDAT
; _c$ = ecx

; 320  :     switch(c)

  00000	0f b6 c1	 movzx	 eax, cl
  00003	83 c0 f8	 add	 eax, -8			; fffffff8H
  00006	83 f8 77	 cmp	 eax, 119		; 00000077H
  00009	77 47		 ja	 SHORT $LN2@Con_print
  0000b	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN18@Con_print[eax]
  00012	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN20@Con_print[eax*4]
$LN7@Con_print:

; 321  :     {
; 322  :     case CHAR_NL:        Con_nl();        break;

  00019	e8 00 00 00 00	 call	 _Con_nl
  0001e	57		 push	 edi

; 331  :         break;
; 332  :     }
; 333  :     Con_corsur();

  0001f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _con_pos
  00025	e8 00 00 00 00	 call	 _Con_set_cursor
  0002a	5f		 pop	 edi

; 334  : }

  0002b	c3		 ret	 0
$LN5@Con_print:

; 323  :     case CHAR_CR:        Con_cr();        break;
; 324  :     case CHAR_TAB:       Con_tab();       break;

  0002c	e8 00 00 00 00	 call	 _Con_tab
  00031	57		 push	 edi

; 331  :         break;
; 332  :     }
; 333  :     Con_corsur();

  00032	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _con_pos
  00038	e8 00 00 00 00	 call	 _Con_set_cursor
  0003d	5f		 pop	 edi

; 334  : }

  0003e	c3		 ret	 0
$LN4@Con_print:

; 325  :     case CHAR_BACK:      Con_back();      break;

  0003f	e8 00 00 00 00	 call	 _Con_back
  00044	57		 push	 edi

; 331  :         break;
; 332  :     }
; 333  :     Con_corsur();

  00045	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _con_pos
  0004b	e8 00 00 00 00	 call	 _Con_set_cursor
  00050	5f		 pop	 edi

; 334  : }

  00051	c3		 ret	 0
$LN2@Con_print:

; 326  :     case CHAR_DEL:       Con_del();       break;
; 327  :     default:
; 328  :          CON_SET_BYTE(con_pos++,c,attr << 8);

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _con_pos
  00057	33 d2		 xor	 edx, edx
  00059	8a 74 24 04	 mov	 dh, BYTE PTR _attr$[esp-4]
  0005d	83 c0 01	 add	 eax, 1
  00060	a3 00 00 00 00	 mov	 DWORD PTR _con_pos, eax
  00065	8a d1		 mov	 dl, cl

; 329  :         if( con_pos >= con_x_scale * con_y_scale)

  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _con_y_scale
  0006d	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _con_x_scale
  00074	3b c1		 cmp	 eax, ecx
  00076	66 89 14 45 fe
	7f 0b 00	 mov	 WORD PTR [eax*2+753662], dx
  0007e	7c 0a		 jl	 SHORT $LN19@Con_print

; 330  :             Con_scroll_up(1);

  00080	6a 01		 push	 1
  00082	e8 00 00 00 00	 call	 _Con_scroll_up
  00087	83 c4 04	 add	 esp, 4
$LN19@Con_print:
  0008a	57		 push	 edi

; 331  :         break;
; 332  :     }
; 333  :     Con_corsur();

  0008b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _con_pos
  00091	e8 00 00 00 00	 call	 _Con_set_cursor
  00096	5f		 pop	 edi

; 334  : }

  00097	c3		 ret	 0
$LN20@Con_print:
  00098	00 00 00 00	 DD	 $LN4@Con_print
  0009c	00 00 00 00	 DD	 $LN5@Con_print
  000a0	00 00 00 00	 DD	 $LN7@Con_print
  000a4	00 00 00 00	 DD	 $LN19@Con_print
  000a8	00 00 00 00	 DD	 $LN2@Con_print
$LN18@Con_print:
  000ac	00		 DB	 0
  000ad	01		 DB	 1
  000ae	02		 DB	 2
  000af	04		 DB	 4
  000b0	04		 DB	 4
  000b1	03		 DB	 3
  000b2	04		 DB	 4
  000b3	04		 DB	 4
  000b4	04		 DB	 4
  000b5	04		 DB	 4
  000b6	04		 DB	 4
  000b7	04		 DB	 4
  000b8	04		 DB	 4
  000b9	04		 DB	 4
  000ba	04		 DB	 4
  000bb	04		 DB	 4
  000bc	04		 DB	 4
  000bd	04		 DB	 4
  000be	04		 DB	 4
  000bf	04		 DB	 4
  000c0	04		 DB	 4
  000c1	04		 DB	 4
  000c2	04		 DB	 4
  000c3	04		 DB	 4
  000c4	04		 DB	 4
  000c5	04		 DB	 4
  000c6	04		 DB	 4
  000c7	04		 DB	 4
  000c8	04		 DB	 4
  000c9	04		 DB	 4
  000ca	04		 DB	 4
  000cb	04		 DB	 4
  000cc	04		 DB	 4
  000cd	04		 DB	 4
  000ce	04		 DB	 4
  000cf	04		 DB	 4
  000d0	04		 DB	 4
  000d1	04		 DB	 4
  000d2	04		 DB	 4
  000d3	04		 DB	 4
  000d4	04		 DB	 4
  000d5	04		 DB	 4
  000d6	04		 DB	 4
  000d7	04		 DB	 4
  000d8	04		 DB	 4
  000d9	04		 DB	 4
  000da	04		 DB	 4
  000db	04		 DB	 4
  000dc	04		 DB	 4
  000dd	04		 DB	 4
  000de	04		 DB	 4
  000df	04		 DB	 4
  000e0	04		 DB	 4
  000e1	04		 DB	 4
  000e2	04		 DB	 4
  000e3	04		 DB	 4
  000e4	04		 DB	 4
  000e5	04		 DB	 4
  000e6	04		 DB	 4
  000e7	04		 DB	 4
  000e8	04		 DB	 4
  000e9	04		 DB	 4
  000ea	04		 DB	 4
  000eb	04		 DB	 4
  000ec	04		 DB	 4
  000ed	04		 DB	 4
  000ee	04		 DB	 4
  000ef	04		 DB	 4
  000f0	04		 DB	 4
  000f1	04		 DB	 4
  000f2	04		 DB	 4
  000f3	04		 DB	 4
  000f4	04		 DB	 4
  000f5	04		 DB	 4
  000f6	04		 DB	 4
  000f7	04		 DB	 4
  000f8	04		 DB	 4
  000f9	04		 DB	 4
  000fa	04		 DB	 4
  000fb	04		 DB	 4
  000fc	04		 DB	 4
  000fd	04		 DB	 4
  000fe	04		 DB	 4
  000ff	04		 DB	 4
  00100	04		 DB	 4
  00101	04		 DB	 4
  00102	04		 DB	 4
  00103	04		 DB	 4
  00104	04		 DB	 4
  00105	04		 DB	 4
  00106	04		 DB	 4
  00107	04		 DB	 4
  00108	04		 DB	 4
  00109	04		 DB	 4
  0010a	04		 DB	 4
  0010b	04		 DB	 4
  0010c	04		 DB	 4
  0010d	04		 DB	 4
  0010e	04		 DB	 4
  0010f	04		 DB	 4
  00110	04		 DB	 4
  00111	04		 DB	 4
  00112	04		 DB	 4
  00113	04		 DB	 4
  00114	04		 DB	 4
  00115	04		 DB	 4
  00116	04		 DB	 4
  00117	04		 DB	 4
  00118	04		 DB	 4
  00119	04		 DB	 4
  0011a	04		 DB	 4
  0011b	04		 DB	 4
  0011c	04		 DB	 4
  0011d	04		 DB	 4
  0011e	04		 DB	 4
  0011f	04		 DB	 4
  00120	04		 DB	 4
  00121	04		 DB	 4
  00122	04		 DB	 4
  00123	03		 DB	 3
_Con_print ENDP
_TEXT	ENDS
PUBLIC	_Con_print_char
; Function compile flags: /Ogtpy
;	COMDAT _Con_print_char
_TEXT	SEGMENT
_c$ = 8							; size = 1
_Con_print_char PROC					; COMDAT

; 338  :     Con_print(c,(byte_t)(con_attr >> 8));

  00000	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _con_attr+1
  00007	8a 4c 24 04	 mov	 cl, BYTE PTR _c$[esp-4]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 _Con_print
  00011	59		 pop	 ecx

; 339  : }

  00012	c3		 ret	 0
_Con_print_char ENDP
_TEXT	ENDS
PUBLIC	_Con_print_string
; Function compile flags: /Ogtpy
;	COMDAT _Con_print_string
_TEXT	SEGMENT
_attr$ = 8						; size = 1
_string$ = 8						; size = 4
_Con_print_string PROC					; COMDAT

; 343  :     const char          *   str     = string;
; 344  :     byte_t                  attr    = (byte_t)(con_attr >> 8);

  00000	a0 01 00 00 00	 mov	 al, BYTE PTR _con_attr+1
  00005	53		 push	 ebx
  00006	8b 5c 24 08	 mov	 ebx, DWORD PTR _string$[esp]

; 345  : 
; 346  :     while( *str)

  0000a	8a 0b		 mov	 cl, BYTE PTR [ebx]
  0000c	84 c9		 test	 cl, cl
  0000e	56		 push	 esi
  0000f	8b f3		 mov	 esi, ebx
  00011	88 44 24 0c	 mov	 BYTE PTR _attr$[esp+4], al
  00015	74 1d		 je	 SHORT $LN1@Con_print_
  00017	57		 push	 edi
  00018	8b 7c 24 10	 mov	 edi, DWORD PTR _attr$[esp+8]
  0001c	8d 64 24 00	 npad	 4
$LL2@Con_print_:

; 347  :         Con_print(*str++,attr);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 _Con_print
  00026	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00029	83 c6 01	 add	 esi, 1
  0002c	83 c4 04	 add	 esp, 4
  0002f	84 c9		 test	 cl, cl
  00031	75 ed		 jne	 SHORT $LL2@Con_print_
  00033	5f		 pop	 edi
$LN1@Con_print_:

; 348  :     
; 349  :     return str - string;

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	2b c3		 sub	 eax, ebx
  00039	5b		 pop	 ebx

; 350  : }

  0003a	c3		 ret	 0
_Con_print_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@NHFFANLN@PC?5consol?5initial?4?4?4?5?5?5?$AA@ ; `string'
PUBLIC	_Con_initial
;	COMDAT ??_C@_0BI@NHFFANLN@PC?5consol?5initial?4?4?4?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BI@NHFFANLN@PC?5consol?5initial?4?4?4?5?5?5?$AA@ DB 'PC consol ini'
	DB	'tial...   ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Con_initial
_TEXT	SEGMENT
_Con_initial PROC					; COMDAT

; 354  :     _printk("PC consol initial...   ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NHFFANLN@PC?5consol?5initial?4?4?4?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 355  :     con_attr    = 0x0700;
; 356  :     con_x_scale = 80;
; 357  :     con_y_scale = 25;
; 358  :     _printk("OK!\n");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0000f	66 c7 05 00 00
	00 00 00 07	 mov	 WORD PTR _con_attr, 1792 ; 00000700H
  00018	c7 05 00 00 00
	00 50 00 00 00	 mov	 DWORD PTR _con_x_scale, 80 ; 00000050H
  00022	c7 05 00 00 00
	00 19 00 00 00	 mov	 DWORD PTR _con_y_scale, 25 ; 00000019H
  0002c	e8 00 00 00 00	 call	 __printk
  00031	83 c4 08	 add	 esp, 8

; 359  : }

  00034	c3		 ret	 0
_Con_initial ENDP
_TEXT	ENDS
PUBLIC	_Pc_keyboard_led_set
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\keyboard.c
;	COMDAT _Pc_keyboard_led_set
_TEXT	SEGMENT
_ledstat$ = 8						; size = 1
_Pc_keyboard_led_set PROC				; COMDAT

; 166  :     Io_outb((void *)0x60,0xED);

  00000	68 ed 00 00 00	 push	 237			; 000000edH
  00005	6a 60		 push	 96			; 00000060H
  00007	e8 00 00 00 00	 call	 _Io_outb

; 167  :     Io_delay();

  0000c	e8 00 00 00 00	 call	 _Io_delay

; 168  :     Io_outb((void *)0x60,ledstat);

  00011	8b 44 24 0c	 mov	 eax, DWORD PTR _ledstat$[esp+4]
  00015	50		 push	 eax
  00016	6a 60		 push	 96			; 00000060H
  00018	e8 00 00 00 00	 call	 _Io_outb
  0001d	83 c4 10	 add	 esp, 16			; 00000010H

; 169  : }

  00020	c3		 ret	 0
_Pc_keyboard_led_set ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _none
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_none	PROC						; COMDAT

; 172  :     sc = 0;     /*  这个写法是为了在BC3.1中，避免出现变量未引用的警告，以下也有类似情况   */
; 173  :     return sc;

  00000	32 c0		 xor	 al, al

; 174  : }

  00002	c3		 ret	 0
_none	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _HandleNormal
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_HandleNormal PROC					; COMDAT

; 178  :     byte_t    ascii        = 0;
; 179  : 
; 180  :     sc &= 0x7F;

  00000	8a 44 24 04	 mov	 al, BYTE PTR _sc$[esp-4]

; 181  :     /*
; 182  :      *  shift按键按下，则更换字符表
; 183  :      */
; 184  :     if(IS_SHIFT_PRESS(keyboard_status))

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _keyboard_status
  0000a	24 7f		 and	 al, 127			; 0000007fH
  0000c	f6 c1 30	 test	 cl, 48			; 00000030H
  0000f	74 0b		 je	 SHORT $LN5@HandleNorm

; 185  :         ascii = ascii_tabs[sc];

  00011	0f b6 d0	 movzx	 edx, al
  00014	8a 82 00 00 00
	00		 mov	 al, BYTE PTR _ascii_tabs[edx]

; 186  :     else

  0001a	eb 09		 jmp	 SHORT $LN4@HandleNorm
$LN5@HandleNorm:

; 187  :         ascii = ascii_tab [sc];

  0001c	0f b6 c0	 movzx	 eax, al
  0001f	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _ascii_tab[eax]
$LN4@HandleNorm:

; 188  : 
; 189  :     if( (led & PC_KBLED_CAPSLOCK) && IS_LETTER(ascii) )

  00025	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0002b	f6 c1 04	 test	 cl, 4
  0002e	74 14		 je	 SHORT $LN3@HandleNorm
  00030	3c 61		 cmp	 al, 97			; 00000061H
  00032	72 04		 jb	 SHORT $LN1@HandleNorm
  00034	3c 7a		 cmp	 al, 122			; 0000007aH
  00036	76 0a		 jbe	 SHORT $LN2@HandleNorm
$LN1@HandleNorm:
  00038	8a d0		 mov	 dl, al
  0003a	80 ea 41	 sub	 dl, 65			; 00000041H
  0003d	80 fa 19	 cmp	 dl, 25			; 00000019H
  00040	77 02		 ja	 SHORT $LN3@HandleNorm
$LN2@HandleNorm:

; 190  :         ascii ^= 0x20;

  00042	34 20		 xor	 al, 32			; 00000020H
$LN3@HandleNorm:

; 191  : 
; 192  :     return ascii;
; 193  : }

  00044	c3		 ret	 0
_HandleNormal ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_left_shift
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_left_shift PROC					; COMDAT

; 199  :     /*
; 200  :      *  前导存在E0，说明这是一个过渡指示字符
; 201  :      */
; 202  :     if( e0e1 & 1)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _e0e1
  00005	a8 01		 test	 al, 1
  00007	74 0d		 je	 SHORT $LN1@Handle_lef

; 203  :     {
; 204  :         gray = 1;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _gray, 1

; 209  :     sc = 0;
; 210  :     return sc;

  00013	32 c0		 xor	 al, al

; 211  : }

  00015	c3		 ret	 0
$LN1@Handle_lef:

; 205  :         return 0;
; 206  :     }
; 207  : 
; 208  :     keyboard_status ^= KB_STATE_LEFT_SHIFT;

  00016	83 35 00 00 00
	00 10		 xor	 DWORD PTR _keyboard_status, 16 ; 00000010H

; 209  :     sc = 0;
; 210  :     return sc;

  0001d	32 c0		 xor	 al, al

; 211  : }

  0001f	c3		 ret	 0
_Handle_left_shift ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_right_shift
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_right_shift PROC				; COMDAT

; 218  :     keyboard_status ^= KB_STATE_RIGHT_SHIFT;

  00000	83 35 00 00 00
	00 20		 xor	 DWORD PTR _keyboard_status, 32 ; 00000020H

; 219  :     sc = 0;
; 220  :     return sc;

  00007	32 c0		 xor	 al, al

; 221  : }

  00009	c3		 ret	 0
_Handle_right_shift ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_caps_lock
_TEXT	SEGMENT
$T3025 = 8						; size = 1
_sc$ = 8						; size = 1
_Handle_caps_lock PROC					; COMDAT

; 227  :     if( sc & 0x80)

  00000	f6 44 24 04 80	 test	 BYTE PTR _sc$[esp-4], 128 ; 00000080H

; 228  :         return 0;

  00005	75 39		 jne	 SHORT $LN6@Handle_cap

; 229  : 
; 230  :     led ^= PC_KBLED_CAPSLOCK;

  00007	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _led
  0000e	83 f0 04	 xor	 eax, 4
  00011	a2 00 00 00 00	 mov	 BYTE PTR _led, al

; 231  : 
; 232  :     Pc_keyboard_led_set(led);

  00016	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0001c	68 ed 00 00 00	 push	 237			; 000000edH
  00021	6a 60		 push	 96			; 00000060H
  00023	88 4c 24 0c	 mov	 BYTE PTR $T3025[esp+4], cl
  00027	e8 00 00 00 00	 call	 _Io_outb
  0002c	e8 00 00 00 00	 call	 _Io_delay
  00031	8b 54 24 0c	 mov	 edx, DWORD PTR $T3025[esp+4]
  00035	52		 push	 edx
  00036	6a 60		 push	 96			; 00000060H
  00038	e8 00 00 00 00	 call	 _Io_outb
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@Handle_cap:

; 233  : 
; 234  :     return 0;

  00040	32 c0		 xor	 al, al

; 235  : }

  00042	c3		 ret	 0
_Handle_caps_lock ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_left_ctrl
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_left_ctrl PROC					; COMDAT

; 242  :     sc = 0;
; 243  :     keyboard_status ^= KB_STATE_LEFT_CTRL;

  00000	83 35 00 00 00
	00 01		 xor	 DWORD PTR _keyboard_status, 1

; 244  :     return sc;

  00007	32 c0		 xor	 al, al

; 245  : }

  00009	c3		 ret	 0
_Handle_left_ctrl ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_left_alt
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_left_alt PROC					; COMDAT

; 251  :     sc = 0;
; 252  :     keyboard_status ^= KB_STATE_LEFT_ALT;

  00000	83 35 00 00 00
	00 04		 xor	 DWORD PTR _keyboard_status, 4

; 253  :     return sc;

  00007	32 c0		 xor	 al, al

; 254  : }

  00009	c3		 ret	 0
_Handle_left_alt ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_minor
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_minor PROC					; COMDAT

; 258  :     sc = '-';
; 259  :     return sc;

  00000	b0 2d		 mov	 al, 45			; 0000002dH

; 260  : }

  00002	c3		 ret	 0
_Handle_minor ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_plus
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_plus PROC					; COMDAT

; 263  :     sc = '+';
; 264  :     return sc;

  00000	b0 2b		 mov	 al, 43			; 0000002bH

; 265  : }

  00002	c3		 ret	 0
_Handle_plus ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray0
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray0 PROC					; COMDAT

; 269  :     sc = 0;
; 270  :     if( !gray && (led & PC_KBLED_NUMLOCK) )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra

; 271  :         return '0';

  00014	b0 30		 mov	 al, 48			; 00000030H

; 274  : }

  00016	c3		 ret	 0
$LN1@Handle_gra:

; 272  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 273  :     return sc;

  00021	32 c0		 xor	 al, al

; 274  : }

  00023	c3		 ret	 0
_Handle_gray0 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray1
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray1 PROC					; COMDAT

; 277  :     sc = 0;
; 278  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@2
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@2

; 279  :         return '1';

  00014	b0 31		 mov	 al, 49			; 00000031H

; 282  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@2:

; 280  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 281  :     return sc;

  00021	32 c0		 xor	 al, al

; 282  : }

  00023	c3		 ret	 0
_Handle_gray1 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray2
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray2 PROC					; COMDAT

; 285  :     sc = 0;
; 286  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@3
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@3

; 287  :         return '2';

  00014	b0 32		 mov	 al, 50			; 00000032H

; 290  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@3:

; 288  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 289  :     return sc;

  00021	32 c0		 xor	 al, al

; 290  : }

  00023	c3		 ret	 0
_Handle_gray2 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray3
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray3 PROC					; COMDAT

; 293  :     sc = 0;
; 294  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@4
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@4

; 295  :         return '3';

  00014	b0 33		 mov	 al, 51			; 00000033H

; 298  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@4:

; 296  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 297  :     return sc;

  00021	32 c0		 xor	 al, al

; 298  : }

  00023	c3		 ret	 0
_Handle_gray3 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray4
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray4 PROC					; COMDAT

; 301  :     sc = 0;
; 302  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@5
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@5

; 303  :         return '4';

  00014	b0 34		 mov	 al, 52			; 00000034H

; 306  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@5:

; 304  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 305  :     return sc;

  00021	32 c0		 xor	 al, al

; 306  : }

  00023	c3		 ret	 0
_Handle_gray4 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray5
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray5 PROC					; COMDAT

; 309  :     sc = 0;
; 310  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@6
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@6

; 311  :         return '5';

  00014	b0 35		 mov	 al, 53			; 00000035H

; 314  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@6:

; 312  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 313  :     return sc;

  00021	32 c0		 xor	 al, al

; 314  : }

  00023	c3		 ret	 0
_Handle_gray5 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray6
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray6 PROC					; COMDAT

; 317  :     sc = 0;
; 318  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@7
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@7

; 319  :         return '6';

  00014	b0 36		 mov	 al, 54			; 00000036H

; 322  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@7:

; 320  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 321  :     return sc;

  00021	32 c0		 xor	 al, al

; 322  : }

  00023	c3		 ret	 0
_Handle_gray6 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray7
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray7 PROC					; COMDAT

; 325  :     sc = 0;
; 326  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@8
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@8

; 327  :         return '7';

  00014	b0 37		 mov	 al, 55			; 00000037H

; 330  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@8:

; 328  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 329  :     return sc;

  00021	32 c0		 xor	 al, al

; 330  : }

  00023	c3		 ret	 0
_Handle_gray7 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray8
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray8 PROC					; COMDAT

; 333  :     sc = 0;
; 334  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@9
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@9

; 335  :         return '8';

  00014	b0 38		 mov	 al, 56			; 00000038H

; 339  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@9:

; 336  :     
; 337  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 338  :     return sc;

  00021	32 c0		 xor	 al, al

; 339  : }

  00023	c3		 ret	 0
_Handle_gray8 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_gray9
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_gray9 PROC					; COMDAT

; 342  :     sc = 0;
; 343  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@10
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@10

; 344  :         return '9';

  00014	b0 39		 mov	 al, 57			; 00000039H

; 347  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@10:

; 345  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 346  :     return sc;

  00021	32 c0		 xor	 al, al

; 347  : }

  00023	c3		 ret	 0
_Handle_gray9 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_graydot
_TEXT	SEGMENT
_sc$ = 8						; size = 1
_Handle_graydot PROC					; COMDAT

; 350  :     sc = 0;
; 351  :     if( !gray && led & PC_KBLED_NUMLOCK )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _gray
  00005	85 c0		 test	 eax, eax
  00007	75 0e		 jne	 SHORT $LN1@Handle_gra@11
  00009	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0000f	f6 c1 02	 test	 cl, 2
  00012	74 03		 je	 SHORT $LN1@Handle_gra@11

; 352  :         return '.';

  00014	b0 2e		 mov	 al, 46			; 0000002eH

; 355  : }

  00016	c3		 ret	 0
$LN1@Handle_gra@11:

; 353  :     gray = 0;

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _gray, 0

; 354  :     return sc;

  00021	32 c0		 xor	 al, al

; 355  : }

  00023	c3		 ret	 0
_Handle_graydot ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_numlock
_TEXT	SEGMENT
$T3062 = 8						; size = 1
_sc$ = 8						; size = 1
_Handle_numlock PROC					; COMDAT

; 358  :     if( sc & 0x80 ) return 0;

  00000	f6 44 24 04 80	 test	 BYTE PTR _sc$[esp-4], 128 ; 00000080H
  00005	75 39		 jne	 SHORT $LN6@Handle_num

; 359  :     led ^= PC_KBLED_NUMLOCK;

  00007	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _led
  0000e	83 f0 02	 xor	 eax, 2
  00011	a2 00 00 00 00	 mov	 BYTE PTR _led, al

; 360  :     Pc_keyboard_led_set(led);

  00016	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0001c	68 ed 00 00 00	 push	 237			; 000000edH
  00021	6a 60		 push	 96			; 00000060H
  00023	88 4c 24 0c	 mov	 BYTE PTR $T3062[esp+4], cl
  00027	e8 00 00 00 00	 call	 _Io_outb
  0002c	e8 00 00 00 00	 call	 _Io_delay
  00031	8b 54 24 0c	 mov	 edx, DWORD PTR $T3062[esp+4]
  00035	52		 push	 edx
  00036	6a 60		 push	 96			; 00000060H
  00038	e8 00 00 00 00	 call	 _Io_outb
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@Handle_num:

; 361  :     return 0;

  00040	32 c0		 xor	 al, al

; 362  : }

  00042	c3		 ret	 0
_Handle_numlock ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Handle_scrlck
_TEXT	SEGMENT
$T3069 = 8						; size = 1
_sc$ = 8						; size = 1
_Handle_scrlck PROC					; COMDAT

; 365  :     if( sc & 0x80 ) return 0;

  00000	f6 44 24 04 80	 test	 BYTE PTR _sc$[esp-4], 128 ; 00000080H
  00005	75 39		 jne	 SHORT $LN6@Handle_scr

; 366  :     led ^= PC_KBLED_SCROLLLOCK;

  00007	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _led
  0000e	83 f0 01	 xor	 eax, 1
  00011	a2 00 00 00 00	 mov	 BYTE PTR _led, al

; 367  :     Pc_keyboard_led_set(led);

  00016	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _led
  0001c	68 ed 00 00 00	 push	 237			; 000000edH
  00021	6a 60		 push	 96			; 00000060H
  00023	88 4c 24 0c	 mov	 BYTE PTR $T3069[esp+4], cl
  00027	e8 00 00 00 00	 call	 _Io_outb
  0002c	e8 00 00 00 00	 call	 _Io_delay
  00031	8b 54 24 0c	 mov	 edx, DWORD PTR $T3069[esp+4]
  00035	52		 push	 edx
  00036	6a 60		 push	 96			; 00000060H
  00038	e8 00 00 00 00	 call	 _Io_outb
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@Handle_scr:

; 368  :     return 0;

  00040	32 c0		 xor	 al, al

; 369  : }

  00042	c3		 ret	 0
_Handle_scrlck ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@MJOLGCMH@keyboard?5irq?4stat?3?5?$CF08X?5ascii?3?5?$CF@ ; `string'
PUBLIC	_Kb_handle
EXTRN	_Tty_put_char:PROC
EXTRN	__sprintf:PROC
;	COMDAT ??_C@_0DC@MJOLGCMH@keyboard?5irq?4stat?3?5?$CF08X?5ascii?3?5?$CF@
CONST	SEGMENT
??_C@_0DC@MJOLGCMH@keyboard?5irq?4stat?3?5?$CF08X?5ascii?3?5?$CF@ DB 'key'
	DB	'board irq.stat: %08X ascii: %c %4d sc: %02X  ', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Kb_handle
_TEXT	SEGMENT
_msg$ = -64						; size = 64
_kbstat$ = 8						; size = 4
_ascii$ = 12						; size = 1
_sc$ = 16						; size = 1
_Kb_handle PROC						; COMDAT

; 373  : #ifdef _CFG_DEBUG_
; 374  :     /**/
; 375  :     char            msg[64];
; 376  : 
; 377  :     _sprintf(msg,"keyboard irq.stat: %08X ascii: %c %4d sc: %02X  \n",
; 378  :         keyboard_status,ascii,ascii,sc & 0xFF);

  00000	0f b6 4c 24 0c	 movzx	 ecx, BYTE PTR _sc$[esp-4]
  00005	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _keyboard_status
  0000b	83 ec 40	 sub	 esp, 64			; 00000040H
  0000e	53		 push	 ebx
  0000f	8b 5c 24 4c	 mov	 ebx, DWORD PTR _ascii$[esp+64]
  00013	51		 push	 ecx
  00014	0f b6 c3	 movzx	 eax, bl
  00017	50		 push	 eax
  00018	50		 push	 eax
  00019	52		 push	 edx
  0001a	8d 44 24 14	 lea	 eax, DWORD PTR _msg$[esp+84]
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@MJOLGCMH@keyboard?5irq?4stat?3?5?$CF08X?5ascii?3?5?$CF@
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __sprintf

; 379  :     
; 380  :     Con_write_string(30,1,msg,0x07);

  00029	6a 07		 push	 7
  0002b	8d 4c 24 20	 lea	 ecx, DWORD PTR _msg$[esp+96]
  0002f	51		 push	 ecx
  00030	6a 01		 push	 1
  00032	6a 1e		 push	 30			; 0000001eH
  00034	e8 00 00 00 00	 call	 _Con_write_string
  00039	83 c4 28	 add	 esp, 40			; 00000028H

; 381  :     /*****/
; 382  : #endif  /*_CFG_DEBUG_*/
; 383  :     /****/
; 384  :    
; 385  :     if( sc & 0x80 ) return ;

  0003c	f6 44 24 50 80	 test	 BYTE PTR _sc$[esp+64], 128 ; 00000080H
  00041	75 0f		 jne	 SHORT $LN3@Kb_handle

; 386  : 
; 387  :     if( ascii == 0 )

  00043	84 db		 test	 bl, bl

; 388  :     {
; 389  :         kbstat = kbstat; /*  避免编译器产生变量未使用的警告 */
; 390  :         return ;

  00045	74 0b		 je	 SHORT $LN3@Kb_handle

; 391  :     }
; 392  : 
; 393  : #ifdef _CFG_TTY_ENABLE_
; 394  :     /*
; 395  :      *  启用TTY时，向主TTY发送数据
; 396  :      */
; 397  :     Tty_put_char(TTY_MAJOR,ascii);

  00047	53		 push	 ebx
  00048	6a 00		 push	 0
  0004a	e8 00 00 00 00	 call	 _Tty_put_char
  0004f	83 c4 08	 add	 esp, 8
$LN3@Kb_handle:
  00052	5b		 pop	 ebx

; 398  : #endif  /*  _CFG_TTY_ENABLE */
; 399  : }

  00053	83 c4 40	 add	 esp, 64			; 00000040H
  00056	c3		 ret	 0
_Kb_handle ENDP
_TEXT	ENDS
PUBLIC	_Kb_do_irq
; Function compile flags: /Ogtpy
;	COMDAT _Kb_do_irq
_TEXT	SEGMENT
_ascii$ = -4						; size = 1
_notuse$ = 8						; size = 4
_sc$ = 12						; size = 4
_Kb_do_irq PROC						; COMDAT

; 402  : {

  00000	51		 push	 ecx

; 403  :     byte_t          ascii;    
; 404  : 
; 405  :     if( interrupt_nest > IRQ_NEST_MAX )

  00001	80 3d 00 00 00
	00 c4		 cmp	 BYTE PTR _interrupt_nest, 196 ; 000000c4H
  00008	76 0b		 jbe	 SHORT $LN1@Kb_do_irq

; 406  :     {
; 407  :         notuse = notuse;
; 408  :         Machine_interrupt_mis();

  0000a	83 05 00 00 00
	00 01		 add	 DWORD PTR _interrupt_mis_count, 1

; 415  :     
; 416  :     return 0;

  00011	33 c0		 xor	 eax, eax

; 417  : }

  00013	59		 pop	 ecx
  00014	c3		 ret	 0
$LN1@Kb_do_irq:
  00015	56		 push	 esi

; 409  :         return 0;
; 410  :     }
; 411  : 
; 412  :     ascii = kb_handle_tab[sc & 0x7F ]((byte_t)sc);

  00016	8b 74 24 10	 mov	 esi, DWORD PTR _sc$[esp+4]
  0001a	8b c6		 mov	 eax, esi
  0001c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0001f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _kb_handle_tab[eax*4]
  00026	56		 push	 esi
  00027	ff d1		 call	 ecx
  00029	88 44 24 08	 mov	 BYTE PTR _ascii$[esp+12], al

; 413  : 
; 414  :     Kb_handle(keyboard_status,ascii,sc);

  0002d	8b 54 24 08	 mov	 edx, DWORD PTR _ascii$[esp+12]
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR _keyboard_status
  00036	56		 push	 esi
  00037	52		 push	 edx
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _Kb_handle
  0003e	83 c4 10	 add	 esp, 16			; 00000010H
  00041	5e		 pop	 esi

; 415  :     
; 416  :     return 0;

  00042	33 c0		 xor	 eax, eax

; 417  : }

  00044	59		 pop	 ecx
  00045	c3		 ret	 0
_Kb_do_irq ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@EKGNADKI@pid?3?$CF3d?5prio?3?$CF2d?5sp?3?$CFP?5sf?3?$CF6d?5na@ ; `string'
PUBLIC	_Proc_msg
EXTRN	_Proc_pool:PROC
;	COMDAT ??_C@_0CJ@EKGNADKI@pid?3?$CF3d?5prio?3?$CF2d?5sp?3?$CFP?5sf?3?$CF6d?5na@
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\consol.c
CONST	SEGMENT
??_C@_0CJ@EKGNADKI@pid?3?$CF3d?5prio?3?$CF2d?5sp?3?$CFP?5sf?3?$CF6d?5na@ DB 'p'
	DB	'id:%3d prio:%2d sp:%P sf:%6d name: %s ', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\pc_debug.c
CONST	ENDS
;	COMDAT _Proc_msg
_TEXT	SEGMENT
tv387 = -68						; size = 4
_msg$ = -64						; size = 64
_Proc_msg PROC						; COMDAT

; 54   : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 55   :     char                    msg[64];    /*  显示字符串缓冲区                */
; 56   :     proc_t              *   proc;
; 57   :     int                     line;       /*  在屏幕上的行号                  */
; 58   :     int                     i;
; 59   :     
; 60   :     line = 23;

  00007	bd 17 00 00 00	 mov	 ebp, 23			; 00000017H

; 61   :     
; 62   :     for( i = 0 , proc = Proc_pool(); i < PROC_MAX; i++,proc++)

  0000c	e8 00 00 00 00	 call	 _Proc_pool
  00011	8d 78 14	 lea	 edi, DWORD PTR [eax+20]
  00014	c7 44 24 10 20
	00 00 00	 mov	 DWORD PTR tv387[esp+84], 32 ; 00000020H
  0001c	8d 64 24 00	 npad	 4
$LL4@Proc_msg:

; 63   :     {
; 64   :         if( proc->proc_entry )

  00020	83 7f 18 00	 cmp	 DWORD PTR [edi+24], 0
  00024	74 59		 je	 SHORT $LN3@Proc_msg

; 65   :         {
; 66   :             _sprintf(msg,"pid:%3d prio:%2d sp:%P sf:%6d name: %s \n",
; 67   :                 proc->proc_pid,proc->proc_priority,proc->proc_sp,
; 68   :                 proc->proc_sched_factor,proc->proc_name);

  00026	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00029	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0002c	0f b6 57 39	 movzx	 edx, BYTE PTR [edi+57]
  00030	57		 push	 edi
  00031	50		 push	 eax
  00032	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
  00035	51		 push	 ecx
  00036	52		 push	 edx
  00037	50		 push	 eax
  00038	8d 4c 24 28	 lea	 ecx, DWORD PTR _msg$[esp+104]
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EKGNADKI@pid?3?$CF3d?5prio?3?$CF2d?5sp?3?$CFP?5sf?3?$CF6d?5na@
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 __sprintf

; 69   :             Con_write_string(25,line--,msg,TEXT_COLOR_GREEN);

  00047	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _con_x_scale
  0004d	0f b6 44 24 30	 movzx	 eax, BYTE PTR _msg$[esp+112]
  00052	0f af f5	 imul	 esi, ebp
  00055	83 c4 1c	 add	 esp, 28			; 0000001cH
  00058	83 c6 19	 add	 esi, 25			; 00000019H
  0005b	84 c0		 test	 al, al
  0005d	74 1d		 je	 SHORT $LN7@Proc_msg
  0005f	8d 5c 24 14	 lea	 ebx, DWORD PTR _msg$[esp+84]
  00063	2b de		 sub	 ebx, esi
$LL8@Proc_msg:
  00065	6a 02		 push	 2
  00067	50		 push	 eax
  00068	56		 push	 esi
  00069	e8 00 00 00 00	 call	 _Con_write_char
  0006e	8a 44 33 01	 mov	 al, BYTE PTR [ebx+esi+1]
  00072	83 c6 01	 add	 esi, 1
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	84 c0		 test	 al, al
  0007a	75 e9		 jne	 SHORT $LL8@Proc_msg
$LN7@Proc_msg:
  0007c	83 ed 01	 sub	 ebp, 1
$LN3@Proc_msg:

; 61   :     
; 62   :     for( i = 0 , proc = Proc_pool(); i < PROC_MAX; i++,proc++)

  0007f	83 c7 54	 add	 edi, 84			; 00000054H
  00082	83 6c 24 10 01	 sub	 DWORD PTR tv387[esp+84], 1
  00087	75 97		 jne	 SHORT $LL4@Proc_msg
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	5b		 pop	 ebx

; 70   :         }
; 71   :     }
; 72   : }

  0008d	83 c4 44	 add	 esp, 68			; 00000044H
  00090	c3		 ret	 0
_Proc_msg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@GIDGLDNL@lenix?5ticks?3?5?$CF8d?$AA@	; `string'
PUBLIC	_Clk_msg
EXTRN	_Clk_get_ticks:PROC
;	COMDAT ??_C@_0BB@GIDGLDNL@lenix?5ticks?3?5?$CF8d?$AA@
CONST	SEGMENT
??_C@_0BB@GIDGLDNL@lenix?5ticks?3?5?$CF8d?$AA@ DB 'lenix ticks: %8d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Clk_msg
_TEXT	SEGMENT
_msg$ = -40						; size = 40
_Clk_msg PROC						; COMDAT

; 75   : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H

; 76   :     char                    msg[40];
; 77   :     _sprintf(msg,"lenix ticks: %8d",Clk_get_ticks());

  00003	e8 00 00 00 00	 call	 _Clk_get_ticks
  00008	50		 push	 eax
  00009	8d 44 24 04	 lea	 eax, DWORD PTR _msg$[esp+44]
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GIDGLDNL@lenix?5ticks?3?5?$CF8d?$AA@
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 __sprintf

; 78   :     Con_write_string(50,0,msg,0x07);

  00018	6a 07		 push	 7
  0001a	8d 4c 24 10	 lea	 ecx, DWORD PTR _msg$[esp+56]
  0001e	51		 push	 ecx
  0001f	6a 00		 push	 0
  00021	6a 32		 push	 50			; 00000032H
  00023	e8 00 00 00 00	 call	 _Con_write_string

; 79   :     Proc_msg();

  00028	e8 00 00 00 00	 call	 _Proc_msg

; 80   : }

  0002d	83 c4 44	 add	 esp, 68			; 00000044H
  00030	c3		 ret	 0
_Clk_msg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@HHCNNAFF@sched?5times?3?5?$CF8d?5?$AA@ ; `string'
PUBLIC	_Proc_sched_msg
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BC@HHCNNAFF@sched?5times?3?5?$CF8d?5?$AA@
CONST	SEGMENT
??_C@_0BC@HHCNNAFF@sched?5times?3?5?$CF8d?5?$AA@ DB 'sched times: %8d ', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_sched_msg
_TEXT	SEGMENT
_msg$ = -40						; size = 40
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
_Proc_sched_msg PROC					; COMDAT

; 84   : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H

; 85   :     static uint32_t         cnt     = 0;
; 86   :     char                    msg[40] = {0};

  00003	6a 27		 push	 39			; 00000027H
  00005	8d 44 24 05	 lea	 eax, DWORD PTR _msg$[esp+45]
  00009	6a 00		 push	 0
  0000b	50		 push	 eax
  0000c	c6 44 24 0c 00	 mov	 BYTE PTR _msg$[esp+52], 0
  00011	e8 00 00 00 00	 call	 _memset

; 87   : 
; 88   :     p1 = p1;
; 89   :     p2 = p2;
; 90   :     _sprintf(msg,"sched times: %8d ",++cnt);

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cnt@?1??Proc_sched_msg@@9@9
  0001b	83 c0 01	 add	 eax, 1
  0001e	50		 push	 eax
  0001f	8d 4c 24 10	 lea	 ecx, DWORD PTR _msg$[esp+56]
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HHCNNAFF@sched?5times?3?5?$CF8d?5?$AA@
  00028	51		 push	 ecx
  00029	a3 00 00 00 00	 mov	 DWORD PTR ?cnt@?1??Proc_sched_msg@@9@9, eax
  0002e	e8 00 00 00 00	 call	 __sprintf

; 91   : 
; 92   :     Con_write_string(40,24,msg,TEXT_COLOR_RED|TEXT_COLOR_BLUE);

  00033	6a 05		 push	 5
  00035	8d 54 24 1c	 lea	 edx, DWORD PTR _msg$[esp+68]
  00039	52		 push	 edx
  0003a	6a 18		 push	 24			; 00000018H
  0003c	6a 28		 push	 40			; 00000028H
  0003e	e8 00 00 00 00	 call	 _Con_write_string

; 93   : }

  00043	83 c4 50	 add	 esp, 80			; 00000050H
  00046	c3		 ret	 0
_Proc_sched_msg ENDP
_TEXT	ENDS
PUBLIC	_Machine_ivt_set
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\machine.c
;	COMDAT _Machine_ivt_set
_TEXT	SEGMENT
_ivtid$ = 8						; size = 4
_isp$ = 12						; size = 4
_Machine_ivt_set PROC					; COMDAT

; 202  : {

  00000	53		 push	 ebx

; 203  :     isp_t                   pisp        = NULL;   /* prev isp */
; 204  :     uint16_t                mask        = 0;
; 205  : 
; 206  :     if( NULL == isp  )

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _isp$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	75 04		 jne	 SHORT $LN1@Machine_iv

; 207  :         return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	5b		 pop	 ebx

; 221  : }

  0000c	c3		 ret	 0
$LN1@Machine_iv:
  0000d	56		 push	 esi

; 208  : 
; 209  :     ivtid = ivtid & 0xF;

  0000e	8b 74 24 0c	 mov	 esi, DWORD PTR _ivtid$[esp+4]
  00012	57		 push	 edi

; 210  :     /*
; 211  :      *  修改硬件中断处理程序，考虑SMP情况，需要关闭硬件中断。
; 212  :      */
; 213  :     mask = Machine_imr_set(0); 

  00013	6a 00		 push	 0
  00015	83 e6 0f	 and	 esi, 15			; 0000000fH
  00018	e8 00 00 00 00	 call	 _Machine_imr_set

; 214  : 
; 215  :     pisp = machine_ivt[ivtid];

  0001d	8b 3c b5 00 00
	00 00		 mov	 edi, DWORD PTR _machine_ivt[esi*4]
  00024	0f b7 c0	 movzx	 eax, ax

; 216  :     machine_ivt[ivtid]  = isp;
; 217  : 
; 218  :     Machine_imr_set(mask);

  00027	50		 push	 eax
  00028	89 1c b5 00 00
	00 00		 mov	 DWORD PTR _machine_ivt[esi*4], ebx
  0002f	e8 00 00 00 00	 call	 _Machine_imr_set
  00034	83 c4 08	 add	 esp, 8

; 219  : 
; 220  :     return pisp;

  00037	8b c7		 mov	 eax, edi
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx

; 221  : }

  0003c	c3		 ret	 0
_Machine_ivt_set ENDP
_TEXT	ENDS
PUBLIC	_Machine_clock_frequency_set
EXTRN	_proc_cpu_time:DWORD
; Function compile flags: /Ogtpy
;	COMDAT _Machine_clock_frequency_set
_TEXT	SEGMENT
$T3111 = -8						; size = 2
_frequency$ = 8						; size = 2
_Machine_clock_frequency_set PROC			; COMDAT

; 273  :     uint16_t    prev_freq = clk_frequency;
; 274  : 
; 275  :     /*  将频率限定在规定的范围内              */
; 276  :     clk_frequency = MIN(frequency,MAX_CLOCK_FREQUENCY);
; 277  :     clk_frequency = MAX(frequency,MIN_CLOCK_FREQUENCY);

  00000	66 8b 44 24 04	 mov	 ax, WORD PTR _frequency$[esp-4]
  00005	83 ec 08	 sub	 esp, 8
  00008	66 3d 14 00	 cmp	 ax, 20			; 00000014H
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	0f b7 3d 00 00
	00 00		 movzx	 edi, WORD PTR _clk_frequency
  00015	77 04		 ja	 SHORT $LN11@Machine_cl
  00017	66 b8 14 00	 mov	 ax, 20			; 00000014H
$LN11@Machine_cl:

; 278  : 
; 279  :     /*
; 280  :      *  根据频率调整cpu时间片的长度
; 281  :      *  计算方式为 (默认时间片*1000)/频率
; 282  :      *  使用单位换算表示为: ( 毫秒 / 1000) / (次/秒)
; 283  :      */
; 284  :     proc_cpu_time = (DEFAULT_CPU_TIME * clk_frequency) / 1000;

  0001b	0f b7 f0	 movzx	 esi, ax
  0001e	8b ce		 mov	 ecx, esi
  00020	6b c9 32	 imul	 ecx, 50			; 00000032H
  00023	66 a3 00 00 00
	00		 mov	 WORD PTR _clk_frequency, ax
  00029	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0002e	f7 e9		 imul	 ecx
  00030	c1 fa 06	 sar	 edx, 6
  00033	8b c2		 mov	 eax, edx
  00035	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00038	03 c2		 add	 eax, edx
  0003a	a3 00 00 00 00	 mov	 DWORD PTR _proc_cpu_time, eax

; 285  : 
; 286  :     Machine_clock_frequency_set_hook(clk_frequency);

  0003f	b8 f0 34 12 00	 mov	 eax, 1193200		; 001234f0H
  00044	99		 cdq
  00045	f7 fe		 idiv	 esi
  00047	6a 36		 push	 54			; 00000036H
  00049	6a 43		 push	 67			; 00000043H
  0004b	0f b7 f0	 movzx	 esi, ax
  0004e	89 74 24 10	 mov	 DWORD PTR $T3111[esp+24], esi
  00052	e8 00 00 00 00	 call	 _Io_outb
  00057	56		 push	 esi
  00058	6a 40		 push	 64			; 00000040H
  0005a	e8 00 00 00 00	 call	 _Io_outb
  0005f	8b 4c 24 19	 mov	 ecx, DWORD PTR $T3111[esp+33]
  00063	51		 push	 ecx
  00064	6a 40		 push	 64			; 00000040H
  00066	e8 00 00 00 00	 call	 _Io_outb
  0006b	83 c4 18	 add	 esp, 24			; 00000018H

; 287  : 
; 288  :     return prev_freq;

  0006e	66 8b c7	 mov	 ax, di
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 289  : }

  00073	83 c4 08	 add	 esp, 8
  00076	c3		 ret	 0
_Machine_clock_frequency_set ENDP
_TEXT	ENDS
PUBLIC	_Rs_initial
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\com.c
;	COMDAT _Rs_initial
_TEXT	SEGMENT
_Rs_initial PROC					; COMDAT

; 148  : {

  00000	56		 push	 esi

; 149  :     uart_t uart = pc_com[0];

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _pc_com

; 150  :     Pc_com_setup(0,RS_BPS_9600);

  00007	6a 0c		 push	 12			; 0000000cH
  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _Pc_com_setup

; 151  :     Io_outb(UART_LINE_CTRL(uart),0x03);

  00010	8d 46 03	 lea	 eax, DWORD PTR [esi+3]
  00013	6a 03		 push	 3
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _Io_outb

; 152  :     Io_outb(UART_IRQ_ENABLE(uart),0x0F);

  0001b	6a 0f		 push	 15			; 0000000fH
  0001d	83 c6 01	 add	 esi, 1
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 _Io_outb
  00026	83 c4 18	 add	 esp, 24			; 00000018H

; 153  : 
; 154  :     Machine_ivt_set(ISP_COM0,Com1_do_irq);

  00029	33 c9		 xor	 ecx, ecx
  0002b	81 f9 00 00 00
	00		 cmp	 ecx, OFFSET _Com1_do_irq
  00031	5e		 pop	 esi
  00032	74 1c		 je	 SHORT $LN4@Rs_initial
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _Machine_imr_set
  0003a	0f b7 c0	 movzx	 eax, ax
  0003d	50		 push	 eax
  0003e	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _machine_ivt+8, OFFSET _Com1_do_irq
  00048	e8 00 00 00 00	 call	 _Machine_imr_set
  0004d	83 c4 08	 add	 esp, 8
$LN4@Rs_initial:

; 155  : }

  00050	c3		 ret	 0
_Rs_initial ENDP
_TEXT	ENDS
PUBLIC	_Kb_initial
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\keyboard.c
;	COMDAT _Kb_initial
_TEXT	SEGMENT
_Kb_initial PROC					; COMDAT

; 421  :     keyboard_status = 0;    // 键盘状态

  00000	33 c0		 xor	 eax, eax
  00002	a3 00 00 00 00	 mov	 DWORD PTR _keyboard_status, eax

; 422  :     keyboard_do_irq = 0;

  00007	a3 00 00 00 00	 mov	 DWORD PTR _keyboard_do_irq, eax

; 423  :     
; 424  :     led     = PC_KBLED_NUMLOCK;

  0000c	c6 05 00 00 00
	00 02		 mov	 BYTE PTR _led, 2

; 425  :     e0e1    = 0;
; 426  :     gray    = 0;
; 427  :     
; 428  :     /*
; 429  :      *  在VPC2007中，该函数会导致VPC2007无响应
; 430  :      */
; 431  :     //Pc_keyboard_led_set(led);    
; 432  :     
; 433  :     Machine_ivt_set(ISR_KEYBOARD,Kb_do_irq);

  00013	33 c9		 xor	 ecx, ecx
  00015	81 f9 00 00 00
	00		 cmp	 ecx, OFFSET _Kb_do_irq
  0001b	a3 00 00 00 00	 mov	 DWORD PTR _e0e1, eax
  00020	a3 00 00 00 00	 mov	 DWORD PTR _gray, eax
  00025	74 1c		 je	 SHORT $LN4@Kb_initial
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _Machine_imr_set
  0002d	0f b7 c0	 movzx	 eax, ax
  00030	50		 push	 eax
  00031	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _machine_ivt+4, OFFSET _Kb_do_irq
  0003b	e8 00 00 00 00	 call	 _Machine_imr_set
  00040	83 c4 08	 add	 esp, 8
$LN4@Kb_initial:

; 434  : }

  00043	c3		 ret	 0
_Kb_initial ENDP
_TEXT	ENDS
PUBLIC	_Machine_initial_hook
EXTRN	_Irq_keyboard:PROC
EXTRN	_Ivt_set:PROC
EXTRN	_Irq_clock:PROC
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\pc\pc.c
;	COMDAT _Machine_initial_hook
_TEXT	SEGMENT
_Machine_initial_hook PROC				; COMDAT

; 175  : #if _CPU_WORD_ == 16
; 176  :     dword_t handle;
; 177  : #endif
; 178  :     Pic_initial();

  00000	e8 00 00 00 00	 call	 _Pic_initial

; 179  :     Con_initial();

  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NHFFANLN@PC?5consol?5initial?4?4?4?5?5?5?$AA@
  0000a	e8 00 00 00 00	 call	 __printk
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  00014	66 c7 05 00 00
	00 00 00 07	 mov	 WORD PTR _con_attr, 1792 ; 00000700H
  0001d	c7 05 00 00 00
	00 50 00 00 00	 mov	 DWORD PTR _con_x_scale, 80 ; 00000050H
  00027	c7 05 00 00 00
	00 19 00 00 00	 mov	 DWORD PTR _con_y_scale, 25 ; 00000019H
  00031	e8 00 00 00 00	 call	 __printk

; 180  :     Kb_initial();

  00036	33 c0		 xor	 eax, eax
  00038	a3 00 00 00 00	 mov	 DWORD PTR _keyboard_status, eax
  0003d	a3 00 00 00 00	 mov	 DWORD PTR _keyboard_do_irq, eax
  00042	c6 05 00 00 00
	00 02		 mov	 BYTE PTR _led, 2
  00049	33 c9		 xor	 ecx, ecx
  0004b	83 c4 08	 add	 esp, 8
  0004e	81 f9 00 00 00
	00		 cmp	 ecx, OFFSET _Kb_do_irq
  00054	a3 00 00 00 00	 mov	 DWORD PTR _e0e1, eax
  00059	a3 00 00 00 00	 mov	 DWORD PTR _gray, eax
  0005e	74 1c		 je	 SHORT $LN8@Machine_in
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _Machine_imr_set
  00066	0f b7 c0	 movzx	 eax, ax
  00069	50		 push	 eax
  0006a	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _machine_ivt+4, OFFSET _Kb_do_irq
  00074	e8 00 00 00 00	 call	 _Machine_imr_set
  00079	83 c4 08	 add	 esp, 8
$LN8@Machine_in:
  0007c	53		 push	 ebx

; 181  :     //Rs_initial();
; 182  : 
; 183  :     physical_memory = Pc_physical_memory();

  0007d	6a 36		 push	 54			; 00000036H
  0007f	6a 70		 push	 112			; 00000070H
  00081	e8 00 00 00 00	 call	 _Io_outb
  00086	6a 71		 push	 113			; 00000071H
  00088	e8 00 00 00 00	 call	 _Io_inb
  0008d	6a 35		 push	 53			; 00000035H
  0008f	6a 70		 push	 112			; 00000070H
  00091	8a d8		 mov	 bl, al
  00093	e8 00 00 00 00	 call	 _Io_outb
  00098	6a 71		 push	 113			; 00000071H
  0009a	e8 00 00 00 00	 call	 _Io_inb
  0009f	0f b6 d0	 movzx	 edx, al
  000a2	0f b6 c3	 movzx	 eax, bl
  000a5	c1 e0 08	 shl	 eax, 8
  000a8	8d 4c 02 01	 lea	 ecx, DWORD PTR [edx+eax+1]
  000ac	c1 e1 0a	 shl	 ecx, 10			; 0000000aH

; 184  : #if _CPU_WORD_ == 16
; 185  :     handle = ((dword_t)Seg_get_cs()) * 0x10000 | (word_t)Sys_call_entry;
; 186  :     Ivt_set(0x77,handle);
; 187  : 
; 188  :     handle = ((dword_t)Seg_get_cs()) * 0x10000 | (word_t)Irq_clock;
; 189  :     Ivt_set(IRQ_CLOCK,handle);
; 190  : 
; 191  :     handle = ((dword_t)Seg_get_cs()) * 0x10000 | (word_t)Irq_keyboard;
; 192  :     Ivt_set(IRQ_KEYBOARD,handle);
; 193  : 
; 194  :     handle = ((dword_t)Seg_get_cs()) * 0x10000 | (word_t)Irq_com1;
; 195  :     /*Ivt_set(IRQ_COM1,handle);
; 196  :     Ivt_set(IRQ_COM2,handle);*/
; 197  : #else
; 198  :     /*  32位情况 */
; 199  :     Ivt_set(IRQ_CLOCK,(dword_t)Irq_clock);

  000af	68 00 00 00 00	 push	 OFFSET _Irq_clock
  000b4	6a 20		 push	 32			; 00000020H
  000b6	89 0d 00 00 00
	00		 mov	 DWORD PTR _physical_memory, ecx
  000bc	e8 00 00 00 00	 call	 _Ivt_set

; 200  :     Ivt_set(IRQ_KEYBOARD,(dword_t)Irq_keyboard);

  000c1	68 00 00 00 00	 push	 OFFSET _Irq_keyboard
  000c6	6a 21		 push	 33			; 00000021H
  000c8	e8 00 00 00 00	 call	 _Ivt_set
  000cd	83 c4 28	 add	 esp, 40			; 00000028H
  000d0	5b		 pop	 ebx

; 201  : #endif
; 202  : }

  000d1	c3		 ret	 0
_Machine_initial_hook ENDP
_TEXT	ENDS
PUBLIC	_Machine_initial
_BSS	SEGMENT
_disable_interrupt_nest DB 01H DUP (?)
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\machine\machine.c
_BSS	ENDS
;	COMDAT _Machine_initial
_TEXT	SEGMENT
_Machine_initial PROC					; COMDAT

; 125  :     int         i;
; 126  :     
; 127  :     /*  将中断处理程序设置为默认的中断处理程序*/
; 128  :     for( i = 0 ; i < IRQ_SRC_MAX ; i++ )
; 129  :         machine_ivt[i] = Machine_isp_default;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _Machine_isp_default

; 130  : 
; 131  :     clk_frequency           = DEFAULT_CLOCK_FREQUENCY;  /*  将始终频率设置为默认的频率 */
; 132  :     interrupt_nest          = 0;

  00005	33 c9		 xor	 ecx, ecx
  00007	a3 00 00 00 00	 mov	 DWORD PTR _machine_ivt, eax
  0000c	a3 04 00 00 00	 mov	 DWORD PTR _machine_ivt+4, eax
  00011	a3 08 00 00 00	 mov	 DWORD PTR _machine_ivt+8, eax
  00016	a3 0c 00 00 00	 mov	 DWORD PTR _machine_ivt+12, eax
  0001b	a3 10 00 00 00	 mov	 DWORD PTR _machine_ivt+16, eax
  00020	a3 14 00 00 00	 mov	 DWORD PTR _machine_ivt+20, eax
  00025	a3 18 00 00 00	 mov	 DWORD PTR _machine_ivt+24, eax
  0002a	a3 1c 00 00 00	 mov	 DWORD PTR _machine_ivt+28, eax
  0002f	a3 20 00 00 00	 mov	 DWORD PTR _machine_ivt+32, eax
  00034	a3 24 00 00 00	 mov	 DWORD PTR _machine_ivt+36, eax
  00039	a3 28 00 00 00	 mov	 DWORD PTR _machine_ivt+40, eax
  0003e	a3 2c 00 00 00	 mov	 DWORD PTR _machine_ivt+44, eax
  00043	a3 30 00 00 00	 mov	 DWORD PTR _machine_ivt+48, eax
  00048	a3 34 00 00 00	 mov	 DWORD PTR _machine_ivt+52, eax
  0004d	a3 38 00 00 00	 mov	 DWORD PTR _machine_ivt+56, eax
  00052	a3 3c 00 00 00	 mov	 DWORD PTR _machine_ivt+60, eax
  00057	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0005c	66 a3 00 00 00
	00		 mov	 WORD PTR _clk_frequency, ax
  00062	88 0d 00 00 00
	00		 mov	 BYTE PTR _interrupt_nest, cl

; 133  :     pic_lock                = 0;

  00068	89 0d 00 00 00
	00		 mov	 DWORD PTR _pic_lock, ecx

; 134  :     disable_interrupt_nest  = 0;

  0006e	88 0d 00 00 00
	00		 mov	 BYTE PTR _disable_interrupt_nest, cl

; 135  :     interrupt_mis_count     = 0;
; 136  :     machine_imr             = -1;
; 137  : 
; 138  :     Machine_clock_frequency_set(clk_frequency);

  00074	50		 push	 eax
  00075	89 0d 00 00 00
	00		 mov	 DWORD PTR _interrupt_mis_count, ecx
  0007b	66 c7 05 00 00
	00 00 ff ff	 mov	 WORD PTR _machine_imr, 65535 ; 0000ffffH
  00084	e8 00 00 00 00	 call	 _Machine_clock_frequency_set
  00089	83 c4 04	 add	 esp, 4

; 139  : 
; 140  :     Machine_initial_hook();

  0008c	e9 00 00 00 00	 jmp	 _Machine_initial_hook
_Machine_initial ENDP
_TEXT	ENDS
END
