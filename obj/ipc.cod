; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\ipc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@GNOLGLLG@assert?5failed?$AA@		; `string'
PUBLIC	??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0M@LMEANPIC@NULL?5?$CB?$DN?5lck?$AA@	; `string'
PUBLIC	??_C@_05MNIEOLGC@ipc?4c?$AA@			; `string'
PUBLIC	_Lck_lock
EXTRN	_Proc_sleep:PROC
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Sched_add:PROC
EXTRN	_Sched_del:PROC
EXTRN	_proc_current:DWORD
EXTRN	_Cpu_disable_interrupt:PROC
EXTRN	_Cpu_tas_i:PROC
EXTRN	_Sys_halt:PROC
EXTRN	__printf:PROC
;	COMDAT ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
; File e:\sourcexstudio\lenix\lenix\src\kernel\ipc.c
CONST	SEGMENT
??_C@_0O@GNOLGLLG@assert?5failed?$AA@ DB 'assert failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ DB 'a'
	DB	'ssert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMEANPIC@NULL?5?$CB?$DN?5lck?$AA@
CONST	SEGMENT
??_C@_0M@LMEANPIC@NULL?5?$CB?$DN?5lck?$AA@ DB 'NULL != lck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNIEOLGC@ipc?4c?$AA@
CONST	SEGMENT
??_C@_05MNIEOLGC@ipc?4c?$AA@ DB 'ipc.c', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Lck_lock
_TEXT	SEGMENT
_lck$ = 8						; size = 4
_Lck_lock PROC						; COMDAT

; 57   : {

  00000	56		 push	 esi

; 58   :     CRITICAL_DECLARE(lck->lck_lock);
; 59   : 
; 60   :     ASSERT(NULL != lck);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lck$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 23		 jne	 SHORT $LN9@Lck_lock
  00009	6a 3c		 push	 60			; 0000003cH
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LMEANPIC@NULL?5?$CB?$DN?5lck?$AA@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001a	e8 00 00 00 00	 call	 __printf
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00024	e8 00 00 00 00	 call	 _Sys_halt
  00029	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@Lck_lock:

; 61   :     while( Cpu_tas((int *)&lck->lck_status,0,1) )

  0002c	6a 01		 push	 1
  0002e	6a 00		 push	 0
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 _Cpu_tas_i
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	85 c0		 test	 eax, eax
  0003b	74 5b		 je	 SHORT $LN5@Lck_lock
  0003d	57		 push	 edi
  0003e	8b ff		 npad	 2
$LL6@Lck_lock:

; 62   :     {        
; 63   :         /*
; 64   :          *  可能存在多个进程同时不能获得锁
; 65   :          */
; 66   :         CRITICAL_BEGIN();

  00040	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00045	8b f8		 mov	 edi, eax

; 67   :         /*
; 68   :          *    如果尝试获得锁的进程优先级高于锁进程的优先级，则可能会出现优先级
; 69   :          *  反转。Lenix采用提高优先级的方式来避免这种情况
; 70   :          */
; 71   :         if( proc_current->proc_priority < lck->lck_priority )

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0004c	0f b6 40 4d	 movzx	 eax, BYTE PTR [eax+77]
  00050	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00053	7d 26		 jge	 SHORT $LN1@Lck_lock

; 72   :         {
; 73   :             /*
; 74   :              *  提高锁的优先级，提高到需要占用对象的进程中最高的优先级
; 75   :              */
; 76   :             lck->lck_priority = proc_current->proc_priority;
; 77   :             /*
; 78   :              *  将锁进程的优先级提高，并调整RSPL。
; 79   :              */
; 80   :             Sched_del(lck->lck_user);

  00055	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00058	51		 push	 ecx
  00059	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0005c	e8 00 00 00 00	 call	 _Sched_del

; 81   :             lck->lck_user->proc_priority = proc_current->proc_priority;

  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00066	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00069	8a 48 4d	 mov	 cl, BYTE PTR [eax+77]
  0006c	88 4a 4d	 mov	 BYTE PTR [edx+77], cl

; 82   :             Sched_add(lck->lck_user);

  0006f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 _Sched_add
  00078	83 c4 08	 add	 esp, 8
$LN1@Lck_lock:

; 83   :         }
; 84   :         CRITICAL_END();

  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 _Cpu_psw_set

; 85   :         Proc_sleep();

  00081	e8 00 00 00 00	 call	 _Proc_sleep
  00086	6a 01		 push	 1
  00088	6a 00		 push	 0
  0008a	56		 push	 esi
  0008b	e8 00 00 00 00	 call	 _Cpu_tas_i
  00090	83 c4 10	 add	 esp, 16			; 00000010H
  00093	85 c0		 test	 eax, eax
  00095	75 a9		 jne	 SHORT $LL6@Lck_lock
  00097	5f		 pop	 edi
$LN5@Lck_lock:

; 86   :     }
; 87   :     lck->lck_user         = proc_current;

  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0009d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 88   :     lck->lck_priority     = proc_current->proc_priority;

  000a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000a6	0f b6 51 4d	 movzx	 edx, BYTE PTR [ecx+77]
  000aa	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 89   :     lck->lck_user_prio    = proc_current->proc_priority;

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000b2	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  000b6	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000b9	5e		 pop	 esi

; 90   : }

  000ba	c3		 ret	 0
_Lck_lock ENDP
_TEXT	ENDS
PUBLIC	_Lck_free
EXTRN	_Proc_wakeup:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Lck_free
_TEXT	SEGMENT
_lck$ = 8						; size = 4
_Lck_free PROC						; COMDAT

; 110  : {

  00000	56		 push	 esi

; 111  :     CRITICAL_DECLARE(lck->lck_lock);
; 112  : 
; 113  :     ASSERT(NULL != lck);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lck$[esp]
  00005	85 f6		 test	 esi, esi
  00007	57		 push	 edi
  00008	75 23		 jne	 SHORT $LN7@Lck_free
  0000a	6a 71		 push	 113			; 00000071H
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0M@LMEANPIC@NULL?5?$CB?$DN?5lck?$AA@
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001b	e8 00 00 00 00	 call	 __printf
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00025	e8 00 00 00 00	 call	 _Sys_halt
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@Lck_free:

; 114  :     CRITICAL_BEGIN();

  0002d	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00032	8b f8		 mov	 edi, eax

; 115  :     if( proc_current->proc_priority != lck->lck_user_prio )

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00039	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  0003d	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00040	74 20		 je	 SHORT $LN1@Lck_free

; 116  :     {
; 117  :         Sched_del(proc_current);

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _Sched_del

; 118  :         proc_current->proc_priority = lck->lck_user_prio;

  00048	8a 56 08	 mov	 dl, BYTE PTR [esi+8]
  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00050	88 50 4d	 mov	 BYTE PTR [eax+77], dl

; 119  :         Sched_add(proc_current);

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _Sched_add
  0005f	83 c4 08	 add	 esp, 8
$LN1@Lck_free:

; 120  :     }
; 121  :     lck->lck_user         = NULL;

  00062	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 122  :     lck->lck_priority     = 0;

  00069	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 123  :     lck->lck_user_prio    = 0;

  00070	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 124  :     lck->lck_status       = 0;
; 125  :     CRITICAL_END();

  00077	57		 push	 edi
  00078	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0007e	e8 00 00 00 00	 call	 _Cpu_psw_set
  00083	83 c4 04	 add	 esp, 4
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi

; 126  :     Proc_wakeup();        

  00088	e9 00 00 00 00	 jmp	 _Proc_wakeup
_Lck_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GMALNMBL@OK?$CB?6?$AA@			; `string'
PUBLIC	??_C@_0BG@GIIALDJD@mutex?5initial?4?4?4?5?5?5?5?5?$AA@ ; `string'
PUBLIC	_Mutex_initial
EXTRN	__memzero:PROC
EXTRN	__printk:PROC
_BSS	SEGMENT
_mutex_pool DB	0400H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04GMALNMBL@OK?$CB?6?$AA@
CONST	SEGMENT
??_C@_04GMALNMBL@OK?$CB?6?$AA@ DB 'OK!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GIIALDJD@mutex?5initial?4?4?4?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@GIIALDJD@mutex?5initial?4?4?4?5?5?5?5?5?$AA@ DB 'mutex initial.'
	DB	'..     ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Mutex_initial
_TEXT	SEGMENT
_Mutex_initial PROC					; COMDAT

; 145  :     _printk("mutex initial...     ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@GIIALDJD@mutex?5initial?4?4?4?5?5?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 146  : #ifdef _CFG_SMP_
; 147  :     mutex_lock  = 0;
; 148  : #endif  /*  _CFG_SMP_   */
; 149  :     _memzero(mutex_pool,MUTEX_MAX * sizeof(mutex_t));

  0000a	68 00 04 00 00	 push	 1024			; 00000400H
  0000f	68 00 00 00 00	 push	 OFFSET _mutex_pool
  00014	e8 00 00 00 00	 call	 __memzero

; 150  :     _printk("OK!\n");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0001e	e8 00 00 00 00	 call	 __printk
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 151  : }

  00026	c3		 ret	 0
_Mutex_initial ENDP
_TEXT	ENDS
PUBLIC	??_C@_05IGMCOAJJ@mutex?$AA@			; `string'
;	COMDAT ??_C@_05IGMCOAJJ@mutex?$AA@
CONST	SEGMENT
??_C@_05IGMCOAJJ@mutex?$AA@ DB 'mutex', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Mutex_release
_TEXT	SEGMENT
___psw$ = 8						; size = 4
_mutex$ = 8						; size = 4
_Mutex_release PROC					; COMDAT

; 172  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 173  :     result_t                result      = RESULT_SUCCEED;
; 174  :     CRITICAL_DECLARE(mutex_lock);
; 175  : 
; 176  :     ASSERT(mutex);

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _mutex$[esp+4]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	3b f7		 cmp	 esi, edi
  0000b	75 26		 jne	 SHORT $LN19@Mutex_rele
  0000d	68 b0 00 00 00	 push	 176			; 000000b0H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_05IGMCOAJJ@mutex?$AA@
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00021	e8 00 00 00 00	 call	 __printf
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0002b	e8 00 00 00 00	 call	 _Sys_halt
  00030	83 c4 14	 add	 esp, 20			; 00000014H
$LN19@Mutex_rele:

; 177  :     /*
; 178  :      *  不是系统分配的对象，不能删除
; 179  :      */
; 180  :     if( mutex < MUTEX_FIRST || mutex > MUTEX_LAST)

  00033	81 fe 00 00 00
	00		 cmp	 esi, OFFSET _mutex_pool
  00039	72 53		 jb	 SHORT $LN14@Mutex_rele
  0003b	81 fe e0 03 00
	00		 cmp	 esi, OFFSET _mutex_pool+992
  00041	77 4b		 ja	 SHORT $LN14@Mutex_rele

; 184  :         goto mutex_destroy_end;
; 185  :     }
; 186  :     CRITICAL_BEGIN();

  00043	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 187  :     /*
; 188  :      *  有进程在等待的，不能销毁
; 189  :      */
; 190  :     if( mutex->mtx_wait.pl_list )

  00048	39 7e 1c	 cmp	 DWORD PTR [esi+28], edi
  0004b	8b d8		 mov	 ebx, eax
  0004d	74 1c		 je	 SHORT $LN8@Mutex_rele

; 191  :     {
; 192  :         PROC_SET_ERR(ERR_MUTEX_BUSY);

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00054	bf 03 03 00 00	 mov	 edi, 771		; 00000303H

; 199  :     }
; 200  : mutex_destroy_end:
; 201  :     CRITICAL_END();

  00059	53		 push	 ebx
  0005a	89 78 38	 mov	 DWORD PTR [eax+56], edi
  0005d	e8 00 00 00 00	 call	 _Cpu_psw_set
  00062	83 c4 04	 add	 esp, 4

; 202  : 
; 203  :     return result;

  00065	8b c7		 mov	 eax, edi
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx

; 204  : }

  0006a	c3		 ret	 0
$LN8@Mutex_rele:

; 193  :         result = ERR_MUTEX_BUSY;
; 194  :     }
; 195  :     else
; 196  :     {
; 197  :         MUTEX_INITIAL(mutex);

  0006b	6a 20		 push	 32			; 00000020H
  0006d	56		 push	 esi
  0006e	e8 00 00 00 00	 call	 __memzero

; 198  :         PROC_NO_ERR();

  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00079	83 c4 08	 add	 esp, 8

; 199  :     }
; 200  : mutex_destroy_end:
; 201  :     CRITICAL_END();

  0007c	53		 push	 ebx
  0007d	89 79 38	 mov	 DWORD PTR [ecx+56], edi
  00080	e8 00 00 00 00	 call	 _Cpu_psw_set
  00085	83 c4 04	 add	 esp, 4

; 202  : 
; 203  :     return result;

  00088	8b c7		 mov	 eax, edi
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx

; 204  : }

  0008d	c3		 ret	 0
$LN14@Mutex_rele:

; 181  :     {
; 182  :         PROC_SET_ERR(ERR_MUTEX_OUT_OF_POOL);

  0008e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current

; 183  :         result = ERR_MUTEX_OUT_OF_POOL;

  00094	8b 5c 24 10	 mov	 ebx, DWORD PTR ___psw$[esp+8]
  00098	bf 02 03 00 00	 mov	 edi, 770		; 00000302H

; 199  :     }
; 200  : mutex_destroy_end:
; 201  :     CRITICAL_END();

  0009d	53		 push	 ebx
  0009e	89 7a 38	 mov	 DWORD PTR [edx+56], edi
$mutex_destroy_end$1802:
  000a1	e8 00 00 00 00	 call	 _Cpu_psw_set
  000a6	83 c4 04	 add	 esp, 4

; 202  : 
; 203  :     return result;

  000a9	8b c7		 mov	 eax, edi
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx

; 204  : }

  000ae	c3		 ret	 0
_Mutex_release ENDP
_TEXT	ENDS
PUBLIC	_Mutex_create
EXTRN	_Koum_add:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Mutex_create
_TEXT	SEGMENT
_Mutex_create PROC					; COMDAT

; 226  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 227  :     int             i       = 0;

  00003	33 db		 xor	 ebx, ebx
  00005	33 ff		 xor	 edi, edi

; 228  :     mutex_t       * mtx     = mutex_pool;

  00007	be 00 00 00 00	 mov	 esi, OFFSET _mutex_pool

; 229  :     handle_t        handle  = INVALID_HANDLE;
; 230  :     CRITICAL_DECLARE(mutex_lock);
; 231  : 
; 232  :     /*
; 233  :      *  遍历系统互斥对象池，查找可用的互斥对象
; 234  :      */
; 235  :     CRITICAL_BEGIN();

  0000c	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00011	b9 01 00 00 00	 mov	 ecx, 1
$LL20@Mutex_crea:

; 237  :     {
; 238  :         if( MTX_FLAG_USED & mtx->mtx_flag )

  00016	84 4e 0c	 test	 BYTE PTR [esi+12], cl
  00019	74 0c		 je	 SHORT $LN17@Mutex_crea
  0001b	03 f9		 add	 edi, ecx
  0001d	83 c6 20	 add	 esi, 32			; 00000020H
  00020	83 ff 20	 cmp	 edi, 32			; 00000020H
  00023	7c f1		 jl	 SHORT $LL20@Mutex_crea

; 236  :     for( ; i < MUTEX_MAX ; i++,mtx++)

  00025	eb 03		 jmp	 SHORT $LN18@Mutex_crea
$LN17@Mutex_crea:

; 239  :             continue;
; 240  :         mtx->mtx_flag |= MTX_FLAG_USED;

  00027	09 4e 0c	 or	 DWORD PTR [esi+12], ecx
$LN18@Mutex_crea:

; 241  :         break;
; 242  :     }
; 243  :     CRITICAL_END();

  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _Cpu_psw_set
  00030	83 c4 04	 add	 esp, 4

; 244  :     /*
; 245  :      *  检测是否分配到互斥对象，如果分配到，则要加入内核对象表
; 246  :      */
; 247  :     if( i < MUTEX_MAX )

  00033	83 ff 20	 cmp	 edi, 32			; 00000020H
  00036	7d 51		 jge	 SHORT $LN3@Mutex_crea

; 248  :     {
; 249  :         handle = Koum_add(mtx,Mutex_release,kot_mutex,HANDLE_ATTR_RDWR);

  00038	6a 03		 push	 3
  0003a	6a 02		 push	 2
  0003c	68 00 00 00 00	 push	 OFFSET _Mutex_release
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 _Koum_add
  00047	8b f8		 mov	 edi, eax
  00049	83 c4 10	 add	 esp, 16			; 00000010H

; 250  :         /*
; 251  :          *  加入系统内核对象表失败，需要释放已分配到的互斥对象
; 252  :          */
; 253  :         if( INVALID_HANDLE == handle )

  0004c	3b fb		 cmp	 edi, ebx
  0004e	75 2a		 jne	 SHORT $LN7@Mutex_crea

; 254  :         {
; 255  :             CRITICAL_BEGIN();

  00050	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 256  :             _memzero(mtx,sizeof(mutex_t));

  00055	6a 20		 push	 32			; 00000020H
  00057	56		 push	 esi
  00058	8b d8		 mov	 ebx, eax
  0005a	e8 00 00 00 00	 call	 __memzero

; 257  :             CRITICAL_END();

  0005f	53		 push	 ebx
  00060	e8 00 00 00 00	 call	 _Cpu_psw_set

; 258  :             PROC_SET_ERR(ERR_MUTEX_KOUM_ADD);

  00065	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	c7 40 38 04 03
	00 00		 mov	 DWORD PTR [eax+56], 772	; 00000304H

; 265  : 
; 266  :     return handle ;

  00074	8b c7		 mov	 eax, edi
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx

; 267  : }

  00079	c3		 ret	 0
$LN7@Mutex_crea:

; 259  :         }
; 260  :         else
; 261  :             PROC_NO_ERR();

  0007a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current

; 265  : 
; 266  :     return handle ;

  00080	8b c7		 mov	 eax, edi
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	89 59 38	 mov	 DWORD PTR [ecx+56], ebx
  00087	5b		 pop	 ebx

; 267  : }

  00088	c3		 ret	 0
$LN3@Mutex_crea:

; 262  :     }
; 263  :     else
; 264  :         PROC_SET_ERR(ERR_MUTEX_EXHAUST);

  00089	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi

; 265  : 
; 266  :     return handle ;

  00091	8b c3		 mov	 eax, ebx
  00093	c7 42 38 01 03
	00 00		 mov	 DWORD PTR [edx+56], 769	; 00000301H
  0009a	5b		 pop	 ebx

; 267  : }

  0009b	c3		 ret	 0
_Mutex_create ENDP
_TEXT	ENDS
PUBLIC	??_C@_06NCGDPKCC@handle?$AA@			; `string'
PUBLIC	_Mutex_get
EXTRN	_Proc_sched:PROC
EXTRN	_Proc_wait_on:PROC
EXTRN	_Koum_handle_object:PROC
;	COMDAT ??_C@_06NCGDPKCC@handle?$AA@
CONST	SEGMENT
??_C@_06NCGDPKCC@handle?$AA@ DB 'handle', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Mutex_get
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_Mutex_get PROC						; COMDAT

; 291  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 292  :     mutex_t       * mutex   = Koum_handle_object(handle);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _handle$[esp+4]
  00006	57		 push	 edi
  00007	e8 00 00 00 00	 call	 _Koum_handle_object
  0000c	83 c4 04	 add	 esp, 4

; 293  :     CRITICAL_DECLARE(mutex->mtx_lock);
; 294  : 
; 295  :     ASSERT(handle);

  0000f	85 ff		 test	 edi, edi
  00011	8b f0		 mov	 esi, eax
  00013	75 2c		 jne	 SHORT $LN17@Mutex_get
  00015	68 27 01 00 00	 push	 295			; 00000127H
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_06NCGDPKCC@handle?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00029	e8 00 00 00 00	 call	 __printf
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00033	e8 00 00 00 00	 call	 _Sys_halt
  00038	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@Mutex_get:
  0003b	5f		 pop	 edi

; 301  :         return RESULT_FAILED;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5e		 pop	 esi

; 328  : }

  00040	c3		 ret	 0
$LN17@Mutex_get:

; 296  : 
; 297  :     /*
; 298  :      *  检测对象是否有效
; 299  :      */
; 300  :     if( INVALID_HANDLE == handle || NULL == mutex )

  00041	85 f6		 test	 esi, esi
  00043	74 f6		 je	 SHORT $LN7@Mutex_get

; 302  :     while( Cpu_tas((int *)&mutex->mtx_status,0,1) )

  00045	6a 01		 push	 1
  00047	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  0004a	6a 00		 push	 0
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 _Cpu_tas_i
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	85 c0		 test	 eax, eax
  00057	74 73		 je	 SHORT $LN5@Mutex_get
  00059	53		 push	 ebx
  0005a	55		 push	 ebp
  0005b	8d 6e 1c	 lea	 ebp, DWORD PTR [esi+28]
  0005e	8b ff		 npad	 2
$LL6@Mutex_get:

; 303  :     {
; 304  :         CRITICAL_BEGIN();

  00060	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00065	8b d8		 mov	 ebx, eax

; 305  :         /*
; 306  :          *  处理优先级反转问题，有更高优先级的进程请求互斥量
; 307  :          */
; 308  :         if( proc_current->proc_priority < mutex->mtx_priority )

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0006c	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  00070	3b 4e 18	 cmp	 ecx, DWORD PTR [esi+24]
  00073	7d 31		 jge	 SHORT $LN1@Mutex_get

; 309  :         {
; 310  :             /*
; 311  :              *    将占用互斥量的进程提高到该进程，也就是将该进程改至更高优先级
; 312  :              *  的列表中注意，这里并不要求立即调度
; 313  :              */
; 314  :             Sched_del(mutex->mtx_user);

  00075	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _Sched_del

; 315  :             mutex->mtx_user->proc_priority = proc_current->proc_priority;

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00084	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00087	8a 51 4d	 mov	 dl, BYTE PTR [ecx+77]
  0008a	88 50 4d	 mov	 BYTE PTR [eax+77], dl

; 316  :             Sched_add(mutex->mtx_user);

  0008d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _Sched_add

; 317  :             mutex->mtx_priority = proc_current->proc_priority;

  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0009c	0f b6 51 4d	 movzx	 edx, BYTE PTR [ecx+77]
  000a0	83 c4 08	 add	 esp, 8
  000a3	89 56 18	 mov	 DWORD PTR [esi+24], edx
$LN1@Mutex_get:

; 318  :         }
; 319  :         Proc_wait_on(&mutex->mtx_wait);

  000a6	55		 push	 ebp
  000a7	e8 00 00 00 00	 call	 _Proc_wait_on

; 320  :         CRITICAL_END();

  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 _Cpu_psw_set

; 321  :         Proc_sched(0);

  000b2	6a 00		 push	 0
  000b4	e8 00 00 00 00	 call	 _Proc_sched
  000b9	6a 01		 push	 1
  000bb	6a 00		 push	 0
  000bd	57		 push	 edi
  000be	e8 00 00 00 00	 call	 _Cpu_tas_i
  000c3	83 c4 18	 add	 esp, 24			; 00000018H
  000c6	85 c0		 test	 eax, eax
  000c8	75 96		 jne	 SHORT $LL6@Mutex_get
  000ca	5d		 pop	 ebp
  000cb	5b		 pop	 ebx
$LN5@Mutex_get:

; 322  :     }
; 323  :     mutex->mtx_user      = proc_current;

  000cc	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000d1	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 324  :     mutex->mtx_user_prio = proc_current->proc_priority;

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000da	0f b6 51 4d	 movzx	 edx, BYTE PTR [ecx+77]
  000de	89 56 14	 mov	 DWORD PTR [esi+20], edx

; 325  :     mutex->mtx_priority  = proc_current->proc_priority;

  000e1	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000e6	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  000ea	5f		 pop	 edi
  000eb	89 4e 18	 mov	 DWORD PTR [esi+24], ecx

; 326  : 
; 327  :     return RESULT_SUCCEED;

  000ee	33 c0		 xor	 eax, eax
  000f0	5e		 pop	 esi

; 328  : }

  000f1	c3		 ret	 0
_Mutex_get ENDP
_TEXT	ENDS
PUBLIC	_Mutex_put
EXTRN	_proc_need_sched:DWORD
EXTRN	_Proc_resume_on:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Mutex_put
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_Mutex_put PROC						; COMDAT

; 349  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 350  :     mutex_t       * mutex   = Koum_handle_object(handle);

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _handle$[esp+8]
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 _Koum_handle_object

; 351  :     CRITICAL_DECLARE(mutex->mtx_lock);
; 352  : 
; 353  :     ASSERT(handle);

  0000d	33 db		 xor	 ebx, ebx
  0000f	83 c4 04	 add	 esp, 4
  00012	3b fb		 cmp	 edi, ebx
  00014	8b f0		 mov	 esi, eax
  00016	75 2d		 jne	 SHORT $LN17@Mutex_put
  00018	68 61 01 00 00	 push	 353			; 00000161H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_06NCGDPKCC@handle?$AA@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0002c	e8 00 00 00 00	 call	 __printf
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00036	e8 00 00 00 00	 call	 _Sys_halt
  0003b	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@Mutex_put:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 358  :         return RESULT_FAILED;

  00040	83 c8 ff	 or	 eax, -1
  00043	5b		 pop	 ebx

; 380  : }

  00044	c3		 ret	 0
$LN17@Mutex_put:

; 354  :     /*
; 355  :      *  检测对象是否有效
; 356  :      */
; 357  :     if( INVALID_HANDLE == handle || NULL == mutex )

  00045	3b f3		 cmp	 esi, ebx
  00047	74 f5		 je	 SHORT $LN9@Mutex_put

; 359  :     CRITICAL_BEGIN();

  00049	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0004e	8b f8		 mov	 edi, eax

; 360  :     /*
; 361  :      *    如果互斥量占用进程的优先级与原始的优先级不同，则说明发生了优先级变
; 362  :      *  更，需要变回原来的优先级
; 363  :      */
; 364  :     if( mutex->mtx_user_prio != proc_current->proc_priority )

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00055	0f b6 48 4d	 movzx	 ecx, BYTE PTR [eax+77]
  00059	39 4e 14	 cmp	 DWORD PTR [esi+20], ecx
  0005c	74 21		 je	 SHORT $LN5@Mutex_put

; 365  :     {
; 366  :         /*  将优先级改回原始优先级  */
; 367  :         Sched_del(mutex->mtx_user);

  0005e	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _Sched_del

; 368  :         proc_current->proc_priority = mutex->mtx_user_prio;

  00067	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00070	88 41 4d	 mov	 BYTE PTR [ecx+77], al

; 369  :         Sched_add(mutex->mtx_user);

  00073	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _Sched_add
  0007c	83 c4 08	 add	 esp, 8
$LN5@Mutex_put:

; 370  :     }
; 371  :     mutex->mtx_user_prio    = 0;

  0007f	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 372  :     mutex->mtx_priority     = 0;

  00082	89 5e 18	 mov	 DWORD PTR [esi+24], ebx

; 373  :     mutex->mtx_status       = 0;

  00085	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 374  :     mutex->mtx_user         = NULL;

  00088	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 375  :     /*  唤醒所有等待的的进程    */
; 376  :     Proc_resume_on(&mutex->mtx_wait);

  0008b	83 c6 1c	 add	 esi, 28			; 0000001cH
  0008e	56		 push	 esi
  0008f	e8 00 00 00 00	 call	 _Proc_resume_on

; 377  :     CRITICAL_END();

  00094	57		 push	 edi
  00095	e8 00 00 00 00	 call	 _Cpu_psw_set

; 378  :     SCHED(0);

  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_need_sched
  0009f	83 c4 08	 add	 esp, 8
  000a2	85 c0		 test	 eax, eax
  000a4	74 09		 je	 SHORT $LN3@Mutex_put
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 _Proc_sched
  000ac	83 c4 04	 add	 esp, 4
$LN3@Mutex_put:
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi

; 379  :     return RESULT_SUCCEED;

  000b1	33 c0		 xor	 eax, eax
  000b3	5b		 pop	 ebx

; 380  : }

  000b4	c3		 ret	 0
_Mutex_put ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@LIHDLMGA@Sema?5initial?4?4?4?5?5?5?$AA@ ; `string'
PUBLIC	_Sema_initial
_BSS	SEGMENT
_sema_pool DB	0280H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@LIHDLMGA@Sema?5initial?4?4?4?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BD@LIHDLMGA@Sema?5initial?4?4?4?5?5?5?$AA@ DB 'Sema initial...   ', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sema_initial
_TEXT	SEGMENT
_Sema_initial PROC					; COMDAT

; 402  :     _printk("Sema initial...   ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LIHDLMGA@Sema?5initial?4?4?4?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 403  :     _memzero(sema_pool,SEMA_MAX * sizeof(semaphore_t));

  0000a	68 80 02 00 00	 push	 640			; 00000280H
  0000f	68 00 00 00 00	 push	 OFFSET _sema_pool
  00014	e8 00 00 00 00	 call	 __memzero

; 404  : 
; 405  : #ifdef _CFG_SMP_
; 406  :     sema_lock = 0;
; 407  : #endif  /*  _CFG_SMP_   */
; 408  :     _printk("OK!\n");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0001e	e8 00 00 00 00	 call	 __printk
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 409  : }

  00026	c3		 ret	 0
_Sema_initial ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LMLKNLAI@NULL?5?$CB?$DN?5sema?$AA@	; `string'
;	COMDAT ??_C@_0N@LMLKNLAI@NULL?5?$CB?$DN?5sema?$AA@
CONST	SEGMENT
??_C@_0N@LMLKNLAI@NULL?5?$CB?$DN?5sema?$AA@ DB 'NULL != sema', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sema_release
_TEXT	SEGMENT
_sema$ = 8						; size = 4
_Sema_release PROC					; COMDAT

; 430  : {

  00000	56		 push	 esi

; 431  :     CRITICAL_DECLARE(sema_lock);
; 432  : 
; 433  :     ASSERT( NULL != sema );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _sema$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 36		 jne	 SHORT $LN19@Sema_relea
  00009	68 b1 01 00 00	 push	 433			; 000001b1H
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LMLKNLAI@NULL?5?$CB?$DN?5sema?$AA@
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001d	e8 00 00 00 00	 call	 __printf
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00027	e8 00 00 00 00	 call	 _Sys_halt

; 434  : #ifdef _CFG_CHECK_PARAMETER_
; 435  :     if( NULL == sema)
; 436  :     {
; 437  :         PROC_SET_LAST_ERR(ERR_NULL_POINTER);

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00032	83 c4 14	 add	 esp, 20			; 00000014H
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  0003d	5e		 pop	 esi

; 463  : }

  0003e	c3		 ret	 0
$LN19@Sema_relea:

; 438  :         return ERR_NULL_POINTER;
; 439  :     }
; 440  : #endif  /*  _CFG_CHECK_PARAMETER_  */
; 441  :     /*
; 442  :      *  不处理池以外的对象
; 443  :      */
; 444  :     if( sema < SEMA_FIRST || sema > SEMA_LAST )

  0003f	81 fe 00 00 00
	00		 cmp	 esi, OFFSET _sema_pool
  00045	72 58		 jb	 SHORT $LN13@Sema_relea
  00047	81 fe 6c 02 00
	00		 cmp	 esi, OFFSET _sema_pool+620
  0004d	77 50		 ja	 SHORT $LN13@Sema_relea
  0004f	57		 push	 edi

; 447  :         return ERR_SEMA_NOT_SYS_CREATE;
; 448  :     }
; 449  :     CRITICAL_BEGIN();

  00050	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 450  :     /*
; 451  :      *  还有进程在等待信号量，不能销毁
; 452  :      */
; 453  :     if( sema->sema_count < sema->sema_max )

  00055	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00058	3b 56 0c	 cmp	 edx, DWORD PTR [esi+12]
  0005b	8b f8		 mov	 edi, eax
  0005d	7d 1d		 jge	 SHORT $LN7@Sema_relea

; 454  :     {
; 455  :         PROC_SET_LAST_ERR(ERR_SEMA_BUSY);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current

; 456  :         CRITICAL_END();

  00064	57		 push	 edi
  00065	c7 40 38 04 02
	00 00		 mov	 DWORD PTR [eax+56], 516	; 00000204H
  0006c	e8 00 00 00 00	 call	 _Cpu_psw_set
  00071	83 c4 04	 add	 esp, 4
  00074	5f		 pop	 edi

; 457  :         return ERR_SEMA_BUSY;

  00075	b8 04 02 00 00	 mov	 eax, 516		; 00000204H
  0007a	5e		 pop	 esi

; 463  : }

  0007b	c3		 ret	 0
$LN7@Sema_relea:

; 458  :     }
; 459  :     SEMA_ZERO(sema);

  0007c	6a 14		 push	 20			; 00000014H
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 __memzero

; 460  :     CRITICAL_END();

  00084	57		 push	 edi
  00085	e8 00 00 00 00	 call	 _Cpu_psw_set

; 461  :     PROC_NO_ERR();

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	5f		 pop	 edi
  00094	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 462  :     return RESULT_SUCCEED;

  0009b	33 c0		 xor	 eax, eax
  0009d	5e		 pop	 esi

; 463  : }

  0009e	c3		 ret	 0
$LN13@Sema_relea:

; 445  :     {
; 446  :         PROC_SET_LAST_ERR(ERR_SEMA_NOT_SYS_CREATE);

  0009f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000a5	b8 02 02 00 00	 mov	 eax, 514		; 00000202H
  000aa	89 42 38	 mov	 DWORD PTR [edx+56], eax
  000ad	5e		 pop	 esi

; 463  : }

  000ae	c3		 ret	 0
_Sema_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@GBAFANDI@max?5?$DO?50?5?$CG?$CG?5max?5?$DM?5SEMA_LIMIT?$AA@ ; `string'
PUBLIC	_Sema_create
;	COMDAT ??_C@_0BM@GBAFANDI@max?5?$DO?50?5?$CG?$CG?5max?5?$DM?5SEMA_LIMIT?$AA@
CONST	SEGMENT
??_C@_0BM@GBAFANDI@max?5?$DO?50?5?$CG?$CG?5max?5?$DM?5SEMA_LIMIT?$AA@ DB 'm'
	DB	'ax > 0 && max < SEMA_LIMIT', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sema_create
_TEXT	SEGMENT
___psw$ = 8						; size = 4
_max$ = 8						; size = 4
_Sema_create PROC					; COMDAT

; 483  : {

  00000	53		 push	 ebx

; 484  :     int             i       = 0;
; 485  :     handle_t        handle  = INVALID_HANDLE;
; 486  :     semaphore_t   * sema    = SEMA_FIRST;
; 487  :     CRITICAL_DECLARE(sema_lock);
; 488  :     
; 489  :     ASSERT( max > 0 && max < SEMA_LIMIT);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _max$[esp]
  00005	55		 push	 ebp
  00006	33 ed		 xor	 ebp, ebp
  00008	85 db		 test	 ebx, ebx
  0000a	56		 push	 esi
  0000b	be 00 00 00 00	 mov	 esi, OFFSET _sema_pool
  00010	7e 08		 jle	 SHORT $LN30@Sema_creat
  00012	81 fb 30 75 00
	00		 cmp	 ebx, 30000		; 00007530H
  00018	7c 40		 jl	 SHORT $LN25@Sema_creat
$LN30@Sema_creat:
  0001a	68 e9 01 00 00	 push	 489			; 000001e9H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GBAFANDI@max?5?$DO?50?5?$CG?$CG?5max?5?$DM?5SEMA_LIMIT?$AA@
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0002e	e8 00 00 00 00	 call	 __printf
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00038	e8 00 00 00 00	 call	 _Sys_halt
  0003d	83 c4 14	 add	 esp, 20			; 00000014H

; 490  :     /*
; 491  :      *  对信号数量进行限制
; 492  :      */
; 493  :     if( max > SEMA_LIMIT)

  00040	81 fb 30 75 00
	00		 cmp	 ebx, 30000		; 00007530H
  00046	7e 12		 jle	 SHORT $LN25@Sema_creat

; 494  :     {
; 495  :         PROC_SET_ERR(ERR_SEMA_MAX_OVERFLOW);

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0004d	5e		 pop	 esi
  0004e	5d		 pop	 ebp
  0004f	c7 40 38 03 02
	00 00		 mov	 DWORD PTR [eax+56], 515	; 00000203H

; 496  :         return INVALID_HANDLE;

  00056	33 c0		 xor	 eax, eax
  00058	5b		 pop	 ebx

; 529  : }

  00059	c3		 ret	 0
$LN25@Sema_creat:
  0005a	57		 push	 edi

; 497  :     }
; 498  : 
; 499  :     CRITICAL_BEGIN();

  0005b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00060	89 44 24 14	 mov	 DWORD PTR ___psw$[esp+12], eax

; 500  :     /*
; 501  :      *  遍历信号对象池，查找可用对象，以信号最大值为0作为可用的依据
; 502  :      */
; 503  :     for( i = 0 ; i < SEMA_MAX ; i++,sema++)

  00064	33 ff		 xor	 edi, edi
$LL22@Sema_creat:

; 504  :     {
; 505  :         if( 0 == sema->sema_max )

  00066	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  00069	74 0d		 je	 SHORT $LN38@Sema_creat
  0006b	83 c7 01	 add	 edi, 1
  0006e	83 c6 14	 add	 esi, 20			; 00000014H
  00071	83 ff 20	 cmp	 edi, 32			; 00000020H
  00074	7c f0		 jl	 SHORT $LL22@Sema_creat
  00076	eb 11		 jmp	 SHORT $LN20@Sema_creat
$LN38@Sema_creat:

; 506  :         {
; 507  :             SEMA_INITIAL(sema,max);

  00078	6a 14		 push	 20			; 00000014H
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 __memzero
  00080	83 c4 08	 add	 esp, 8
  00083	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00086	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
$LN20@Sema_creat:

; 508  :             break;
; 509  :         }
; 510  :     }
; 511  :     CRITICAL_END();

  00089	8b 4c 24 14	 mov	 ecx, DWORD PTR ___psw$[esp+12]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 _Cpu_psw_set
  00093	83 c4 04	 add	 esp, 4

; 512  :     if( i >= SEMA_MAX )

  00096	83 ff 20	 cmp	 edi, 32			; 00000020H
  00099	7c 14		 jl	 SHORT $LN15@Sema_creat

; 513  :     {
; 514  :         PROC_SET_ERR(ERR_SEMA_EXHAUST);

  0009b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi

; 526  :     }
; 527  : sema_create_end:
; 528  :     return handle;

  000a3	8b c5		 mov	 eax, ebp
  000a5	5d		 pop	 ebp
  000a6	c7 42 38 01 02
	00 00		 mov	 DWORD PTR [edx+56], 513	; 00000201H
  000ad	5b		 pop	 ebx

; 529  : }

  000ae	c3		 ret	 0
$LN15@Sema_creat:

; 515  :         goto sema_create_end;
; 516  :     }
; 517  :     handle = Koum_add(sema,Sema_release,kot_sema,HANDLE_ATTR_RDWR);

  000af	6a 03		 push	 3
  000b1	6a 03		 push	 3
  000b3	68 00 00 00 00	 push	 OFFSET _Sema_release
  000b8	56		 push	 esi
  000b9	e8 00 00 00 00	 call	 _Koum_add
  000be	8b e8		 mov	 ebp, eax
  000c0	83 c4 10	 add	 esp, 16			; 00000010H

; 518  :     if( INVALID_HANDLE != handle )

  000c3	85 ed		 test	 ebp, ebp
  000c5	74 13		 je	 SHORT $LN6@Sema_creat

; 519  :         PROC_NO_ERR();

  000c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 526  :     }
; 527  : sema_create_end:
; 528  :     return handle;

  000d5	8b c5		 mov	 eax, ebp
  000d7	5d		 pop	 ebp
  000d8	5b		 pop	 ebx

; 529  : }

  000d9	c3		 ret	 0
$LN6@Sema_creat:

; 520  :     else
; 521  :     {
; 522  :         CRITICAL_BEGIN();

  000da	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 523  :         SEMA_ZERO(sema);

  000df	6a 14		 push	 20			; 00000014H
  000e1	56		 push	 esi
  000e2	8b f8		 mov	 edi, eax
  000e4	e8 00 00 00 00	 call	 __memzero

; 524  :         CRITICAL_END();

  000e9	57		 push	 edi
  000ea	e8 00 00 00 00	 call	 _Cpu_psw_set

; 525  :         PROC_SET_ERR(ERR_SEMA_KOUM_ADD);

  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	5f		 pop	 edi
  000f9	5e		 pop	 esi

; 526  :     }
; 527  : sema_create_end:
; 528  :     return handle;

  000fa	8b c5		 mov	 eax, ebp
  000fc	5d		 pop	 ebp
  000fd	c7 41 38 05 02
	00 00		 mov	 DWORD PTR [ecx+56], 517	; 00000205H
$sema_create_end$1956:
  00104	5b		 pop	 ebx

; 529  : }

  00105	c3		 ret	 0
_Sema_create ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@ ; `string'
PUBLIC	_Sema_down
;	COMDAT ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
CONST	SEGMENT
??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@ DB 'INVALID_HAND'
	DB	'LE != handle', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sema_down
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_Sema_down PROC						; COMDAT

; 551  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 552  :     semaphore_t   * sema    = Koum_handle_object(handle);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _handle$[esp+4]
  00006	57		 push	 edi
  00007	e8 00 00 00 00	 call	 _Koum_handle_object
  0000c	83 c4 04	 add	 esp, 4

; 553  :     CRITICAL_DECLARE(sema->sema_lock);
; 554  : 
; 555  :     ASSERT( INVALID_HANDLE != handle );

  0000f	85 ff		 test	 edi, edi
  00011	8b f0		 mov	 esi, eax
  00013	75 2c		 jne	 SHORT $LN13@Sema_down
  00015	68 2b 02 00 00	 push	 555			; 0000022bH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00029	e8 00 00 00 00	 call	 __printf
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00033	e8 00 00 00 00	 call	 _Sys_halt
  00038	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@Sema_down:
  0003b	5f		 pop	 edi

; 558  :         return RESULT_FAILED;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5e		 pop	 esi

; 578  : }

  00040	c3		 ret	 0
$LN13@Sema_down:

; 556  : #ifdef _CFG_CHECK_PARAMETER_
; 557  :     if( INVALID_HANDLE == handle || NULL == sema )

  00041	85 f6		 test	 esi, esi
  00043	74 f6		 je	 SHORT $LN5@Sema_down

; 559  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 560  :     CRITICAL_BEGIN();

  00045	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 561  : #ifdef d_CFG_DEBUG_
; 562  :     _printf("%s semaphore down count: %d \n",
; 563  :         proc_current->proc_name,sema->sema_count - 1);
; 564  : #endif
; 565  :     if( --sema->sema_count < 0 )

  0004a	83 46 08 ff	 add	 DWORD PTR [esi+8], -1
  0004e	8b f8		 mov	 edi, eax
  00050	79 29		 jns	 SHORT $LN1@Sema_down

; 566  :     {
; 567  :         /*  信号计数器小于0说明资源已经耗尽，进程需要等待资源可用。*/
; 568  :         Sched_del(proc_current);

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _Sched_del

; 569  :         Proc_wait_on(&sema->sema_wait);

  0005d	83 c6 10	 add	 esi, 16			; 00000010H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 _Proc_wait_on

; 570  :         CRITICAL_END();

  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 _Cpu_psw_set

; 571  :         Proc_sched(0);

  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 _Proc_sched
  00073	83 c4 10	 add	 esp, 16			; 00000010H
  00076	5f		 pop	 edi

; 572  :         /*  到达这里说明进程已经恢复运行，也说明资源被释放了一个，可以使用。*/
; 573  :         return RESULT_SUCCEED;

  00077	33 c0		 xor	 eax, eax
  00079	5e		 pop	 esi

; 578  : }

  0007a	c3		 ret	 0
$LN1@Sema_down:

; 574  :     }
; 575  :     CRITICAL_END();   

  0007b	57		 push	 edi
  0007c	e8 00 00 00 00	 call	 _Cpu_psw_set
  00081	83 c4 04	 add	 esp, 4
  00084	5f		 pop	 edi

; 576  : 
; 577  :     return RESULT_SUCCEED;

  00085	33 c0		 xor	 eax, eax
  00087	5e		 pop	 esi

; 578  : }

  00088	c3		 ret	 0
_Sema_down ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@HAKIFBNH@semaphore?5large?5than?5max?$CB?$AA@ ; `string'
PUBLIC	_Sema_up
EXTRN	_Proc_resume_max_on:PROC
;	COMDAT ??_C@_0BK@HAKIFBNH@semaphore?5large?5than?5max?$CB?$AA@
CONST	SEGMENT
??_C@_0BK@HAKIFBNH@semaphore?5large?5than?5max?$CB?$AA@ DB 'semaphore lar'
	DB	'ge than max!', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Sema_up
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_Sema_up PROC						; COMDAT

; 602  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 603  :     semaphore_t   * sema    = Koum_handle_object(handle);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _handle$[esp+4]
  00006	57		 push	 edi
  00007	e8 00 00 00 00	 call	 _Koum_handle_object
  0000c	83 c4 04	 add	 esp, 4

; 604  :     CRITICAL_DECLARE(sema->sema_lock);
; 605  : 
; 606  :     ASSERT( INVALID_HANDLE != handle );

  0000f	85 ff		 test	 edi, edi
  00011	8b f0		 mov	 esi, eax
  00013	75 2c		 jne	 SHORT $LN18@Sema_up
  00015	68 5e 02 00 00	 push	 606			; 0000025eH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00029	e8 00 00 00 00	 call	 __printf
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00033	e8 00 00 00 00	 call	 _Sys_halt
  00038	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Sema_up:

; 609  :         return RESULT_FAILED;

  0003b	83 c8 ff	 or	 eax, -1
$LN2@Sema_up:
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 625  : }

  00040	c3		 ret	 0
$LN18@Sema_up:

; 607  : #ifdef _CFG_CHECK_PARAMETER_
; 608  :     if( INVALID_HANDLE == handle || NULL == sema )

  00041	85 f6		 test	 esi, esi
  00043	74 f6		 je	 SHORT $LN10@Sema_up

; 610  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 611  : 
; 612  :     CRITICAL_BEGIN();

  00045	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 613  : #ifdef d_CFG_DEBUG_
; 614  :     _printf("%s semaphore up count: %d \n",
; 615  :         proc_current->proc_name,sema->sema_count + 1);
; 616  : #endif
; 617  :     /*  超过最大值，肯定有错，死机  */
; 618  :     if( ++sema->sema_count > sema->sema_max )

  0004a	83 46 08 01	 add	 DWORD PTR [esi+8], 1
  0004e	8b f8		 mov	 edi, eax
  00050	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00053	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00056	7e 0d		 jle	 SHORT $LN6@Sema_up

; 619  :         Sys_halt("semaphore large than max!");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@HAKIFBNH@semaphore?5large?5than?5max?$CB?$AA@
  0005d	e8 00 00 00 00	 call	 _Sys_halt
  00062	83 c4 04	 add	 esp, 4
$LN6@Sema_up:

; 620  :     /*  小于1，说明有等待资源的进程，需要唤醒   */
; 621  :     if( sema->sema_count < 1 )

  00065	83 7e 08 01	 cmp	 DWORD PTR [esi+8], 1
  00069	7d 0c		 jge	 SHORT $LN5@Sema_up

; 622  :         Proc_resume_max_on(&sema->sema_wait);

  0006b	83 c6 10	 add	 esi, 16			; 00000010H
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 _Proc_resume_max_on
  00074	83 c4 04	 add	 esp, 4
$LN5@Sema_up:

; 623  :     CRITICAL_END();

  00077	57		 push	 edi
  00078	e8 00 00 00 00	 call	 _Cpu_psw_set

; 624  :     SCHED(0);

  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_need_sched
  00082	83 c4 04	 add	 esp, 4
  00085	85 c0		 test	 eax, eax
  00087	74 b5		 je	 SHORT $LN2@Sema_up
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _handle$[esp-4], 0
  00093	e9 00 00 00 00	 jmp	 _Proc_sched
_Sema_up ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@NBMOOJPK@message?5initial?4?4?4?4?5?5?5?5?$AA@ ; `string'
PUBLIC	_Msg_initial
_BSS	SEGMENT
_mb_pool DB	04e0H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BI@NBMOOJPK@message?5initial?4?4?4?4?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BI@NBMOOJPK@message?5initial?4?4?4?4?5?5?5?5?$AA@ DB 'message init'
	DB	'ial....    ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Msg_initial
_TEXT	SEGMENT
_Msg_initial PROC					; COMDAT

; 648  :     _printk("message initial....    ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@NBMOOJPK@message?5initial?4?4?4?4?5?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 649  : #ifdef _CFG_SMP_
; 650  :     spin_lock_t     = 0;
; 651  : #endif  /*  _CFG_SMP_*/
; 652  :     _memzero(mb_pool,sizeof(message_box_t)*MB_MAX);

  0000a	68 e0 04 00 00	 push	 1248			; 000004e0H
  0000f	68 00 00 00 00	 push	 OFFSET _mb_pool
  00014	e8 00 00 00 00	 call	 __memzero

; 653  :     _printk("OK!\n");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0001e	e8 00 00 00 00	 call	 __printk
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 654  : }

  00026	c3		 ret	 0
_Msg_initial ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Msg_release
_TEXT	SEGMENT
_mb$ = 8						; size = 4
_Msg_release PROC					; COMDAT

; 659  : {

  00000	56		 push	 esi

; 660  :     /*
; 661  :      *  可能存在的情况。1、对象还有引用
; 662  :      *  设计，自己任何时候都可以销毁对象，不管是否有引用。
; 663  :      *  引用者不能销毁对象
; 664  :      *  在全部引用者释放后，才能完全释放
; 665  :      */
; 666  :     CRITICAL_DECLARE(mb_lock);
; 667  :     --mb->mb_ref;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _mb$[esp]
  00005	83 46 18 ff	 add	 DWORD PTR [esi+24], -1

; 668  :     /*  只有创建者能销毁邮箱    */
; 669  :     if( proc_current != mb->mb_owner )

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0000e	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]

; 670  :         return RESULT_SUCCEED;

  00011	75 52		 jne	 SHORT $LN20@Msg_releas
  00013	53		 push	 ebx
  00014	57		 push	 edi

; 671  :     CRITICAL_BEGIN();

  00015	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0001a	8b f8		 mov	 edi, eax

; 672  :     do
; 673  :     {
; 674  :         /*
; 675  :          *  有可能在销毁对象时，还有进程在等待邮箱，需要唤醒这些进程，使其可以
; 676  :          *  进行后续的处理。
; 677  :          *  嵌套使用CSPF。
; 678  :          */
; 679  :         CRITICAL_DECLARE(mb->mb_lock);
; 680  :         CRITICAL_BEGIN();

  0001c	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 681  :         Proc_resume_on(&mb->mb_send_wait);

  00021	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00024	51		 push	 ecx
  00025	8b d8		 mov	 ebx, eax
  00027	e8 00 00 00 00	 call	 _Proc_resume_on

; 682  :         CRITICAL_END();

  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 _Cpu_psw_set

; 683  :     }while(0);
; 684  :     _memzero(mb,sizeof(message_box_t));

  00032	6a 34		 push	 52			; 00000034H
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 __memzero

; 685  :     CRITICAL_END();

  0003a	57		 push	 edi
  0003b	e8 00 00 00 00	 call	 _Cpu_psw_set

; 686  :     SCHED(0);

  00040	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_need_sched
  00046	83 c4 14	 add	 esp, 20			; 00000014H
  00049	85 d2		 test	 edx, edx
  0004b	5f		 pop	 edi
  0004c	5b		 pop	 ebx
  0004d	74 0a		 je	 SHORT $LN6@Msg_releas
  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 _Proc_sched
  00056	83 c4 04	 add	 esp, 4
$LN6@Msg_releas:

; 687  :     PROC_NO_ERR();

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0005e	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN20@Msg_releas:

; 688  : 
; 689  :     return RESULT_SUCCEED;

  00065	33 c0		 xor	 eax, eax
  00067	5e		 pop	 esi

; 690  : }

  00068	c3		 ret	 0
_Msg_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HHEJHIBB@0?5?$CB?$DN?5count?$AA@	; `string'
PUBLIC	??_C@_0P@CCOOKCO@NULL?5?$CB?$DN?5msgbuf?$AA@	; `string'
PUBLIC	??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@	; `string'
PUBLIC	_Msg_create
EXTRN	__nstrcpy:PROC
EXTRN	__namecmp:PROC
;	COMDAT ??_C@_0L@HHEJHIBB@0?5?$CB?$DN?5count?$AA@
CONST	SEGMENT
??_C@_0L@HHEJHIBB@0?5?$CB?$DN?5count?$AA@ DB '0 != count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CCOOKCO@NULL?5?$CB?$DN?5msgbuf?$AA@
CONST	SEGMENT
??_C@_0P@CCOOKCO@NULL?5?$CB?$DN?5msgbuf?$AA@ DB 'NULL != msgbuf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@
CONST	SEGMENT
??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@ DB 'NULL != name', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Msg_create
_TEXT	SEGMENT
___psw$ = -4						; size = 4
_name$ = 8						; size = 4
_msgbuf$ = 12						; size = 4
_count$ = 16						; size = 4
_Msg_create PROC					; COMDAT

; 712  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 713  :     int             i       = 0;
; 714  :     message_box_t * mb      = mb_pool;
; 715  :     handle_t        handle  = INVALID_HANDLE;
; 716  :     CRITICAL_DECLARE(mb_lock);
; 717  : 
; 718  :     ASSERT( NULL != name);

  00003	8b 6c 24 10	 mov	 ebp, DWORD PTR _name$[esp+8]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 db		 xor	 ebx, ebx
  0000b	33 ff		 xor	 edi, edi
  0000d	3b eb		 cmp	 ebp, ebx
  0000f	be 00 00 00 00	 mov	 esi, OFFSET _mb_pool
  00014	75 26		 jne	 SHORT $LN39@Msg_create
  00016	68 ce 02 00 00	 push	 718			; 000002ceH
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0002a	e8 00 00 00 00	 call	 __printf
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00034	e8 00 00 00 00	 call	 _Sys_halt
  00039	83 c4 14	 add	 esp, 20			; 00000014H
$LN39@Msg_create:

; 719  :     ASSERT( NULL != msgbuf  );

  0003c	39 5c 24 1c	 cmp	 DWORD PTR _msgbuf$[esp+16], ebx
  00040	75 26		 jne	 SHORT $LN35@Msg_create
  00042	68 cf 02 00 00	 push	 719			; 000002cfH
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@CCOOKCO@NULL?5?$CB?$DN?5msgbuf?$AA@
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00056	e8 00 00 00 00	 call	 __printf
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00060	e8 00 00 00 00	 call	 _Sys_halt
  00065	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@Msg_create:

; 720  :     ASSERT( 0 != count  );

  00068	39 5c 24 20	 cmp	 DWORD PTR _count$[esp+16], ebx
  0006c	75 26		 jne	 SHORT $LN31@Msg_create
  0006e	68 d0 02 00 00	 push	 720			; 000002d0H
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0L@HHEJHIBB@0?5?$CB?$DN?5count?$AA@
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00082	e8 00 00 00 00	 call	 __printf
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0008c	e8 00 00 00 00	 call	 _Sys_halt
  00091	83 c4 14	 add	 esp, 20			; 00000014H
$LN31@Msg_create:

; 721  : #ifdef _CFG_CHECK_PARAMETER_
; 722  :     if( NULL == name || NULL == msgbuf || 0 == count )

  00094	3b eb		 cmp	 ebp, ebx
  00096	0f 84 81 00 00
	00		 je	 $LN58@Msg_create
  0009c	39 5c 24 1c	 cmp	 DWORD PTR _msgbuf$[esp+16], ebx
  000a0	74 7b		 je	 SHORT $LN58@Msg_create
  000a2	39 5c 24 20	 cmp	 DWORD PTR _count$[esp+16], ebx
  000a6	74 75		 je	 SHORT $LN58@Msg_create

; 723  :         goto mb_create_end;
; 724  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 725  :     CRITICAL_BEGIN();

  000a8	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  000ad	89 44 24 10	 mov	 DWORD PTR ___psw$[esp+20], eax
$LL23@Msg_create:

; 726  :     /*  先找到可用对象，消息对象的缓冲区没有分配缓存，则认为该对象可用 */
; 727  :     for( ; i < MB_MAX ; i++,mb++)
; 728  :     {
; 729  :         if( NULL == mb->mb_buffer )

  000b1	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  000b4	74 4c		 je	 SHORT $LN59@Msg_create
  000b6	83 c6 34	 add	 esi, 52			; 00000034H
  000b9	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  000bc	74 2d		 je	 SHORT $LN49@Msg_create
  000be	83 c6 34	 add	 esi, 52			; 00000034H
  000c1	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  000c4	74 2a		 je	 SHORT $LN50@Msg_create
  000c6	83 c6 34	 add	 esi, 52			; 00000034H
  000c9	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  000cc	74 27		 je	 SHORT $LN51@Msg_create
  000ce	83 c6 34	 add	 esi, 52			; 00000034H
  000d1	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  000d4	74 24		 je	 SHORT $LN52@Msg_create
  000d6	83 c6 34	 add	 esi, 52			; 00000034H
  000d9	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  000dc	74 21		 je	 SHORT $LN53@Msg_create
  000de	83 c7 06	 add	 edi, 6
  000e1	83 c6 34	 add	 esi, 52			; 00000034H
  000e4	83 ff 18	 cmp	 edi, 24			; 00000018H
  000e7	7c c8		 jl	 SHORT $LL23@Msg_create

; 730  :             break;
; 731  :     }
; 732  :     if( i >= MB_MAX )

  000e9	eb 1c		 jmp	 SHORT $LN55@Msg_create
$LN49@Msg_create:

; 726  :     /*  先找到可用对象，消息对象的缓冲区没有分配缓存，则认为该对象可用 */
; 727  :     for( ; i < MB_MAX ; i++,mb++)
; 728  :     {
; 729  :         if( NULL == mb->mb_buffer )

  000eb	83 c7 01	 add	 edi, 1
  000ee	eb 12		 jmp	 SHORT $LN59@Msg_create
$LN50@Msg_create:
  000f0	83 c7 02	 add	 edi, 2
  000f3	eb 0d		 jmp	 SHORT $LN59@Msg_create
$LN51@Msg_create:
  000f5	83 c7 03	 add	 edi, 3
  000f8	eb 08		 jmp	 SHORT $LN59@Msg_create
$LN52@Msg_create:
  000fa	83 c7 04	 add	 edi, 4
  000fd	eb 03		 jmp	 SHORT $LN59@Msg_create
$LN53@Msg_create:
  000ff	83 c7 05	 add	 edi, 5
$LN59@Msg_create:

; 730  :             break;
; 731  :     }
; 732  :     if( i >= MB_MAX )

  00102	83 ff 18	 cmp	 edi, 24			; 00000018H
  00105	7c 1e		 jl	 SHORT $LN19@Msg_create
$LN55@Msg_create:

; 733  :     {
; 734  :         PROC_SET_ERR(ERR_MSG_NO_SPACE);

  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current

; 735  :         CRITICAL_END();

  0010d	50		 push	 eax
  0010e	c7 41 38 01 04
	00 00		 mov	 DWORD PTR [ecx+56], 1025 ; 00000401H

; 751  :             mb->mb_buffer = NULL;
; 752  :             CRITICAL_END();

  00115	e8 00 00 00 00	 call	 _Cpu_psw_set
  0011a	83 c4 04	 add	 esp, 4
$LN58@Msg_create:
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5d		 pop	 ebp

; 778  : 
; 779  : mb_create_end:
; 780  :     return handle;

  00120	33 c0		 xor	 eax, eax
$mb_create_end$2069:
  00122	5b		 pop	 ebx

; 781  : }

  00123	59		 pop	 ecx
  00124	c3		 ret	 0
$LN19@Msg_create:

; 736  :         goto mb_create_end;
; 737  :     }
; 738  :     /*  占用对象，并将名称设置为空    */
; 739  :     mb->mb_buffer     = msgbuf;

  00125	8b 54 24 1c	 mov	 edx, DWORD PTR _msgbuf$[esp+16]

; 740  :     mb->mb_name[0]    = 0;

  00129	8d 6e 08	 lea	 ebp, DWORD PTR [esi+8]
  0012c	89 56 28	 mov	 DWORD PTR [esi+40], edx
  0012f	88 5d 00	 mov	 BYTE PTR [ebp], bl
  00132	bf 08 00 00 00	 mov	 edi, OFFSET _mb_pool+8
$LL15@Msg_create:

; 743  :     {
; 744  :         /*  跳过没有使用的对象，此时自身还没有名称，所以肯定不会找到自身。*/
; 745  :         if( NULL == mb_pool[i].mb_buffer )

  00137	39 5f 20	 cmp	 DWORD PTR [edi+32], ebx
  0013a	74 16		 je	 SHORT $LN14@Msg_create

; 746  :             continue;
; 747  :         /*  系统中存在重名, 创建失败。释放已经分配的对象     */
; 748  :         if( _namecmp(mb_pool[i].mb_name,name) == 0 )

  0013c	8b 44 24 18	 mov	 eax, DWORD PTR _name$[esp+16]
  00140	50		 push	 eax
  00141	57		 push	 edi
  00142	e8 00 00 00 00	 call	 __namecmp
  00147	83 c4 08	 add	 esp, 8
  0014a	85 c0		 test	 eax, eax
  0014c	0f 84 89 00 00
	00		 je	 $LN46@Msg_create
$LN14@Msg_create:

; 741  :     /*  检测是否重名    */
; 742  :     for( i = 0 ; i < MB_MAX ; i++ )

  00152	83 c7 34	 add	 edi, 52			; 00000034H
  00155	81 ff e8 04 00
	00		 cmp	 edi, OFFSET _mb_pool+1256
  0015b	7c da		 jl	 SHORT $LL15@Msg_create

; 753  :             goto mb_create_end;
; 754  :         }
; 755  :     }
; 756  :     CRITICAL_END();

  0015d	8b 44 24 10	 mov	 eax, DWORD PTR ___psw$[esp+20]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 _Cpu_psw_set

; 757  :     /*  到达这里说明存在可用对象，且没有重名，可以创建对象。    */
; 758  :     _nstrcpy(mb->mb_name,name,OBJ_NAME_LEN);

  00167	8b 4c 24 1c	 mov	 ecx, DWORD PTR _name$[esp+20]
  0016b	6a 0c		 push	 12			; 0000000cH
  0016d	51		 push	 ecx
  0016e	55		 push	 ebp
  0016f	e8 00 00 00 00	 call	 __nstrcpy

; 759  :     PROC_LIST_ZERO(&mb->mb_send_wait);

  00174	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00177	6a 04		 push	 4
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 __memzero

; 760  :     PROC_LIST_ZERO(&mb->mb_resv_wait);

  0017f	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  00182	6a 04		 push	 4
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 __memzero

; 761  : #ifdef _CFG_SMP_
; 762  :     msg->mb_lock       = 0;
; 763  : #endif  /*  _CFG_SMP_*/
; 764  :     mb->mb_owner        = proc_current;
; 765  :     mb->mb_count        = count;

  0018a	8b 44 24 40	 mov	 eax, DWORD PTR _count$[esp+48]
  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current

; 766  :     mb->mb_send         = 0;
; 767  :     mb->mb_resv         = count - 1;
; 768  :     mb->mb_ref          = 1;
; 769  :     handle = Koum_add(mb,Msg_release,kot_message,HANDLE_ATTR_RDWR);

  00194	6a 03		 push	 3
  00196	6a 04		 push	 4
  00198	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0019b	83 c0 ff	 add	 eax, -1
  0019e	68 00 00 00 00	 push	 OFFSET _Msg_release
  001a3	56		 push	 esi
  001a4	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  001a7	89 5e 2c	 mov	 DWORD PTR [esi+44], ebx
  001aa	89 46 30	 mov	 DWORD PTR [esi+48], eax
  001ad	c7 46 18 01 00
	00 00		 mov	 DWORD PTR [esi+24], 1
  001b4	e8 00 00 00 00	 call	 _Koum_add
  001b9	8b f8		 mov	 edi, eax
  001bb	83 c4 30	 add	 esp, 48			; 00000030H

; 770  :     if( INVALID_HANDLE == handle )

  001be	3b fb		 cmp	 edi, ebx
  001c0	75 3e		 jne	 SHORT $LN3@Msg_create

; 771  :     {
; 772  :         CRITICAL_BEGIN();

  001c2	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 773  :         mb->mb_buffer = NULL;
; 774  :         CRITICAL_END();

  001c7	50		 push	 eax
  001c8	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  001cb	e8 00 00 00 00	 call	 _Cpu_psw_set
  001d0	83 c4 04	 add	 esp, 4

; 778  : 
; 779  : mb_create_end:
; 780  :     return handle;

  001d3	8b c7		 mov	 eax, edi
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5d		 pop	 ebp
  001d8	5b		 pop	 ebx

; 781  : }

  001d9	59		 pop	 ecx
  001da	c3		 ret	 0
$LN46@Msg_create:

; 749  :         {
; 750  :             PROC_SET_ERR(ERR_MSG_EXIST);

  001db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current

; 751  :             mb->mb_buffer = NULL;
; 752  :             CRITICAL_END();

  001e1	8b 54 24 10	 mov	 edx, DWORD PTR ___psw$[esp+20]
  001e5	c7 41 38 02 04
	00 00		 mov	 DWORD PTR [ecx+56], 1026 ; 00000402H
  001ec	52		 push	 edx
  001ed	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  001f0	e8 00 00 00 00	 call	 _Cpu_psw_set
  001f5	83 c4 04	 add	 esp, 4
  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	5d		 pop	 ebp

; 778  : 
; 779  : mb_create_end:
; 780  :     return handle;

  001fb	33 c0		 xor	 eax, eax
  001fd	5b		 pop	 ebx

; 781  : }

  001fe	59		 pop	 ecx
  001ff	c3		 ret	 0
$LN3@Msg_create:

; 775  :         goto mb_create_end;
; 776  :     }
; 777  :     PROC_NO_ERR();

  00200	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current

; 778  : 
; 779  : mb_create_end:
; 780  :     return handle;

  00206	8b c7		 mov	 eax, edi
  00208	5f		 pop	 edi
  00209	5e		 pop	 esi
  0020a	5d		 pop	 ebp
  0020b	89 5a 38	 mov	 DWORD PTR [edx+56], ebx
  0020e	5b		 pop	 ebx

; 781  : }

  0020f	59		 pop	 ecx
  00210	c3		 ret	 0
_Msg_create ENDP
_TEXT	ENDS
PUBLIC	_Msg_get
; Function compile flags: /Ogtpy
;	COMDAT _Msg_get
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Msg_get PROC						; COMDAT

; 801  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 802  :     handle_t        handle  = INVALID_HANDLE;
; 803  :     message_box_t * mb      = mb_pool;

  00004	be 00 00 00 00	 mov	 esi, OFFSET _mb_pool

; 804  :     int             i       = 0;

  00009	33 ff		 xor	 edi, edi

; 805  :     CRITICAL_DECLARE(mb_lock);
; 806  :         
; 807  :     CRITICAL_BEGIN();

  0000b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00010	8b 5c 24 14	 mov	 ebx, DWORD PTR _name$[esp+12]
  00014	8b e8		 mov	 ebp, eax
$LL7@Msg_get:

; 809  :     {
; 810  :         if( !MB_IS_VALID(mb))

  00016	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0001a	74 11		 je	 SHORT $LN6@Msg_get
  0001c	8d 46 08	 lea	 eax, DWORD PTR [esi+8]

; 811  :             continue;
; 812  :         if( _namecmp(name,mb->mb_name) == 0 )

  0001f	50		 push	 eax
  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 __namecmp
  00026	83 c4 08	 add	 esp, 8
  00029	85 c0		 test	 eax, eax
  0002b	74 0b		 je	 SHORT $LN14@Msg_get
$LN6@Msg_get:

; 808  :     for( ; i < MB_MAX ; i++,mb++)

  0002d	83 c7 01	 add	 edi, 1
  00030	83 c6 34	 add	 esi, 52			; 00000034H
  00033	83 ff 18	 cmp	 edi, 24			; 00000018H
  00036	7c de		 jl	 SHORT $LL7@Msg_get
$LN14@Msg_get:

; 813  :             break;
; 814  :     }
; 815  :     CRITICAL_END();

  00038	55		 push	 ebp
  00039	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003e	83 c4 04	 add	 esp, 4

; 816  :     if( i < MB_MAX )

  00041	83 ff 18	 cmp	 edi, 24			; 00000018H
  00044	7d 1f		 jge	 SHORT $LN17@Msg_get

; 817  :         handle = Koum_add(mb,Msg_release,4,HANDLE_ATTR_RDWR);

  00046	6a 03		 push	 3
  00048	6a 04		 push	 4
  0004a	68 00 00 00 00	 push	 OFFSET _Msg_release
  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 _Koum_add
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 818  :     if( INVALID_HANDLE != handle )

  00058	85 c0		 test	 eax, eax
  0005a	74 0b		 je	 SHORT $LN1@Msg_get

; 819  :         ++mb->mb_ref;

  0005c	83 46 18 01	 add	 DWORD PTR [esi+24], 1
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5d		 pop	 ebp
  00063	5b		 pop	 ebx

; 821  : }

  00064	c3		 ret	 0
$LN17@Msg_get:

; 820  :     return handle;

  00065	33 c0		 xor	 eax, eax
$LN1@Msg_get:
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5d		 pop	 ebp
  0006a	5b		 pop	 ebx

; 821  : }

  0006b	c3		 ret	 0
_Msg_get ENDP
_TEXT	ENDS
PUBLIC	_Msg_send
; Function compile flags: /Ogtpy
;	COMDAT _Msg_send
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_type$ = 12						; size = 4
_param32$ = 16						; size = 4
_param64$ = 20						; size = 8
_Msg_send PROC						; COMDAT

; 847  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 848  :     message_box_t * mb      = Koum_handle_object(handle);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _handle$[esp+4]
  00006	57		 push	 edi
  00007	e8 00 00 00 00	 call	 _Koum_handle_object
  0000c	83 c4 04	 add	 esp, 4

; 849  :     message_t     * msg     = NULL;
; 850  :     CRITICAL_DECLARE(mb->mb_lock);
; 851  : 
; 852  :     ASSERT( INVALID_HANDLE != handle);

  0000f	85 ff		 test	 edi, edi
  00011	8b f0		 mov	 esi, eax
  00013	75 2c		 jne	 SHORT $LN27@Msg_send
  00015	68 54 03 00 00	 push	 852			; 00000354H
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_05MNIEOLGC@ipc?4c?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00029	e8 00 00 00 00	 call	 __printf
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00033	e8 00 00 00 00	 call	 _Sys_halt
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	5f		 pop	 edi

; 853  : #ifdef _CFG_CHECK_PARAMETER_
; 854  :     if( INVALID_HANDLE == handle )
; 855  :         return RESULT_FAILED;

  0003c	83 c8 ff	 or	 eax, -1
  0003f	5e		 pop	 esi

; 902  : }

  00040	c3		 ret	 0
$LN27@Msg_send:

; 856  : #endif  /*  _CFG_CHECK_PARAMMETER_  */
; 857  :     if( NULL == mb)

  00041	85 f6		 test	 esi, esi
  00043	75 11		 jne	 SHORT $LN26@Msg_send

; 858  :     {
; 859  :         PROC_SET_ERR(ERR_MSG_INVALID);

  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0004b	b8 07 04 00 00	 mov	 eax, 1031		; 00000407H
  00050	5f		 pop	 edi
  00051	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00054	5e		 pop	 esi

; 902  : }

  00055	c3		 ret	 0
$LN26@Msg_send:

; 860  :         return ERR_MSG_INVALID;
; 861  :     }
; 862  :     /*
; 863  :      *  不能给自身发送消息
; 864  :      *  如果出现了缓冲区已满，而自身也尝试向自己发送消息，而进入了等待状态，
; 865  :      *  那么发送进程和接收进程都会处于等待状态，相当于死锁。
; 866  :      */
; 867  :     if( proc_current == mb->mb_owner )

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0005b	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0005e	75 0f		 jne	 SHORT $LN34@Msg_send
  00060	5f		 pop	 edi

; 868  :     {
; 869  :         PROC_SET_ERR(ERR_MSG_ITSELF);

  00061	c7 40 38 09 04
	00 00		 mov	 DWORD PTR [eax+56], 1033 ; 00000409H

; 870  :         return ERR_MSG_ITSELF;

  00068	b8 09 04 00 00	 mov	 eax, 1033		; 00000409H
  0006d	5e		 pop	 esi

; 902  : }

  0006e	c3		 ret	 0
$LN34@Msg_send:

; 871  :     }
; 872  : send_msg:
; 873  :     CRITICAL_BEGIN();

  0006f	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 874  :     if( !MB_IS_VALID(mb))

  00074	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00078	8b f8		 mov	 edi, eax
  0007a	74 39		 je	 SHORT $LN35@Msg_send
  0007c	8d 64 24 00	 npad	 4
$send_msg$2146:

; 879  :     }
; 880  :     if( MB_IS_FULL(mb) )

  00080	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00083	83 c0 01	 add	 eax, 1
  00086	99		 cdq
  00087	f7 7e 24	 idiv	 DWORD PTR [esi+36]
  0008a	3b 56 30	 cmp	 edx, DWORD PTR [esi+48]
  0008d	75 43		 jne	 SHORT $LN11@Msg_send

; 881  :     {
; 882  :         /*
; 883  :          *  缓冲区满，需要等待
; 884  :          */
; 885  :         Proc_wait_on(&mb->mb_send_wait);

  0008f	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _Proc_wait_on

; 886  :         CRITICAL_END();

  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 _Cpu_psw_set

; 887  :         Proc_sched(0);

  0009e	6a 00		 push	 0
  000a0	e8 00 00 00 00	 call	 _Proc_sched
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  000ad	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  000b1	8b f8		 mov	 edi, eax
  000b3	75 cb		 jne	 SHORT $send_msg$2146
$LN35@Msg_send:

; 875  :     {
; 876  :         PROC_SET_ERR(ERR_MSG_NOT_EXIST);

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current

; 877  :         CRITICAL_END();

  000ba	57		 push	 edi
  000bb	c7 40 38 04 04
	00 00		 mov	 DWORD PTR [eax+56], 1028 ; 00000404H
  000c2	e8 00 00 00 00	 call	 _Cpu_psw_set
  000c7	83 c4 04	 add	 esp, 4
  000ca	5f		 pop	 edi

; 878  :         return ERR_MSG_NOT_EXIST;

  000cb	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  000d0	5e		 pop	 esi

; 902  : }

  000d1	c3		 ret	 0
$LN11@Msg_send:

; 888  :         goto send_msg;
; 889  :     }
; 890  :     msg = mb->mb_buffer + mb->mb_send;

  000d2	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000d5	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000d8	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000db	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]

; 891  :     msg->msg_pid        = proc_current->proc_pid;

  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000e4	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]

; 892  :     msg->msg_type       = type;

  000e7	8b 4c 24 10	 mov	 ecx, DWORD PTR _type$[esp+4]
  000eb	89 10		 mov	 DWORD PTR [eax], edx

; 893  :     msg->msg_param32    = param32;

  000ed	8b 54 24 14	 mov	 edx, DWORD PTR _param32$[esp+4]
  000f1	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 894  :     msg->msg_param64    = param64;

  000f4	8b 4c 24 18	 mov	 ecx, DWORD PTR _param64$[esp+4]
  000f8	89 50 08	 mov	 DWORD PTR [eax+8], edx
  000fb	8b 54 24 1c	 mov	 edx, DWORD PTR _param64$[esp+8]
  000ff	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00102	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 895  :     MB_SEND_FORWARD(mb);

  00105	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00108	83 c0 01	 add	 eax, 1
  0010b	99		 cdq
  0010c	f7 7e 24	 idiv	 DWORD PTR [esi+36]

; 896  :     Proc_resume_on(&mb->mb_resv_wait);

  0010f	83 c6 20	 add	 esi, 32			; 00000020H
  00112	56		 push	 esi
  00113	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00116	e8 00 00 00 00	 call	 _Proc_resume_on

; 897  :     CRITICAL_END();

  0011b	57		 push	 edi
  0011c	e8 00 00 00 00	 call	 _Cpu_psw_set

; 898  :     SCHED(0);

  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_need_sched
  00126	83 c4 08	 add	 esp, 8
  00129	85 c0		 test	 eax, eax
  0012b	74 0a		 je	 SHORT $LN6@Msg_send
  0012d	6a 00		 push	 0
  0012f	e8 00 00 00 00	 call	 _Proc_sched
  00134	83 c4 04	 add	 esp, 4
$LN6@Msg_send:

; 899  :     PROC_NO_ERR();

  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0013d	5f		 pop	 edi
  0013e	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 900  : 
; 901  :     return RESULT_SUCCEED;

  00145	33 c0		 xor	 eax, eax
  00147	5e		 pop	 esi

; 902  : }

  00148	c3		 ret	 0
_Msg_send ENDP
_TEXT	ENDS
PUBLIC	_Msg_post
; Function compile flags: /Ogtpy
;	COMDAT _Msg_post
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_type$ = 12						; size = 4
_param32$ = 16						; size = 4
_param64$ = 20						; size = 8
_Msg_post PROC						; COMDAT

; 929  :     message_box_t * mb      = Koum_handle_object(handle);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _handle$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _Koum_handle_object
  0000b	8b f0		 mov	 esi, eax
  0000d	83 c4 04	 add	 esp, 4

; 930  :     message_t     * msg     = NULL;
; 931  :     CRITICAL_DECLARE(mb->mb_lock);
; 932  : 
; 933  :     if( NULL == mb)

  00010	85 f6		 test	 esi, esi
  00012	75 10		 jne	 SHORT $LN17@Msg_post

; 934  :     {
; 935  :         PROC_SET_ERR(ERR_MSG_INVALID);

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0001a	b8 07 04 00 00	 mov	 eax, 1031		; 00000407H
  0001f	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00022	5e		 pop	 esi

; 957  : }

  00023	c3		 ret	 0
$LN17@Msg_post:
  00024	57		 push	 edi

; 936  :         return ERR_MSG_INVALID;
; 937  :     }
; 938  :     CRITICAL_BEGIN();

  00025	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 939  :     if( MB_IS_FULL(mb) )          /*  缓冲区满，丢弃消息返回  */

  0002a	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  0002d	8b f8		 mov	 edi, eax
  0002f	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00032	99		 cdq
  00033	f7 7e 24	 idiv	 DWORD PTR [esi+36]
  00036	3b 56 30	 cmp	 edx, DWORD PTR [esi+48]
  00039	75 1a		 jne	 SHORT $LN14@Msg_post

; 940  :     {
; 941  :         CRITICAL_END();

  0003b	57		 push	 edi
  0003c	e8 00 00 00 00	 call	 _Cpu_psw_set

; 942  :         PROC_SET_ERR(ERR_MSG_BUFFER_FULL);

  00041	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00047	83 c4 04	 add	 esp, 4
  0004a	b8 05 04 00 00	 mov	 eax, 1029		; 00000405H
  0004f	5f		 pop	 edi
  00050	89 42 38	 mov	 DWORD PTR [edx+56], eax
  00053	5e		 pop	 esi

; 957  : }

  00054	c3		 ret	 0
$LN14@Msg_post:

; 943  :         return ERR_MSG_BUFFER_FULL;        
; 944  :     }
; 945  :     msg = mb->mb_buffer + mb->mb_send;
; 946  :     msg->msg_pid        = proc_current->proc_pid;

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0005b	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0005e	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00061	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00064	8b 4a 30	 mov	 ecx, DWORD PTR [edx+48]

; 947  :     msg->msg_type       = type;

  00067	8b 54 24 10	 mov	 edx, DWORD PTR _type$[esp+4]
  0006b	89 08		 mov	 DWORD PTR [eax], ecx

; 948  :     msg->msg_param32    = param32;

  0006d	8b 4c 24 14	 mov	 ecx, DWORD PTR _param32$[esp+4]
  00071	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 949  :     msg->msg_param64    = param64;

  00074	8b 54 24 18	 mov	 edx, DWORD PTR _param64$[esp+4]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0007b	8b 4c 24 1c	 mov	 ecx, DWORD PTR _param64$[esp+8]
  0007f	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00082	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 950  :     MB_SEND_FORWARD(mb);

  00085	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00088	83 c0 01	 add	 eax, 1
  0008b	99		 cdq
  0008c	f7 7e 24	 idiv	 DWORD PTR [esi+36]

; 951  :     Proc_resume_on(&mb->mb_resv_wait);

  0008f	83 c6 20	 add	 esi, 32			; 00000020H
  00092	56		 push	 esi
  00093	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00096	e8 00 00 00 00	 call	 _Proc_resume_on

; 952  :     CRITICAL_END();

  0009b	57		 push	 edi
  0009c	e8 00 00 00 00	 call	 _Cpu_psw_set

; 953  :     SCHED(0);

  000a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_need_sched
  000a7	83 c4 08	 add	 esp, 8
  000aa	85 d2		 test	 edx, edx
  000ac	74 0a		 je	 SHORT $LN6@Msg_post
  000ae	6a 00		 push	 0
  000b0	e8 00 00 00 00	 call	 _Proc_sched
  000b5	83 c4 04	 add	 esp, 4
$LN6@Msg_post:

; 954  :     PROC_NO_ERR();

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000bd	5f		 pop	 edi
  000be	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 955  : 
; 956  :     return RESULT_SUCCEED;

  000c5	33 c0		 xor	 eax, eax
  000c7	5e		 pop	 esi

; 957  : }

  000c8	c3		 ret	 0
_Msg_post ENDP
_TEXT	ENDS
PUBLIC	_Msg_resv
; Function compile flags: /Ogtpy
;	COMDAT _Msg_resv
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_msg$ = 12						; size = 4
_Msg_resv PROC						; COMDAT

; 981  :     message_box_t * mb      = Koum_handle_object(handle);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _handle$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _Koum_handle_object
  0000c	8b f0		 mov	 esi, eax
  0000e	83 c4 04	 add	 esp, 4

; 982  :     CRITICAL_DECLARE(mb->mb_lock);    /*  在mb为NULL时，可能会造成错误 */
; 983  : 
; 984  :     if( NULL == mb || NULL == msg )

  00011	85 f6		 test	 esi, esi
  00013	0f 84 df 00 00
	00		 je	 $LN21@Msg_resv
  00019	8b 5c 24 10	 mov	 ebx, DWORD PTR _msg$[esp+4]
  0001d	85 db		 test	 ebx, ebx
  0001f	0f 84 d3 00 00
	00		 je	 $LN21@Msg_resv

; 987  :         return ERR_MSG_INVALID;
; 988  :     }
; 989  :     /*
; 990  :      *  拥有者才能接受消息
; 991  :      */
; 992  :     if( proc_current != mb->mb_owner )

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0002a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0002d	74 0f		 je	 SHORT $LN26@Msg_resv
  0002f	5e		 pop	 esi

; 993  :     {
; 994  :         PROC_SET_ERR(ERR_MSG_NOT_OWNER);

  00030	c7 40 38 03 04
	00 00		 mov	 DWORD PTR [eax+56], 1027 ; 00000403H

; 995  :         return ERR_MSG_NOT_OWNER;

  00037	b8 03 04 00 00	 mov	 eax, 1027		; 00000403H
  0003c	5b		 pop	 ebx

; 1017 : }

  0003d	c3		 ret	 0
$LN26@Msg_resv:
  0003e	57		 push	 edi

; 996  :     }
; 997  : resv_msg:
; 998  :     CRITICAL_BEGIN();

  0003f	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00044	8b f8		 mov	 edi, eax

; 999  :     if( MB_IS_EMPTY(mb) )

  00046	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00049	83 c0 01	 add	 eax, 1
  0004c	99		 cdq
  0004d	f7 7e 24	 idiv	 DWORD PTR [esi+36]
  00050	3b 56 2c	 cmp	 edx, DWORD PTR [esi+44]
  00053	75 38		 jne	 SHORT $LN10@Msg_resv
  00055	55		 push	 ebp
  00056	8d 6e 20	 lea	 ebp, DWORD PTR [esi+32]
  00059	8d a4 24 00 00
	00 00		 npad	 7
$resv_msg$2218:

; 1000 :     {
; 1001 :         /*
; 1002 :          *  缓冲区空，需要等待数据
; 1003 :          */
; 1004 :         Proc_wait_on(&mb->mb_resv_wait);

  00060	55		 push	 ebp
  00061	e8 00 00 00 00	 call	 _Proc_wait_on

; 1005 :         CRITICAL_END();

  00066	57		 push	 edi
  00067	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1006 :         Proc_sched(0);

  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 _Proc_sched
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0007b	8b f8		 mov	 edi, eax
  0007d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00080	83 c0 01	 add	 eax, 1
  00083	99		 cdq
  00084	f7 7e 24	 idiv	 DWORD PTR [esi+36]
  00087	3b 56 2c	 cmp	 edx, DWORD PTR [esi+44]
  0008a	74 d4		 je	 SHORT $resv_msg$2218
  0008c	5d		 pop	 ebp
$LN10@Msg_resv:

; 1007 :         goto resv_msg;
; 1008 :     }
; 1009 :     MB_RESV_FORWARD(mb);

  0008d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00090	83 c0 01	 add	 eax, 1
  00093	99		 cdq
  00094	f7 7e 24	 idiv	 DWORD PTR [esi+36]

; 1010 :     *msg = *(mb->mb_buffer + mb->mb_resv);
; 1011 :     Proc_resume_on(&mb->mb_send_wait);

  00097	83 c6 1c	 add	 esi, 28			; 0000001cH
  0009a	56		 push	 esi
  0009b	89 56 14	 mov	 DWORD PTR [esi+20], edx
  0009e	8d 0c 92	 lea	 ecx, DWORD PTR [edx+edx*4]
  000a1	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  000a4	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	89 0b		 mov	 DWORD PTR [ebx], ecx
  000ab	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000ae	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b4	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  000b7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000ba	89 53 0c	 mov	 DWORD PTR [ebx+12], edx
  000bd	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000c0	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000c3	e8 00 00 00 00	 call	 _Proc_resume_on

; 1012 :     CRITICAL_END();

  000c8	57		 push	 edi
  000c9	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1013 :     SCHED(0);

  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_need_sched
  000d4	83 c4 08	 add	 esp, 8
  000d7	85 c9		 test	 ecx, ecx
  000d9	5f		 pop	 edi
  000da	74 0a		 je	 SHORT $LN6@Msg_resv
  000dc	6a 00		 push	 0
  000de	e8 00 00 00 00	 call	 _Proc_sched
  000e3	83 c4 04	 add	 esp, 4
$LN6@Msg_resv:

; 1014 :     PROC_NO_ERR();

  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000ec	5e		 pop	 esi
  000ed	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 1015 : 
; 1016 :     return RESULT_SUCCEED;

  000f4	33 c0		 xor	 eax, eax
  000f6	5b		 pop	 ebx

; 1017 : }

  000f7	c3		 ret	 0
$LN21@Msg_resv:

; 985  :     {
; 986  :         PROC_SET_ERR(ERR_MSG_INVALID);

  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  000fe	b8 07 04 00 00	 mov	 eax, 1031		; 00000407H
  00103	5e		 pop	 esi
  00104	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00107	5b		 pop	 ebx

; 1017 : }

  00108	c3		 ret	 0
_Msg_resv ENDP
_TEXT	ENDS
PUBLIC	_Msg_take
EXTRN	_Proc_delay:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Msg_take
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_msg$ = 12						; size = 4
_Msg_take PROC						; COMDAT

; 1041 :     message_box_t * mb      = Koum_handle_object(handle);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _handle$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _Koum_handle_object
  0000d	8b f0		 mov	 esi, eax
  0000f	83 c4 04	 add	 esp, 4

; 1042 :     int             retry   = MSG_TAKE_RETRY_TIMES;
; 1043 :     CRITICAL_DECLARE(mb->mb_lock);    /*  在mb为NULL时，可能会造成错误 */
; 1044 : 
; 1045 :     if( NULL == mb || NULL == msg )

  00012	85 f6		 test	 esi, esi
  00014	bd 01 00 00 00	 mov	 ebp, 1
  00019	0f 84 f3 00 00
	00		 je	 $LN25@Msg_take
  0001f	8b 5c 24 14	 mov	 ebx, DWORD PTR _msg$[esp+8]
  00023	85 db		 test	 ebx, ebx
  00025	0f 84 e7 00 00
	00		 je	 $LN25@Msg_take

; 1048 :         return ERR_MSG_INVALID;
; 1049 :     }
; 1050 :     /*
; 1051 :      *  拥有者才能接受消息
; 1052 :      */
; 1053 :     if( proc_current != mb->mb_owner )

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00030	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  00033	74 10		 je	 SHORT $LN30@Msg_take
  00035	5e		 pop	 esi
  00036	5d		 pop	 ebp

; 1054 :     {
; 1055 :         PROC_SET_ERR(ERR_MSG_NOT_OWNER);

  00037	c7 40 38 03 04
	00 00		 mov	 DWORD PTR [eax+56], 1027 ; 00000403H

; 1056 :         return ERR_MSG_NOT_OWNER;

  0003e	b8 03 04 00 00	 mov	 eax, 1027		; 00000403H
  00043	5b		 pop	 ebx

; 1083 : }

  00044	c3		 ret	 0
$LN30@Msg_take:
  00045	57		 push	 edi

; 1057 :     }
; 1058 : resv_msg:
; 1059 :     CRITICAL_BEGIN();

  00046	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0004b	8b f8		 mov	 edi, eax

; 1060 :     /*
; 1061 :      *  在缓冲区无数据的情况下，等待一定的毫秒后，仍无数据
; 1062 :      *  返回失败
; 1063 :      */
; 1064 :     if( MB_IS_EMPTY(mb))

  0004d	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00050	83 c0 01	 add	 eax, 1
  00053	99		 cdq
  00054	f7 7e 24	 idiv	 DWORD PTR [esi+36]
  00057	3b 56 2c	 cmp	 edx, DWORD PTR [esi+44]
  0005a	75 36		 jne	 SHORT $LN10@Msg_take
  0005c	8d 64 24 00	 npad	 4
$resv_msg$2252:

; 1065 :     {
; 1066 :         CRITICAL_END();

  00060	57		 push	 edi
  00061	e8 00 00 00 00	 call	 _Cpu_psw_set
  00066	83 c4 04	 add	 esp, 4

; 1067 :         if( --retry < 0 )

  00069	83 ed 01	 sub	 ebp, 1
  0006c	0f 88 8d 00 00
	00		 js	 $LN31@Msg_take

; 1070 :             return ERR_MSG_BUFFER_EMPTY;
; 1071 :         }
; 1072 :         Proc_delay(MSG_TAKE_TIMEOUT);

  00072	6a 64		 push	 100			; 00000064H
  00074	e8 00 00 00 00	 call	 _Proc_delay
  00079	83 c4 04	 add	 esp, 4
  0007c	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00081	8b f8		 mov	 edi, eax
  00083	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00086	83 c0 01	 add	 eax, 1
  00089	99		 cdq
  0008a	f7 7e 24	 idiv	 DWORD PTR [esi+36]
  0008d	3b 56 2c	 cmp	 edx, DWORD PTR [esi+44]
  00090	74 ce		 je	 SHORT $resv_msg$2252
$LN10@Msg_take:

; 1073 :         goto resv_msg;
; 1074 :     }
; 1075 :     MB_RESV_FORWARD(mb);

  00092	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00095	83 c0 01	 add	 eax, 1
  00098	99		 cdq
  00099	f7 7e 24	 idiv	 DWORD PTR [esi+36]

; 1076 :     *msg = *(mb->mb_buffer + mb->mb_resv);

  0009c	8b 46 28	 mov	 eax, DWORD PTR [esi+40]

; 1077 :     Proc_resume_on(&mb->mb_send_wait);

  0009f	83 c6 1c	 add	 esi, 28			; 0000001cH
  000a2	56		 push	 esi
  000a3	89 56 14	 mov	 DWORD PTR [esi+20], edx
  000a6	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  000a9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  000ac	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  000af	89 0b		 mov	 DWORD PTR [ebx], ecx
  000b1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b4	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000b7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ba	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  000bd	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000c0	89 53 0c	 mov	 DWORD PTR [ebx+12], edx
  000c3	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000c6	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000c9	e8 00 00 00 00	 call	 _Proc_resume_on

; 1078 :     CRITICAL_END();

  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1079 :     SCHED(0);

  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_need_sched
  000da	83 c4 08	 add	 esp, 8
  000dd	85 c9		 test	 ecx, ecx
  000df	74 0a		 je	 SHORT $LN6@Msg_take
  000e1	6a 00		 push	 0
  000e3	e8 00 00 00 00	 call	 _Proc_sched
  000e8	83 c4 04	 add	 esp, 4
$LN6@Msg_take:

; 1080 :     PROC_NO_ERR();

  000eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5d		 pop	 ebp
  000f4	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0

; 1081 : 
; 1082 :     return RESULT_SUCCEED;

  000fb	33 c0		 xor	 eax, eax
  000fd	5b		 pop	 ebx

; 1083 : }

  000fe	c3		 ret	 0
$LN31@Msg_take:

; 1068 :         {
; 1069 :             PROC_SET_ERR(ERR_MSG_BUFFER_EMPTY);

  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	b8 06 04 00 00	 mov	 eax, 1030		; 00000406H
  0010c	5d		 pop	 ebp
  0010d	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00110	5b		 pop	 ebx

; 1083 : }

  00111	c3		 ret	 0
$LN25@Msg_take:

; 1046 :     {
; 1047 :         PROC_SET_ERR(ERR_MSG_INVALID);

  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00118	5e		 pop	 esi
  00119	b8 07 04 00 00	 mov	 eax, 1031		; 00000407H
  0011e	5d		 pop	 ebp
  0011f	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  00122	5b		 pop	 ebx

; 1083 : }

  00123	c3		 ret	 0
_Msg_take ENDP
_TEXT	ENDS
END
