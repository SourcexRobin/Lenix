; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\demo\kernel32\fs_fat32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2097	DB	'FAT32 informatino:', 0aH, 00H
$SG2098	DB	'start sector =%ld; total sectors =%ld', 0aH, 00H
	ORG $+1
$SG2099	DB	'start data sector =%d; total dat sectors =%d', 0aH, 00H
	ORG $+2
$SG2100	DB	'total clusters =%d', 00H
	ORG $+1
$SG2105	DB	'FAT32 BPB information:', 0aH, 00H
$SG2106	DB	'boot signature =%02X; volume id =%08X; volume lable =%s', 0aH
	DB	00H
	ORG $+3
$SG2107	DB	'bytes per sector =%d; sectors per cluster =%d', 0aH, 00H
	ORG $+1
$SG2108	DB	'total sectors =%d; fat number =%d; fat size =%d', 0aH, 00H
	ORG $+3
$SG2109	DB	'rsvd sectors =%d; root cluster =%d', 0aH, 00H
$SG2115	DB	'%-12s ', 00H
	ORG $+1
$SG2117	DB	'<DIR> ', 00H
	ORG $+1
$SG2119	DB	'      ', 00H
	ORG $+1
$SG2120	DB	'%-9d %02d-%02d-%02d %02d:%02d %02X', 0aH, 00H
$SG2449	DB	'FAT32 read!', 0aH, 00H
	ORG $+3
$SG2476	DB	'FAT32 initial...', 0aH, 00H
	ORG $+2
$SG2477	DB	'start=%ld total=%ld', 0aH, 00H
	ORG $+3
$SG2499	DB	'FAT32 fnode find', 0aH, 00H
	ORG $+2
$SG2504	DB	'fs_fat32.c', 00H
	ORG $+1
$SG2505	DB	'parents', 00H
$SG2506	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2507	DB	'assert failed', 00H
	ORG $+2
$SG2512	DB	'fs_fat32.c', 00H
	ORG $+1
$SG2513	DB	'fnode', 00H
	ORG $+2
$SG2514	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2515	DB	'assert failed', 00H
	ORG $+2
$SG2566	DB	'fat32 create short name', 0aH, 00H
	ORG $+3
$SG2600	DB	'fat32 create fnode', 0aH, 00H
$SG2608	DB	'fat32 create fnode.  file not exist', 0a3H, 0a1H, ' ', 0aH
	DB	00H
$SG2625	DB	'fs_fat32.c', 00H
	ORG $+1
$SG2626	DB	'fnode', 00H
	ORG $+2
$SG2627	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2628	DB	'assert failed', 00H
	ORG $+2
$SG2633	DB	'fs_fat32.c', 00H
	ORG $+1
$SG2634	DB	'buffer', 00H
	ORG $+1
$SG2635	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2636	DB	'assert failed', 00H
	ORG $+2
$SG2641	DB	'fs_fat32.c', 00H
	ORG $+1
$SG2642	DB	'size>0', 00H
	ORG $+1
$SG2643	DB	'assert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H
$SG2644	DB	'assert failed', 00H
	ORG $+2
$SG2645	DB	'FAT32 fnode read!', 0aH, 00H
_DATA	ENDS
PUBLIC	_Fat32_register
; Function compile flags: /Odtp
; File e:\sourcexstudio\lenix\lenix\demo\kernel32\fs_fat32.c
_TEXT	SEGMENT
_fsdrv$ = 8						; size = 4
_Fat32_register PROC

; 933  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 934  :     fsdrv->fs_type          = FS_PART_TYPE_FAT32;

  00003	8b 45 08	 mov	 eax, DWORD PTR _fsdrv$[ebp]
  00006	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 935  :     fsdrv->fs_initial       = Fat32_initial;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _fsdrv$[ebp]
  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET _Fat32_initial

; 936  :     fsdrv->fs_fnode_find    = Fat32_fnode_find;

  00016	8b 55 08	 mov	 edx, DWORD PTR _fsdrv$[ebp]
  00019	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET _Fat32_fnode_find

; 937  :     fsdrv->fs_fnode_create  = Fat32_fnode_create;

  00020	8b 45 08	 mov	 eax, DWORD PTR _fsdrv$[ebp]
  00023	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET _Fat32_fnode_create

; 938  :     fsdrv->fs_fnode_read    = Fat32_fnode_read;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _fsdrv$[ebp]
  0002d	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET _Fat32_fnode_read

; 939  : 
; 940  :     return RESULT_SUCCEED;

  00034	33 c0		 xor	 eax, eax

; 941  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_Fat32_register ENDP
_TEXT	ENDS
EXTRN	_Bbuf_release:PROC
EXTRN	_Bbuf_read:PROC
EXTRN	__printk:PROC
EXTRN	__allmul:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fat$ = -12						; size = 4
_bpb$ = -8						; size = 4
_blkbuf$ = -4						; size = 4
_fs$ = 8						; size = 4
_Fat32_initial PROC

; 722  : {

  00040	55		 push	 ebp
  00041	8b ec		 mov	 ebp, esp
  00043	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 723  :     blkbuf_t      * blkbuf  = NULL;

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _blkbuf$[ebp], 0

; 724  :     bpb32_t       * bpb     = NULL;

  0004d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bpb$[ebp], 0

; 725  :     fat_t         * fat     = NULL;

  00054	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _fat$[ebp], 0

; 726  : 
; 727  :     _printk("FAT32 initial...\n");

  0005b	68 00 00 00 00	 push	 OFFSET $SG2476
  00060	e8 00 00 00 00	 call	 __printk
  00065	83 c4 04	 add	 esp, 4

; 728  :     _printk("start=%ld total=%ld\n",
; 729  :         fs->fs_part.fsp_start,fs->fs_part.fsp_total);

  00068	8b 45 08	 mov	 eax, DWORD PTR _fs$[ebp]
  0006b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0006e	51		 push	 ecx
  0006f	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00072	52		 push	 edx
  00073	8b 45 08	 mov	 eax, DWORD PTR _fs$[ebp]
  00076	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00079	51		 push	 ecx
  0007a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007d	52		 push	 edx
  0007e	68 00 00 00 00	 push	 OFFSET $SG2477
  00083	e8 00 00 00 00	 call	 __printk
  00088	83 c4 14	 add	 esp, 20			; 00000014H

; 730  :     if( NULL == (blkbuf=Bbuf_read(fs->fs_part.fsp_dev,fs->fs_part.fsp_start)))

  0008b	8b 45 08	 mov	 eax, DWORD PTR _fs$[ebp]
  0008e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00091	51		 push	 ecx
  00092	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00095	52		 push	 edx
  00096	8b 45 08	 mov	 eax, DWORD PTR _fs$[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _Bbuf_read
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	89 45 fc	 mov	 DWORD PTR _blkbuf$[ebp], eax
  000a7	83 7d fc 00	 cmp	 DWORD PTR _blkbuf$[ebp], 0
  000ab	75 08		 jne	 SHORT $LN1@Fat32_init

; 731  :         return RESULT_FAILED;

  000ad	83 c8 ff	 or	 eax, -1
  000b0	e9 8d 01 00 00	 jmp	 $LN2@Fat32_init
$LN1@Fat32_init:

; 732  :     bpb = BBUF_TO_SECTOR(blkbuf,fs->fs_part.fsp_start);

  000b5	8b 55 08	 mov	 edx, DWORD PTR _fs$[ebp]
  000b8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000bb	83 e0 07	 and	 eax, 7
  000be	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000c1	83 e1 00	 and	 ecx, 0
  000c4	6a 00		 push	 0
  000c6	68 00 02 00 00	 push	 512			; 00000200H
  000cb	51		 push	 ecx
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 __allmul
  000d2	8b 55 fc	 mov	 edx, DWORD PTR _blkbuf$[ebp]
  000d5	03 42 14	 add	 eax, DWORD PTR [edx+20]
  000d8	89 45 f8	 mov	 DWORD PTR _bpb$[ebp], eax

; 733  :     fat = (fat_t *)fs->fs_param_blk;

  000db	8b 45 08	 mov	 eax, DWORD PTR _fs$[ebp]
  000de	83 c0 64	 add	 eax, 100		; 00000064H
  000e1	89 45 f4	 mov	 DWORD PTR _fat$[ebp], eax

; 734  :     fat->fat_start_sector       = FS_START_SECTOR(fs);

  000e4	8b 4d f4	 mov	 ecx, DWORD PTR _fat$[ebp]
  000e7	8b 55 08	 mov	 edx, DWORD PTR _fs$[ebp]
  000ea	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000ed	89 01		 mov	 DWORD PTR [ecx], eax
  000ef	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000f2	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 735  :     fat->fat_total_sectors      = FS_TOTAL_SECTORS(fs);

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _fat$[ebp]
  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _fs$[ebp]
  000fb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000fe	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00101	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00104	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 736  :     fat->fat_clus_size          = FAT32_CLUS_SIZE(bpb);

  00107	8b 55 f8	 mov	 edx, DWORD PTR _bpb$[ebp]
  0010a	0f b7 42 0b	 movzx	 eax, WORD PTR [edx+11]
  0010e	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  00111	0f b6 51 0d	 movzx	 edx, BYTE PTR [ecx+13]
  00115	0f af c2	 imul	 eax, edx
  00118	8b 4d f4	 mov	 ecx, DWORD PTR _fat$[ebp]
  0011b	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 737  :     fat->fat_start_data_sector  = FAT32_START_DATA_SECTOR(bpb);

  0011e	8b 55 f8	 mov	 edx, DWORD PTR _bpb$[ebp]
  00121	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00125	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  00128	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  0012f	0f af 51 24	 imul	 edx, DWORD PTR [ecx+36]
  00133	03 c2		 add	 eax, edx
  00135	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  00138	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 738  :     fat->fat_total_data_sectors = FAT32_TOTAL_DATA_SECTORS(bpp);

  0013b	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  0013e	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00142	8b 55 f8	 mov	 edx, DWORD PTR _bpb$[ebp]
  00145	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00149	8b 55 f8	 mov	 edx, DWORD PTR _bpb$[ebp]
  0014c	0f af 42 24	 imul	 eax, DWORD PTR [edx+36]
  00150	03 c8		 add	 ecx, eax
  00152	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  00155	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00158	2b d1		 sub	 edx, ecx
  0015a	8b 45 f4	 mov	 eax, DWORD PTR _fat$[ebp]
  0015d	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 739  :     fat->fat_total_clus         = FAT32_TOTAL_CLUS(bpb);

  00160	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  00163	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00167	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  0016a	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  0016e	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  00171	0f af 48 24	 imul	 ecx, DWORD PTR [eax+36]
  00175	03 d1		 add	 edx, ecx
  00177	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  0017a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0017d	2b c2		 sub	 eax, edx
  0017f	8b 55 f8	 mov	 edx, DWORD PTR _bpb$[ebp]
  00182	0f b6 4a 0d	 movzx	 ecx, BYTE PTR [edx+13]
  00186	33 d2		 xor	 edx, edx
  00188	f7 f1		 div	 ecx
  0018a	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  0018d	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 740  :     fat->fat_bytes_per_sect     = bpb->bpb32_bytes_per_sect;

  00190	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  00193	0f b7 48 0b	 movzx	 ecx, WORD PTR [eax+11]
  00197	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  0019a	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 741  :     fat->fat_sects_per_clus     = bpb->bpb32_sects_per_clus;

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  001a0	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  001a4	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  001a7	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 742  :     fat->fat_fat_size           = bpb->bpb32_fat_size32;

  001aa	8b 45 f4	 mov	 eax, DWORD PTR _fat$[ebp]
  001ad	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  001b0	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  001b3	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 743  :     fat->fat_num_of_fat         = bpb->bpb32_num_of_fats;

  001b6	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  001b9	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  001bd	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  001c0	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 744  :     fat->fat_root_clus          = bpb->bpb32_root_clus;

  001c3	8b 45 f4	 mov	 eax, DWORD PTR _fat$[ebp]
  001c6	8b 4d f8	 mov	 ecx, DWORD PTR _bpb$[ebp]
  001c9	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  001cc	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 745  :     fat->fat_rsvd_sectors       = bpb->bpb32_rsvd_sectors;

  001cf	8b 45 f8	 mov	 eax, DWORD PTR _bpb$[ebp]
  001d2	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  001d6	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  001d9	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 746  :     fat->fat_root_dir_sectors   = 0;

  001dc	8b 45 f4	 mov	 eax, DWORD PTR _fat$[ebp]
  001df	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 747  :     Bbuf_release(blkbuf);

  001e6	8b 4d fc	 mov	 ecx, DWORD PTR _blkbuf$[ebp]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 _Bbuf_release
  001ef	83 c4 04	 add	 esp, 4

; 748  : 
; 749  :     fat->fat_free_clus          = 0;

  001f2	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  001f5	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 750  :     fat->fat_next_free          = 0;

  001fc	8b 45 f4	 mov	 eax, DWORD PTR _fat$[ebp]
  001ff	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 751  :     /*  初始化文件系统对象的根目录文件节点  */
; 752  :     fs->fs_root.fn_mount        = NULL;

  00206	8b 4d 08	 mov	 ecx, DWORD PTR _fs$[ebp]
  00209	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 753  :     fs->fs_root.fn_fs           = fs;

  00210	8b 55 08	 mov	 edx, DWORD PTR _fs$[ebp]
  00213	8b 45 08	 mov	 eax, DWORD PTR _fs$[ebp]
  00216	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 754  :     fs->fs_root.fn_fln          = fat->fat_root_clus;

  00219	8b 4d 08	 mov	 ecx, DWORD PTR _fs$[ebp]
  0021c	8b 55 f4	 mov	 edx, DWORD PTR _fat$[ebp]
  0021f	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00222	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 755  :     fs->fs_root.fn_size         = 0;

  00225	8b 4d 08	 mov	 ecx, DWORD PTR _fs$[ebp]
  00228	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
  0022f	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 756  :     fs->fs_root.fn_attr         = FATDIR_ATTR_DIRECTORY;

  00236	8b 55 08	 mov	 edx, DWORD PTR _fs$[ebp]
  00239	c7 42 38 10 00
	00 00		 mov	 DWORD PTR [edx+56], 16	; 00000010H

; 757  :     return RESULT_SUCCEED;

  00240	33 c0		 xor	 eax, eax
$LN2@Fat32_init:

; 758  : }

  00242	8b e5		 mov	 esp, ebp
  00244	5d		 pop	 ebp
  00245	c3		 ret	 0
_Fat32_initial ENDP
_TEXT	ENDS
EXTRN	_Stime_to_time:PROC
EXTRN	_Sdate_to_date:PROC
EXTRN	_Sys_halt:PROC
EXTRN	__printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv84 = -372						; size = 4
_dir$ = -368						; size = 352
_pdo$ = -12						; size = 4
_fs$ = -8						; size = 4
_i$ = -4						; size = 4
_parents$ = 8						; size = 4
_name$ = 12						; size = 4
_flags$ = 16						; size = 4
_fnode$ = 20						; size = 4
_Fat32_fnode_find PROC

; 767  : {

  00250	55		 push	 ebp
  00251	8b ec		 mov	 ebp, esp
  00253	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H

; 768  :     fat_dir_t       dir[FATDIR_MAX_DIRCTORYS];
; 769  :     fs_t          * fs  = NULL;

  00259	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _fs$[ebp], 0

; 770  :     dword_t         pdo = 0;        /* parents directory offset */

  00260	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pdo$[ebp], 0

; 771  :     int             i   = 0;

  00267	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 772  : 
; 773  :     _printk("FAT32 fnode find\n");

  0026e	68 00 00 00 00	 push	 OFFSET $SG2499
  00273	e8 00 00 00 00	 call	 __printk
  00278	83 c4 04	 add	 esp, 4
$LN17@Fat32_fnod:

; 774  :     ASSERT( parents );

  0027b	83 7d 08 00	 cmp	 DWORD PTR _parents$[ebp], 0
  0027f	75 29		 jne	 SHORT $LN16@Fat32_fnod
  00281	68 06 03 00 00	 push	 774			; 00000306H
  00286	68 00 00 00 00	 push	 OFFSET $SG2504
  0028b	68 00 00 00 00	 push	 OFFSET $SG2505
  00290	68 00 00 00 00	 push	 OFFSET $SG2506
  00295	e8 00 00 00 00	 call	 __printf
  0029a	83 c4 10	 add	 esp, 16			; 00000010H
  0029d	68 00 00 00 00	 push	 OFFSET $SG2507
  002a2	e8 00 00 00 00	 call	 _Sys_halt
  002a7	83 c4 04	 add	 esp, 4
$LN16@Fat32_fnod:
  002aa	33 c0		 xor	 eax, eax
  002ac	75 cd		 jne	 SHORT $LN17@Fat32_fnod
$LN13@Fat32_fnod:

; 775  :     ASSERT( fnode );

  002ae	83 7d 14 00	 cmp	 DWORD PTR _fnode$[ebp], 0
  002b2	75 29		 jne	 SHORT $LN12@Fat32_fnod
  002b4	68 07 03 00 00	 push	 775			; 00000307H
  002b9	68 00 00 00 00	 push	 OFFSET $SG2512
  002be	68 00 00 00 00	 push	 OFFSET $SG2513
  002c3	68 00 00 00 00	 push	 OFFSET $SG2514
  002c8	e8 00 00 00 00	 call	 __printf
  002cd	83 c4 10	 add	 esp, 16			; 00000010H
  002d0	68 00 00 00 00	 push	 OFFSET $SG2515
  002d5	e8 00 00 00 00	 call	 _Sys_halt
  002da	83 c4 04	 add	 esp, 4
$LN12@Fat32_fnod:
  002dd	33 c9		 xor	 ecx, ecx
  002df	75 cd		 jne	 SHORT $LN13@Fat32_fnod

; 776  : 
; 777  :     if( NULL == name)

  002e1	83 7d 0c 00	 cmp	 DWORD PTR _name$[ebp], 0
  002e5	75 08		 jne	 SHORT $LN9@Fat32_fnod

; 778  :         return RESULT_FAILED;

  002e7	83 c8 ff	 or	 eax, -1
  002ea	e9 15 02 00 00	 jmp	 $LN18@Fat32_fnod
$LN9@Fat32_fnod:

; 779  :     fs = FNODE_GET_FS(parents);

  002ef	8b 55 08	 mov	 edx, DWORD PTR _parents$[ebp]
  002f2	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  002f6	74 0e		 je	 SHORT $LN20@Fat32_fnod
  002f8	8b 45 08	 mov	 eax, DWORD PTR _parents$[ebp]
  002fb	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002fe	89 8d 8c fe ff
	ff		 mov	 DWORD PTR tv84[ebp], ecx
  00304	eb 0c		 jmp	 SHORT $LN21@Fat32_fnod
$LN20@Fat32_fnod:
  00306	8b 55 08	 mov	 edx, DWORD PTR _parents$[ebp]
  00309	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0030c	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
$LN21@Fat32_fnod:
  00312	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR tv84[ebp]
  00318	89 4d f8	 mov	 DWORD PTR _fs$[ebp], ecx

; 780  :     if( RESULT_SUCCEED != 
; 781  :         Fat32_dir_find(FS_DEVICE(fs),FS_PARAM_BLK(fs),
; 782  :             (uint32_t)FAT32_GET_FIRST_CLUS(parents),name,flags,dir,&pdo) )

  0031b	8d 55 f4	 lea	 edx, DWORD PTR _pdo$[ebp]
  0031e	52		 push	 edx
  0031f	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _dir$[ebp]
  00325	50		 push	 eax
  00326	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  00329	51		 push	 ecx
  0032a	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  0032d	52		 push	 edx
  0032e	8b 45 08	 mov	 eax, DWORD PTR _parents$[ebp]
  00331	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00334	51		 push	 ecx
  00335	8b 55 f8	 mov	 edx, DWORD PTR _fs$[ebp]
  00338	83 c2 64	 add	 edx, 100		; 00000064H
  0033b	52		 push	 edx
  0033c	8b 45 f8	 mov	 eax, DWORD PTR _fs$[ebp]
  0033f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00341	51		 push	 ecx
  00342	e8 00 00 00 00	 call	 _Fat32_dir_find
  00347	83 c4 1c	 add	 esp, 28			; 0000001cH
  0034a	85 c0		 test	 eax, eax
  0034c	74 08		 je	 SHORT $LN8@Fat32_fnod

; 783  :         return RESULT_FAILED;

  0034e	83 c8 ff	 or	 eax, -1
  00351	e9 ae 01 00 00	 jmp	 $LN18@Fat32_fnod
$LN8@Fat32_fnod:

; 784  :     for( i = 0 ; i < FATDIR_MAX_DIRCTORYS ; i++)

  00356	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0035d	eb 09		 jmp	 SHORT $LN7@Fat32_fnod
$LN6@Fat32_fnod:
  0035f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00362	83 c2 01	 add	 edx, 1
  00365	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN7@Fat32_fnod:
  00368	83 7d fc 0b	 cmp	 DWORD PTR _i$[ebp], 11	; 0000000bH
  0036c	7d 1a		 jge	 SHORT $LN5@Fat32_fnod

; 785  :     {
; 786  :         if( !FATDIR_IS_LONG_NAME_DIR(dir+i) )

  0036e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00371	c1 e0 05	 shl	 eax, 5
  00374	0f b6 8c 05 9b
	fe ff ff	 movzx	 ecx, BYTE PTR _dir$[ebp+eax+11]
  0037c	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0037f	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00382	74 02		 je	 SHORT $LN4@Fat32_fnod

; 787  :             break;

  00384	eb 02		 jmp	 SHORT $LN5@Fat32_fnod
$LN4@Fat32_fnod:

; 788  :     }

  00386	eb d7		 jmp	 SHORT $LN6@Fat32_fnod
$LN5@Fat32_fnod:

; 789  :     //Fat32_directory_information(dir + i);
; 790  :     fnode->fn_attr |= FNODE_ATTR_READ|FNODE_ATTR_WRITE;

  00388	8b 55 14	 mov	 edx, DWORD PTR _fnode$[ebp]
  0038b	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0038e	83 c8 06	 or	 eax, 6
  00391	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  00394	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 791  :     if( dir[i].fdir_attr & FATDIR_ATTR_READ_ONLY )

  00397	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0039a	c1 e2 05	 shl	 edx, 5
  0039d	0f b6 84 15 9b
	fe ff ff	 movzx	 eax, BYTE PTR _dir$[ebp+edx+11]
  003a5	83 e0 01	 and	 eax, 1
  003a8	74 0f		 je	 SHORT $LN3@Fat32_fnod

; 792  :         fnode->fn_attr &= ~FNODE_ATTR_WRITE;

  003aa	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  003ad	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  003b0	83 e2 fb	 and	 edx, -5			; fffffffbH
  003b3	8b 45 14	 mov	 eax, DWORD PTR _fnode$[ebp]
  003b6	89 50 20	 mov	 DWORD PTR [eax+32], edx
$LN3@Fat32_fnod:

; 793  :     if( dir[i].fdir_attr & FATDIR_ATTR_DIRECTORY )

  003b9	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  003bc	c1 e1 05	 shl	 ecx, 5
  003bf	0f b6 94 0d 9b
	fe ff ff	 movzx	 edx, BYTE PTR _dir$[ebp+ecx+11]
  003c7	83 e2 10	 and	 edx, 16			; 00000010H
  003ca	74 0f		 je	 SHORT $LN2@Fat32_fnod

; 794  :         fnode->fn_attr |= FNODE_ATTR_DIRECTORY;

  003cc	8b 45 14	 mov	 eax, DWORD PTR _fnode$[ebp]
  003cf	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003d2	83 c9 01	 or	 ecx, 1
  003d5	8b 55 14	 mov	 edx, DWORD PTR _fnode$[ebp]
  003d8	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
$LN2@Fat32_fnod:

; 795  :     if( dir[i].fdir_attr & FATDIR_ATTR_HIDDEN)

  003db	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  003de	c1 e0 05	 shl	 eax, 5
  003e1	0f b6 8c 05 9b
	fe ff ff	 movzx	 ecx, BYTE PTR _dir$[ebp+eax+11]
  003e9	83 e1 02	 and	 ecx, 2
  003ec	74 0f		 je	 SHORT $LN1@Fat32_fnod

; 796  :         fnode->fn_attr |= FNODE_ATTR_HIDDEN;

  003ee	8b 55 14	 mov	 edx, DWORD PTR _fnode$[ebp]
  003f1	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  003f4	83 c8 08	 or	 eax, 8
  003f7	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  003fa	89 41 20	 mov	 DWORD PTR [ecx+32], eax
$LN1@Fat32_fnod:

; 797  :     fnode->fn_fs        = parents->fn_fs;

  003fd	8b 55 14	 mov	 edx, DWORD PTR _fnode$[ebp]
  00400	8b 45 08	 mov	 eax, DWORD PTR _parents$[ebp]
  00403	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00406	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 798  :     fnode->fn_mount     = NULL;

  00409	8b 55 14	 mov	 edx, DWORD PTR _fnode$[ebp]
  0040c	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 799  :     fnode->fn_fln       = FATDIR_FIRST_CLUSTER(dir + i);

  00413	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00416	c1 e0 05	 shl	 eax, 5
  00419	0f b7 8c 05 a4
	fe ff ff	 movzx	 ecx, WORD PTR _dir$[ebp+eax+20]
  00421	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00424	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00427	c1 e2 05	 shl	 edx, 5
  0042a	0f b7 84 15 aa
	fe ff ff	 movzx	 eax, WORD PTR _dir$[ebp+edx+26]
  00432	03 c8		 add	 ecx, eax
  00434	8b 55 14	 mov	 edx, DWORD PTR _fnode$[ebp]
  00437	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 800  :     fnode->fn_size      = dir[i].fdir_fsize;

  0043a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0043d	c1 e0 05	 shl	 eax, 5
  00440	8b 8c 05 ac fe
	ff ff		 mov	 ecx, DWORD PTR _dir$[ebp+eax+28]
  00447	33 d2		 xor	 edx, edx
  00449	8b 45 14	 mov	 eax, DWORD PTR _fnode$[ebp]
  0044c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0044f	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 801  :     Sdate_to_date(dir[i].fdir_cd,&fnode->fn_cd);

  00452	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  00455	83 c1 24	 add	 ecx, 36			; 00000024H
  00458	51		 push	 ecx
  00459	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0045c	c1 e2 05	 shl	 edx, 5
  0045f	66 8b 84 15 a0
	fe ff ff	 mov	 ax, WORD PTR _dir$[ebp+edx+16]
  00467	50		 push	 eax
  00468	e8 00 00 00 00	 call	 _Sdate_to_date
  0046d	83 c4 08	 add	 esp, 8

; 802  :     Stime_to_time(dir[i].fdir_ct,&fnode->fn_ct);

  00470	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  00473	83 c1 28	 add	 ecx, 40			; 00000028H
  00476	51		 push	 ecx
  00477	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0047a	c1 e2 05	 shl	 edx, 5
  0047d	66 8b 84 15 9e
	fe ff ff	 mov	 ax, WORD PTR _dir$[ebp+edx+14]
  00485	50		 push	 eax
  00486	e8 00 00 00 00	 call	 _Stime_to_time
  0048b	83 c4 08	 add	 esp, 8

; 803  :     Sdate_to_date(dir[i].fdir_lwd,&fnode->fn_lwd);

  0048e	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  00491	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00494	51		 push	 ecx
  00495	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00498	c1 e2 05	 shl	 edx, 5
  0049b	66 8b 84 15 a8
	fe ff ff	 mov	 ax, WORD PTR _dir$[ebp+edx+24]
  004a3	50		 push	 eax
  004a4	e8 00 00 00 00	 call	 _Sdate_to_date
  004a9	83 c4 08	 add	 esp, 8

; 804  :     Stime_to_time(dir[i].fdir_lwt,&fnode->fn_lwt);

  004ac	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  004af	83 c1 30	 add	 ecx, 48			; 00000030H
  004b2	51		 push	 ecx
  004b3	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  004b6	c1 e2 05	 shl	 edx, 5
  004b9	66 8b 84 15 a6
	fe ff ff	 mov	 ax, WORD PTR _dir$[ebp+edx+22]
  004c1	50		 push	 eax
  004c2	e8 00 00 00 00	 call	 _Stime_to_time
  004c7	83 c4 08	 add	 esp, 8

; 805  :     Sdate_to_date(dir[i].fdir_lad,&fnode->fn_lad);

  004ca	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  004cd	83 c1 34	 add	 ecx, 52			; 00000034H
  004d0	51		 push	 ecx
  004d1	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  004d4	c1 e2 05	 shl	 edx, 5
  004d7	66 8b 84 15 a2
	fe ff ff	 mov	 ax, WORD PTR _dir$[ebp+edx+18]
  004df	50		 push	 eax
  004e0	e8 00 00 00 00	 call	 _Sdate_to_date
  004e5	83 c4 08	 add	 esp, 8

; 806  :     /*  记录目录在目录文件中的位置  */
; 807  :     fnode->fn_pd_fln    = FAT32_GET_FIRST_CLUS(parents);

  004e8	8b 4d 14	 mov	 ecx, DWORD PTR _fnode$[ebp]
  004eb	8b 55 08	 mov	 edx, DWORD PTR _parents$[ebp]
  004ee	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  004f1	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 808  :     fnode->fn_pd_offset = pdo;

  004f4	8b 4d f4	 mov	 ecx, DWORD PTR _pdo$[ebp]
  004f7	33 d2		 xor	 edx, edx
  004f9	8b 45 14	 mov	 eax, DWORD PTR _fnode$[ebp]
  004fc	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  004ff	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 809  : 
; 810  :     return RESULT_SUCCEED;

  00502	33 c0		 xor	 eax, eax
$LN18@Fat32_fnod:

; 811  : }

  00504	8b e5		 mov	 esp, ebp
  00506	5d		 pop	 ebp
  00507	c3		 ret	 0
_Fat32_fnode_find ENDP
_TEXT	ENDS
EXTRN	_Lck_free:PROC
EXTRN	__namecmp:PROC
EXTRN	_Lck_lock:PROC
EXTRN	__memzero:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_clus$ = -300						; size = 4
_result$ = -296						; size = 4
_dircnt$ = -292						; size = 4
_csa$ = -288						; size = 8
__t_bb_$ = -276						; size = 4
_dirname$ = -272					; size = 256
_di$ = -16						; size = 4
_ci$ = -12						; size = 4
_i$ = -8						; size = 4
_dirbuf$ = -4						; size = 4
_hd$ = 8						; size = 4
_fat$ = 12						; size = 4
_dirclus$ = 16						; size = 4
_name$ = 20						; size = 4
_flags$ = 24						; size = 4
_dir$ = 28						; size = 4
_offset$ = 32						; size = 4
_Fat32_dir_find PROC

; 466  : {

  00510	55		 push	 ebp
  00511	8b ec		 mov	 ebp, esp
  00513	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00519	56		 push	 esi
  0051a	57		 push	 edi

; 467  :     result_t        result      = RESULT_FAILED;

  0051b	c7 85 d8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _result$[ebp], -1

; 468  :     uint64_t        csa         = 0;/* cluster sector address*/

  00525	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _csa$[ebp], 0
  0052f	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _csa$[ebp+4], 0

; 469  :     uint32_t        clus        = dirclus;

  00539	8b 45 10	 mov	 eax, DWORD PTR _dirclus$[ebp]
  0053c	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _clus$[ebp], eax

; 470  :     uint_t          i           = 0,    /* sectoer index    */

  00542	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 471  :                     ci          = 0,    /* cluster index    */

  00549	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ci$[ebp], 0

; 472  :                     di          = 0;    /* directory index  */

  00550	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _di$[ebp], 0

; 473  :     int             dircnt      = 0;

  00557	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dircnt$[ebp], 0

; 474  :     fat_dir_t     * dirbuf      = NULL;

  00561	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dirbuf$[ebp], 0

; 475  :     char            dirname[256];
; 476  :     BBUF_DECLARE();

  00568	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __t_bb_$[ebp], 0

; 477  : 
; 478  :     if( dirclus == 0 )

  00572	83 7d 10 00	 cmp	 DWORD PTR _dirclus$[ebp], 0
  00576	75 08		 jne	 SHORT $LN20@Fat32_dir_

; 479  :         return -1;

  00578	83 c8 ff	 or	 eax, -1
  0057b	e9 b6 02 00 00	 jmp	 $LN21@Fat32_dir_
$LN20@Fat32_dir_:

; 480  :     _memzero(dir,sizeof(fat_dir_t)*11);

  00580	68 60 01 00 00	 push	 352			; 00000160H
  00585	8b 4d 1c	 mov	 ecx, DWORD PTR _dir$[ebp]
  00588	51		 push	 ecx
  00589	e8 00 00 00 00	 call	 __memzero
  0058e	83 c4 08	 add	 esp, 8
$fat32_dir_find_begin$2349:

; 481  :     /*  遍历目录文件 */
; 482  : fat32_dir_find_begin:
; 483  :     /*  遍历簇内扇区*/
; 484  :     csa = FAT32_CLUS_TO_SECT(fat,clus);

  00591	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _clus$[ebp]
  00597	83 ea 02	 sub	 edx, 2
  0059a	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  0059d	0f af 50 2c	 imul	 edx, DWORD PTR [eax+44]
  005a1	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  005a4	03 51 20	 add	 edx, DWORD PTR [ecx+32]
  005a7	33 c0		 xor	 eax, eax
  005a9	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  005ac	03 11		 add	 edx, DWORD PTR [ecx]
  005ae	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  005b1	13 c8		 adc	 ecx, eax
  005b3	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _csa$[ebp], edx
  005b9	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _csa$[ebp+4], ecx

; 485  :     for( i = 0 ; i < fat->fat_sects_per_clus ; i++ )

  005bf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  005c6	eb 09		 jmp	 SHORT $LN19@Fat32_dir_
$LN18@Fat32_dir_:
  005c8	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  005cb	83 c2 01	 add	 edx, 1
  005ce	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN19@Fat32_dir_:
  005d1	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  005d4	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  005d7	3b 48 2c	 cmp	 ecx, DWORD PTR [eax+44]
  005da	0f 83 f6 01 00
	00		 jae	 $LN17@Fat32_dir_
$LN16@Fat32_dir_:

; 486  :     {
; 487  :         /*  遍历扇区内目录  */
; 488  :         BBUF_READ_SECTOR(dirbuf,hd,csa + i);

  005e0	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  005e3	33 c0		 xor	 eax, eax
  005e5	03 95 e0 fe ff
	ff		 add	 edx, DWORD PTR _csa$[ebp]
  005eb	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _csa$[ebp+4]
  005f1	13 c8		 adc	 ecx, eax
  005f3	51		 push	 ecx
  005f4	52		 push	 edx
  005f5	8b 55 08	 mov	 edx, DWORD PTR _hd$[ebp]
  005f8	52		 push	 edx
  005f9	e8 00 00 00 00	 call	 _Bbuf_read
  005fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00601	89 85 ec fe ff
	ff		 mov	 DWORD PTR __t_bb_$[ebp], eax
  00607	83 bd ec fe ff
	ff 00		 cmp	 DWORD PTR __t_bb_$[ebp], 0
  0060e	74 35		 je	 SHORT $LN13@Fat32_dir_
  00610	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00613	33 c9		 xor	 ecx, ecx
  00615	03 85 e0 fe ff
	ff		 add	 eax, DWORD PTR _csa$[ebp]
  0061b	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _csa$[ebp+4]
  00621	13 d1		 adc	 edx, ecx
  00623	83 e0 07	 and	 eax, 7
  00626	83 e2 00	 and	 edx, 0
  00629	6a 00		 push	 0
  0062b	68 00 02 00 00	 push	 512			; 00000200H
  00630	52		 push	 edx
  00631	50		 push	 eax
  00632	e8 00 00 00 00	 call	 __allmul
  00637	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR __t_bb_$[ebp]
  0063d	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  00640	89 45 fc	 mov	 DWORD PTR _dirbuf$[ebp], eax
  00643	eb 07		 jmp	 SHORT $LN15@Fat32_dir_
$LN13@Fat32_dir_:
  00645	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dirbuf$[ebp], 0
$LN15@Fat32_dir_:
  0064c	33 d2		 xor	 edx, edx
  0064e	75 90		 jne	 SHORT $LN16@Fat32_dir_

; 489  :         if( NULL == dirbuf )

  00650	83 7d fc 00	 cmp	 DWORD PTR _dirbuf$[ebp], 0
  00654	75 05		 jne	 SHORT $LN11@Fat32_dir_

; 490  :             goto fat32_dir_find_end;

  00656	e9 d5 01 00 00	 jmp	 $fat32_dir_find_end$2363
$LN11@Fat32_dir_:

; 491  :         BBUF_LOCK();

  0065b	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR __t_bb_$[ebp]
  00661	83 c0 18	 add	 eax, 24			; 00000018H
  00664	50		 push	 eax
  00665	e8 00 00 00 00	 call	 _Lck_lock
  0066a	83 c4 04	 add	 esp, 4

; 492  :         for( di = 0  ; di < 16 ; di++)

  0066d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _di$[ebp], 0
  00674	eb 09		 jmp	 SHORT $LN10@Fat32_dir_
$LN9@Fat32_dir_:
  00676	8b 4d f0	 mov	 ecx, DWORD PTR _di$[ebp]
  00679	83 c1 01	 add	 ecx, 1
  0067c	89 4d f0	 mov	 DWORD PTR _di$[ebp], ecx
$LN10@Fat32_dir_:
  0067f	83 7d f0 10	 cmp	 DWORD PTR _di$[ebp], 16	; 00000010H
  00683	0f 83 27 01 00
	00		 jae	 $LN8@Fat32_dir_

; 493  :         {
; 494  :             /*  到达目录文件末尾*/
; 495  :             if( 0 == *dirbuf[di].fdir_name )

  00689	8b 55 f0	 mov	 edx, DWORD PTR _di$[ebp]
  0068c	c1 e2 05	 shl	 edx, 5
  0068f	8b 45 fc	 mov	 eax, DWORD PTR _dirbuf$[ebp]
  00692	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00696	85 c9		 test	 ecx, ecx
  00698	75 05		 jne	 SHORT $LN7@Fat32_dir_

; 496  :                 goto fat32_dir_find_release;

  0069a	e9 70 01 00 00	 jmp	 $fat32_dir_find_release$2368
$LN7@Fat32_dir_:

; 497  :             /*  本目录未使用    */
; 498  :             if( 0xE5 == *dirbuf[di].fdir_name )

  0069f	8b 55 f0	 mov	 edx, DWORD PTR _di$[ebp]
  006a2	c1 e2 05	 shl	 edx, 5
  006a5	8b 45 fc	 mov	 eax, DWORD PTR _dirbuf$[ebp]
  006a8	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  006ac	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  006b2	75 1d		 jne	 SHORT $LN6@Fat32_dir_

; 499  :             {
; 500  :                 dircnt = 0;

  006b4	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dircnt$[ebp], 0

; 501  :                 _memzero(dir,sizeof(fat_dir_t)*11);

  006be	68 60 01 00 00	 push	 352			; 00000160H
  006c3	8b 55 1c	 mov	 edx, DWORD PTR _dir$[ebp]
  006c6	52		 push	 edx
  006c7	e8 00 00 00 00	 call	 __memzero
  006cc	83 c4 08	 add	 esp, 8

; 502  :                 continue;

  006cf	eb a5		 jmp	 SHORT $LN9@Fat32_dir_
$LN6@Fat32_dir_:

; 503  :             }
; 504  :             /*  到达这里说明发现有效目录，检测属性 */
; 505  :             dir[dircnt++] = dirbuf[di];

  006d1	8b 75 f0	 mov	 esi, DWORD PTR _di$[ebp]
  006d4	c1 e6 05	 shl	 esi, 5
  006d7	03 75 fc	 add	 esi, DWORD PTR _dirbuf$[ebp]
  006da	8b bd dc fe ff
	ff		 mov	 edi, DWORD PTR _dircnt$[ebp]
  006e0	c1 e7 05	 shl	 edi, 5
  006e3	03 7d 1c	 add	 edi, DWORD PTR _dir$[ebp]
  006e6	b9 08 00 00 00	 mov	 ecx, 8
  006eb	f3 a5		 rep movsd
  006ed	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _dircnt$[ebp]
  006f3	83 c0 01	 add	 eax, 1
  006f6	89 85 dc fe ff
	ff		 mov	 DWORD PTR _dircnt$[ebp], eax

; 506  :             if( FATDIR_IS_LONG_NAME_DIR(dirbuf+di) )

  006fc	8b 4d f0	 mov	 ecx, DWORD PTR _di$[ebp]
  006ff	c1 e1 05	 shl	 ecx, 5
  00702	8b 55 fc	 mov	 edx, DWORD PTR _dirbuf$[ebp]
  00705	0f b6 44 0a 0b	 movzx	 eax, BYTE PTR [edx+ecx+11]
  0070a	83 e0 3f	 and	 eax, 63			; 0000003fH
  0070d	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00710	75 05		 jne	 SHORT $LN5@Fat32_dir_

; 507  :                 continue;

  00712	e9 5f ff ff ff	 jmp	 $LN9@Fat32_dir_
$LN5@Fat32_dir_:

; 508  :             /*  如果明确要求查找文件 */
; 509  :             if( flags & FAT32_DIR_FIND_FILE )

  00717	8b 4d 18	 mov	 ecx, DWORD PTR _flags$[ebp]
  0071a	83 e1 01	 and	 ecx, 1
  0071d	74 18		 je	 SHORT $LN4@Fat32_dir_

; 510  :                 if( dirbuf[di].fdir_attr & FATDIR_ATTR_DIRECTORY )

  0071f	8b 55 f0	 mov	 edx, DWORD PTR _di$[ebp]
  00722	c1 e2 05	 shl	 edx, 5
  00725	8b 45 fc	 mov	 eax, DWORD PTR _dirbuf$[ebp]
  00728	0f b6 4c 10 0b	 movzx	 ecx, BYTE PTR [eax+edx+11]
  0072d	83 e1 10	 and	 ecx, 16			; 00000010H
  00730	74 05		 je	 SHORT $LN4@Fat32_dir_

; 511  :                     continue;

  00732	e9 3f ff ff ff	 jmp	 $LN9@Fat32_dir_
$LN4@Fat32_dir_:

; 512  :             //Fat32_directory_information(dirbuf + di);
; 513  :             Fat32_get_directory_name(dir,dirname);

  00737	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _dirname$[ebp]
  0073d	52		 push	 edx
  0073e	8b 45 1c	 mov	 eax, DWORD PTR _dir$[ebp]
  00741	50		 push	 eax
  00742	e8 00 00 00 00	 call	 _Fat32_get_directory_name
  00747	83 c4 08	 add	 esp, 8

; 514  :             if( _namecmp(name,dirname) == 0 )

  0074a	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _dirname$[ebp]
  00750	51		 push	 ecx
  00751	8b 55 14	 mov	 edx, DWORD PTR _name$[ebp]
  00754	52		 push	 edx
  00755	e8 00 00 00 00	 call	 __namecmp
  0075a	83 c4 08	 add	 esp, 8
  0075d	85 c0		 test	 eax, eax
  0075f	75 2f		 jne	 SHORT $LN2@Fat32_dir_

; 515  :             {
; 516  :                 //_printk("name found!\n");
; 517  :                 *offset = ci * fat->fat_clus_size + 
; 518  :                           i * fat->fat_bytes_per_sect +
; 519  :                           di * sizeof(fat_dir_t);

  00761	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  00764	8b 4d f4	 mov	 ecx, DWORD PTR _ci$[ebp]
  00767	0f af 48 30	 imul	 ecx, DWORD PTR [eax+48]
  0076b	8b 55 0c	 mov	 edx, DWORD PTR _fat$[ebp]
  0076e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00771	0f af 42 28	 imul	 eax, DWORD PTR [edx+40]
  00775	03 c8		 add	 ecx, eax
  00777	8b 55 f0	 mov	 edx, DWORD PTR _di$[ebp]
  0077a	c1 e2 05	 shl	 edx, 5
  0077d	03 ca		 add	 ecx, edx
  0077f	8b 45 20	 mov	 eax, DWORD PTR _offset$[ebp]
  00782	89 08		 mov	 DWORD PTR [eax], ecx

; 520  :                 result = RESULT_SUCCEED;

  00784	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _result$[ebp], 0

; 521  :                 goto fat32_dir_find_release;

  0078e	eb 7f		 jmp	 SHORT $fat32_dir_find_release$2368
$LN2@Fat32_dir_:

; 522  :             }
; 523  : 
; 524  :             /*  处理完毕后清零 */
; 525  :             _memzero(dir,sizeof(fat_dir_t)*11);

  00790	68 60 01 00 00	 push	 352			; 00000160H
  00795	8b 4d 1c	 mov	 ecx, DWORD PTR _dir$[ebp]
  00798	51		 push	 ecx
  00799	e8 00 00 00 00	 call	 __memzero
  0079e	83 c4 08	 add	 esp, 8

; 526  :             dircnt = 0;

  007a1	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dircnt$[ebp], 0

; 527  :         }

  007ab	e9 c6 fe ff ff	 jmp	 $LN9@Fat32_dir_
$LN8@Fat32_dir_:

; 528  :         BBUF_FREE();

  007b0	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR __t_bb_$[ebp]
  007b6	83 c2 18	 add	 edx, 24			; 00000018H
  007b9	52		 push	 edx
  007ba	e8 00 00 00 00	 call	 _Lck_free
  007bf	83 c4 04	 add	 esp, 4

; 529  :         BBUF_RELEASE();

  007c2	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR __t_bb_$[ebp]
  007c8	50		 push	 eax
  007c9	e8 00 00 00 00	 call	 _Bbuf_release
  007ce	83 c4 04	 add	 esp, 4

; 530  :     }

  007d1	e9 f2 fd ff ff	 jmp	 $LN18@Fat32_dir_
$LN17@Fat32_dir_:

; 531  :     ci++;

  007d6	8b 4d f4	 mov	 ecx, DWORD PTR _ci$[ebp]
  007d9	83 c1 01	 add	 ecx, 1
  007dc	89 4d f4	 mov	 DWORD PTR _ci$[ebp], ecx

; 532  :     clus = Fat32_next_cluster(hd,fat,clus);

  007df	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _clus$[ebp]
  007e5	52		 push	 edx
  007e6	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  007e9	50		 push	 eax
  007ea	8b 4d 08	 mov	 ecx, DWORD PTR _hd$[ebp]
  007ed	51		 push	 ecx
  007ee	e8 00 00 00 00	 call	 _Fat32_next_cluster
  007f3	83 c4 0c	 add	 esp, 12			; 0000000cH
  007f6	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _clus$[ebp], eax

; 533  :     if( clus < FAT32_END_OF_CLUS )

  007fc	81 bd d4 fe ff
	ff f8 ff ff 0f	 cmp	 DWORD PTR _clus$[ebp], 268435448 ; 0ffffff8H
  00806	73 05		 jae	 SHORT $LN1@Fat32_dir_

; 534  :         goto fat32_dir_find_begin;

  00808	e9 84 fd ff ff	 jmp	 $fat32_dir_find_begin$2349
$LN1@Fat32_dir_:

; 535  :     goto fat32_dir_find_end;

  0080d	eb 21		 jmp	 SHORT $fat32_dir_find_end$2363
$fat32_dir_find_release$2368:

; 536  : fat32_dir_find_release:
; 537  :     BBUF_FREE();

  0080f	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR __t_bb_$[ebp]
  00815	83 c2 18	 add	 edx, 24			; 00000018H
  00818	52		 push	 edx
  00819	e8 00 00 00 00	 call	 _Lck_free
  0081e	83 c4 04	 add	 esp, 4

; 538  :     BBUF_RELEASE();

  00821	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR __t_bb_$[ebp]
  00827	50		 push	 eax
  00828	e8 00 00 00 00	 call	 _Bbuf_release
  0082d	83 c4 04	 add	 esp, 4
$fat32_dir_find_end$2363:

; 539  : fat32_dir_find_end:
; 540  :     return result;

  00830	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _result$[ebp]
$LN21@Fat32_dir_:

; 541  : }

  00836	5f		 pop	 edi
  00837	5e		 pop	 esi
  00838	8b e5		 mov	 esp, ebp
  0083a	5d		 pop	 ebp
  0083b	c3		 ret	 0
_Fat32_dir_find ENDP
; Function compile flags: /Odtp
_addr$ = -16						; size = 8
_sbb$ = -8						; size = 4
_buf$ = -4						; size = 4
_hd$ = 8						; size = 4
_fat$ = 12						; size = 4
_cluster$ = 16						; size = 4
_Fat32_next_cluster PROC

; 276  : {

  00840	55		 push	 ebp
  00841	8b ec		 mov	 ebp, esp
  00843	83 ec 10	 sub	 esp, 16			; 00000010H

; 277  :     blkbuf_t      * sbb = NULL; /**/

  00846	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sbb$[ebp], 0

; 278  :     byte_t        * buf = NULL;

  0084d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _buf$[ebp], 0

; 279  :     uint64_t        addr= 0;

  00854	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _addr$[ebp], 0
  0085b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _addr$[ebp+4], 0

; 280  : 
; 281  :     addr = FAT32_TSC_TO_HDA(fat,cluster);

  00862	8b 45 10	 mov	 eax, DWORD PTR _cluster$[ebp]
  00865	c1 e0 02	 shl	 eax, 2
  00868	c1 e8 09	 shr	 eax, 9
  0086b	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  0086e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00871	03 d0		 add	 edx, eax
  00873	33 c0		 xor	 eax, eax
  00875	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00878	03 11		 add	 edx, DWORD PTR [ecx]
  0087a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0087d	13 c8		 adc	 ecx, eax
  0087f	89 55 f0	 mov	 DWORD PTR _addr$[ebp], edx
  00882	89 4d f4	 mov	 DWORD PTR _addr$[ebp+4], ecx

; 282  :     if( NULL == (sbb = Bbuf_read(hd,addr) ) )

  00885	8b 55 f4	 mov	 edx, DWORD PTR _addr$[ebp+4]
  00888	52		 push	 edx
  00889	8b 45 f0	 mov	 eax, DWORD PTR _addr$[ebp]
  0088c	50		 push	 eax
  0088d	8b 4d 08	 mov	 ecx, DWORD PTR _hd$[ebp]
  00890	51		 push	 ecx
  00891	e8 00 00 00 00	 call	 _Bbuf_read
  00896	83 c4 0c	 add	 esp, 12			; 0000000cH
  00899	89 45 f8	 mov	 DWORD PTR _sbb$[ebp], eax
  0089c	83 7d f8 00	 cmp	 DWORD PTR _sbb$[ebp], 0
  008a0	75 07		 jne	 SHORT $LN1@Fat32_next

; 283  :         return 0x0FFFFFF8;

  008a2	b8 f8 ff ff 0f	 mov	 eax, 268435448		; 0ffffff8H
  008a7	eb 52		 jmp	 SHORT $LN2@Fat32_next
$LN1@Fat32_next:

; 284  :     buf  = BBUF_TO_SECTOR(sbb,addr);

  008a9	8b 55 f0	 mov	 edx, DWORD PTR _addr$[ebp]
  008ac	83 e2 07	 and	 edx, 7
  008af	8b 45 f4	 mov	 eax, DWORD PTR _addr$[ebp+4]
  008b2	83 e0 00	 and	 eax, 0
  008b5	6a 00		 push	 0
  008b7	68 00 02 00 00	 push	 512			; 00000200H
  008bc	50		 push	 eax
  008bd	52		 push	 edx
  008be	e8 00 00 00 00	 call	 __allmul
  008c3	8b 4d f8	 mov	 ecx, DWORD PTR _sbb$[ebp]
  008c6	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  008c9	89 45 fc	 mov	 DWORD PTR _buf$[ebp], eax

; 285  :     addr = (*(uint32_t *)(buf+FAT32_THIS_SECT_OFFSET(cluster))) & 0x0FFFFFFF;

  008cc	8b 55 10	 mov	 edx, DWORD PTR _cluster$[ebp]
  008cf	c1 e2 02	 shl	 edx, 2
  008d2	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  008d8	8b 45 fc	 mov	 eax, DWORD PTR _buf$[ebp]
  008db	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  008de	81 e1 ff ff ff
	0f		 and	 ecx, 268435455		; 0fffffffH
  008e4	33 d2		 xor	 edx, edx
  008e6	89 4d f0	 mov	 DWORD PTR _addr$[ebp], ecx
  008e9	89 55 f4	 mov	 DWORD PTR _addr$[ebp+4], edx

; 286  :     Bbuf_release(sbb);

  008ec	8b 45 f8	 mov	 eax, DWORD PTR _sbb$[ebp]
  008ef	50		 push	 eax
  008f0	e8 00 00 00 00	 call	 _Bbuf_release
  008f5	83 c4 04	 add	 esp, 4

; 287  : 
; 288  :     return (uint32_t)addr;

  008f8	8b 45 f0	 mov	 eax, DWORD PTR _addr$[ebp]
$LN2@Fat32_next:

; 289  : }

  008fb	8b e5		 mov	 esp, ebp
  008fd	5d		 pop	 ebp
  008fe	c3		 ret	 0
_Fat32_next_cluster ENDP
; Function compile flags: /Odtp
_retname$ = -16					; size = 4
_lndi$ = -12						; size = 4
_i$ = -8						; size = 4
_lndir$ = -4						; size = 4
_dir$ = 8						; size = 4
_name$ = 12						; size = 4
_Fat32_get_directory_name PROC

; 360  : {

  00900	55		 push	 ebp
  00901	8b ec		 mov	 ebp, esp
  00903	83 ec 10	 sub	 esp, 16			; 00000010H

; 361  :     int             i       = 0,    /*  index                       */

  00906	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 362  :                     lndi    = 0;    /*  long name directory index   */

  0090d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lndi$[ebp], 0

; 363  :     fdir_lnentry_t* lndir   = NULL; /*  long name directory         */

  00914	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _lndir$[ebp], 0

; 364  :     char          * retname = name; /*  return name                 */

  0091b	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  0091e	89 45 f0	 mov	 DWORD PTR _retname$[ebp], eax

; 365  : 
; 366  :     /*  判断长、短文件名    */
; 367  :     if( FATDIR_IS_LONG_NAME_DIR(dir) )

  00921	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00924	0f b6 51 0b	 movzx	 edx, BYTE PTR [ecx+11]
  00928	83 e2 3f	 and	 edx, 63			; 0000003fH
  0092b	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  0092e	75 2d		 jne	 SHORT $LN38@Fat32_get_

; 368  :     {
; 369  :         /*  计算占用的目录数    */
; 370  :         i = 0;

  00930	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN37@Fat32_get_:

; 371  :         while( FATDIR_IS_LONG_NAME_DIR(dir + i) )

  00937	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0093a	c1 e0 05	 shl	 eax, 5
  0093d	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00940	0f b6 54 01 0b	 movzx	 edx, BYTE PTR [ecx+eax+11]
  00945	83 e2 3f	 and	 edx, 63			; 0000003fH
  00948	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  0094b	75 0b		 jne	 SHORT $LN36@Fat32_get_

; 372  :             i++;

  0094d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00950	83 c0 01	 add	 eax, 1
  00953	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00956	eb df		 jmp	 SHORT $LN37@Fat32_get_
$LN36@Fat32_get_:

; 373  :         goto fat32_get_long_name;

  00958	e9 85 00 00 00	 jmp	 $fat32_get_long_name$2269
$LN38@Fat32_get_:

; 374  :     }
; 375  :     /*  处理短文件名    */
; 376  :     for( i = 0 ; i < 11 ; i++)

  0095d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00964	eb 09		 jmp	 SHORT $LN35@Fat32_get_
$LN34@Fat32_get_:
  00966	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00969	83 c1 01	 add	 ecx, 1
  0096c	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN35@Fat32_get_:
  0096f	83 7d f8 0b	 cmp	 DWORD PTR _i$[ebp], 11	; 0000000bH
  00973	7d 68		 jge	 SHORT $LN33@Fat32_get_

; 377  :     {
; 378  :         if( i < 8  && dir->fdir_name[i] == 0x20 )

  00975	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  00979	7d 10		 jge	 SHORT $LN32@Fat32_get_
  0097b	8b 55 08	 mov	 edx, DWORD PTR _dir$[ebp]
  0097e	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00981	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00984	83 f8 20	 cmp	 eax, 32			; 00000020H
  00987	75 02		 jne	 SHORT $LN32@Fat32_get_

; 379  :             continue;

  00989	eb db		 jmp	 SHORT $LN34@Fat32_get_
$LN32@Fat32_get_:

; 380  :         if( i < 11 && dir->fdir_name[i] == 0x20 )

  0098b	83 7d f8 0b	 cmp	 DWORD PTR _i$[ebp], 11	; 0000000bH
  0098f	7d 13		 jge	 SHORT $LN31@Fat32_get_
  00991	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00994	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00997	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0099a	83 fa 20	 cmp	 edx, 32			; 00000020H
  0099d	75 05		 jne	 SHORT $LN31@Fat32_get_

; 381  :             goto fat32_get_name_end;

  0099f	e9 e3 01 00 00	 jmp	 $fat32_get_name_end$2275
$LN31@Fat32_get_:

; 382  :         if( i == 8 && dir->fdir_name[8] != 0x20 )

  009a4	83 7d f8 08	 cmp	 DWORD PTR _i$[ebp], 8
  009a8	75 1b		 jne	 SHORT $LN30@Fat32_get_
  009aa	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  009ad	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  009b1	83 f9 20	 cmp	 ecx, 32			; 00000020H
  009b4	74 0f		 je	 SHORT $LN30@Fat32_get_

; 383  :             *name++ = '.';

  009b6	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  009b9	c6 02 2e	 mov	 BYTE PTR [edx], 46	; 0000002eH
  009bc	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  009bf	83 c0 01	 add	 eax, 1
  009c2	89 45 0c	 mov	 DWORD PTR _name$[ebp], eax
$LN30@Fat32_get_:

; 384  :         *name++ = dir->fdir_name[i];

  009c5	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  009c8	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  009cb	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  009ce	8a 01		 mov	 al, BYTE PTR [ecx]
  009d0	88 02		 mov	 BYTE PTR [edx], al
  009d2	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  009d5	83 c1 01	 add	 ecx, 1
  009d8	89 4d 0c	 mov	 DWORD PTR _name$[ebp], ecx

; 385  :     }

  009db	eb 89		 jmp	 SHORT $LN34@Fat32_get_
$LN33@Fat32_get_:

; 386  :     goto fat32_get_name_end;

  009dd	e9 a5 01 00 00	 jmp	 $fat32_get_name_end$2275
$fat32_get_long_name$2269:

; 387  : 
; 388  :     /*  处理长文件名，由于是反向安排目录位置，需要反向处理  */
; 389  : fat32_get_long_name:
; 390  :     if( i < 0 )

  009e2	83 7d f8 00	 cmp	 DWORD PTR _i$[ebp], 0
  009e6	7d 05		 jge	 SHORT $LN29@Fat32_get_

; 391  :         goto fat32_get_name_end;

  009e8	e9 9a 01 00 00	 jmp	 $fat32_get_name_end$2275
$LN29@Fat32_get_:

; 392  :     /*  跳过长名目录附带的短文件名目录  */
; 393  :     if( !FATDIR_IS_LONG_NAME_DIR(dir+i) )

  009ed	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  009f0	c1 e2 05	 shl	 edx, 5
  009f3	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  009f6	0f b6 4c 10 0b	 movzx	 ecx, BYTE PTR [eax+edx+11]
  009fb	83 e1 3f	 and	 ecx, 63			; 0000003fH
  009fe	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00a01	74 0b		 je	 SHORT $LN28@Fat32_get_

; 394  :     {
; 395  :         i--;

  00a03	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00a06	83 ea 01	 sub	 edx, 1
  00a09	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 396  :         goto fat32_get_long_name;

  00a0c	eb d4		 jmp	 SHORT $fat32_get_long_name$2269
$LN28@Fat32_get_:

; 397  :     }
; 398  :     lndir = (fdir_lnentry_t *)(dir + i--);

  00a0e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00a11	c1 e0 05	 shl	 eax, 5
  00a14	03 45 08	 add	 eax, DWORD PTR _dir$[ebp]
  00a17	89 45 fc	 mov	 DWORD PTR _lndir$[ebp], eax
  00a1a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00a1d	83 e9 01	 sub	 ecx, 1
  00a20	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx

; 399  :     /*  长名目录将文件名分成了3个部分，所以要分开处理 */
; 400  :     /*  处理第1部分 */
; 401  :     for( lndi = 0 ; lndi < 5 ; lndi++ )

  00a23	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lndi$[ebp], 0
  00a2a	eb 09		 jmp	 SHORT $LN27@Fat32_get_
$LN26@Fat32_get_:
  00a2c	8b 55 f4	 mov	 edx, DWORD PTR _lndi$[ebp]
  00a2f	83 c2 01	 add	 edx, 1
  00a32	89 55 f4	 mov	 DWORD PTR _lndi$[ebp], edx
$LN27@Fat32_get_:
  00a35	83 7d f4 05	 cmp	 DWORD PTR _lndi$[ebp], 5
  00a39	7d 5e		 jge	 SHORT $LN25@Fat32_get_

; 402  :     {
; 403  :         if( 0 == lndir->fdl_name1[lndi] )

  00a3b	8b 45 f4	 mov	 eax, DWORD PTR _lndi$[ebp]
  00a3e	8b 4d fc	 mov	 ecx, DWORD PTR _lndir$[ebp]
  00a41	0f b7 54 41 01	 movzx	 edx, WORD PTR [ecx+eax*2+1]
  00a46	85 d2		 test	 edx, edx
  00a48	75 05		 jne	 SHORT $LN23@Fat32_get_

; 404  :             goto fat32_get_name_end;

  00a4a	e9 38 01 00 00	 jmp	 $fat32_get_name_end$2275
$LN23@Fat32_get_:

; 405  :         //FAT32_PRINTK(lndir->fdl_name1[lndi]);
; 406  :         FAT32_UNICODE_TO_ANSI(lndir->fdl_name1[lndi],name);

  00a4f	8b 45 f4	 mov	 eax, DWORD PTR _lndi$[ebp]
  00a52	8b 4d fc	 mov	 ecx, DWORD PTR _lndir$[ebp]
  00a55	0f b7 54 41 01	 movzx	 edx, WORD PTR [ecx+eax*2+1]
  00a5a	83 fa 7f	 cmp	 edx, 127		; 0000007fH
  00a5d	7d 1a		 jge	 SHORT $LN20@Fat32_get_
  00a5f	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00a62	8b 4d f4	 mov	 ecx, DWORD PTR _lndi$[ebp]
  00a65	8b 55 fc	 mov	 edx, DWORD PTR _lndir$[ebp]
  00a68	8a 4c 4a 01	 mov	 cl, BYTE PTR [edx+ecx*2+1]
  00a6c	88 08		 mov	 BYTE PTR [eax], cl
  00a6e	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00a71	83 c2 01	 add	 edx, 1
  00a74	89 55 0c	 mov	 DWORD PTR _name$[ebp], edx
  00a77	eb 1a		 jmp	 SHORT $LN22@Fat32_get_
$LN20@Fat32_get_:
  00a79	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00a7c	8b 4d f4	 mov	 ecx, DWORD PTR _lndi$[ebp]
  00a7f	8b 55 fc	 mov	 edx, DWORD PTR _lndir$[ebp]
  00a82	66 8b 4c 4a 01	 mov	 cx, WORD PTR [edx+ecx*2+1]
  00a87	66 89 08	 mov	 WORD PTR [eax], cx
  00a8a	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00a8d	83 c2 02	 add	 edx, 2
  00a90	89 55 0c	 mov	 DWORD PTR _name$[ebp], edx
$LN22@Fat32_get_:
  00a93	33 c0		 xor	 eax, eax
  00a95	75 b8		 jne	 SHORT $LN23@Fat32_get_

; 407  :     }

  00a97	eb 93		 jmp	 SHORT $LN26@Fat32_get_
$LN25@Fat32_get_:

; 408  :     /*  处理第2部分 */
; 409  :     for( lndi = 0 ; lndi < 6 ; lndi++ )

  00a99	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lndi$[ebp], 0
  00aa0	eb 09		 jmp	 SHORT $LN18@Fat32_get_
$LN17@Fat32_get_:
  00aa2	8b 4d f4	 mov	 ecx, DWORD PTR _lndi$[ebp]
  00aa5	83 c1 01	 add	 ecx, 1
  00aa8	89 4d f4	 mov	 DWORD PTR _lndi$[ebp], ecx
$LN18@Fat32_get_:
  00aab	83 7d f4 06	 cmp	 DWORD PTR _lndi$[ebp], 6
  00aaf	7d 5e		 jge	 SHORT $LN16@Fat32_get_

; 410  :     {
; 411  :         if( 0 == lndir->fdl_name2[lndi] )

  00ab1	8b 55 f4	 mov	 edx, DWORD PTR _lndi$[ebp]
  00ab4	8b 45 fc	 mov	 eax, DWORD PTR _lndir$[ebp]
  00ab7	0f b7 4c 50 0e	 movzx	 ecx, WORD PTR [eax+edx*2+14]
  00abc	85 c9		 test	 ecx, ecx
  00abe	75 05		 jne	 SHORT $LN14@Fat32_get_

; 412  :             goto fat32_get_name_end;

  00ac0	e9 c2 00 00 00	 jmp	 $fat32_get_name_end$2275
$LN14@Fat32_get_:

; 413  :         //FAT32_PRINTK(lndir->fdl_name2[lndi]);
; 414  :         FAT32_UNICODE_TO_ANSI(lndir->fdl_name2[lndi],name);

  00ac5	8b 55 f4	 mov	 edx, DWORD PTR _lndi$[ebp]
  00ac8	8b 45 fc	 mov	 eax, DWORD PTR _lndir$[ebp]
  00acb	0f b7 4c 50 0e	 movzx	 ecx, WORD PTR [eax+edx*2+14]
  00ad0	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00ad3	7d 1a		 jge	 SHORT $LN11@Fat32_get_
  00ad5	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00ad8	8b 45 f4	 mov	 eax, DWORD PTR _lndi$[ebp]
  00adb	8b 4d fc	 mov	 ecx, DWORD PTR _lndir$[ebp]
  00ade	8a 44 41 0e	 mov	 al, BYTE PTR [ecx+eax*2+14]
  00ae2	88 02		 mov	 BYTE PTR [edx], al
  00ae4	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00ae7	83 c1 01	 add	 ecx, 1
  00aea	89 4d 0c	 mov	 DWORD PTR _name$[ebp], ecx
  00aed	eb 1a		 jmp	 SHORT $LN13@Fat32_get_
$LN11@Fat32_get_:
  00aef	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00af2	8b 45 f4	 mov	 eax, DWORD PTR _lndi$[ebp]
  00af5	8b 4d fc	 mov	 ecx, DWORD PTR _lndir$[ebp]
  00af8	66 8b 44 41 0e	 mov	 ax, WORD PTR [ecx+eax*2+14]
  00afd	66 89 02	 mov	 WORD PTR [edx], ax
  00b00	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00b03	83 c1 02	 add	 ecx, 2
  00b06	89 4d 0c	 mov	 DWORD PTR _name$[ebp], ecx
$LN13@Fat32_get_:
  00b09	33 d2		 xor	 edx, edx
  00b0b	75 b8		 jne	 SHORT $LN14@Fat32_get_

; 415  :     }

  00b0d	eb 93		 jmp	 SHORT $LN17@Fat32_get_
$LN16@Fat32_get_:

; 416  :     /*  处理第3部分 */
; 417  :     for( lndi = 0 ; lndi < 2 ; lndi++ )

  00b0f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lndi$[ebp], 0
  00b16	eb 09		 jmp	 SHORT $LN9@Fat32_get_
$LN8@Fat32_get_:
  00b18	8b 45 f4	 mov	 eax, DWORD PTR _lndi$[ebp]
  00b1b	83 c0 01	 add	 eax, 1
  00b1e	89 45 f4	 mov	 DWORD PTR _lndi$[ebp], eax
$LN9@Fat32_get_:
  00b21	83 7d f4 02	 cmp	 DWORD PTR _lndi$[ebp], 2
  00b25	7d 5b		 jge	 SHORT $LN7@Fat32_get_

; 418  :     {
; 419  :         if( 0 == lndir->fdl_name3[lndi] )

  00b27	8b 4d f4	 mov	 ecx, DWORD PTR _lndi$[ebp]
  00b2a	8b 55 fc	 mov	 edx, DWORD PTR _lndir$[ebp]
  00b2d	0f b7 44 4a 1c	 movzx	 eax, WORD PTR [edx+ecx*2+28]
  00b32	85 c0		 test	 eax, eax
  00b34	75 02		 jne	 SHORT $LN5@Fat32_get_

; 420  :             goto fat32_get_name_end;

  00b36	eb 4f		 jmp	 SHORT $fat32_get_name_end$2275
$LN5@Fat32_get_:

; 421  :         //FAT32_PRINTK(lndir->fdl_name3[lndi]);
; 422  :         FAT32_UNICODE_TO_ANSI(lndir->fdl_name3[lndi],name);

  00b38	8b 4d f4	 mov	 ecx, DWORD PTR _lndi$[ebp]
  00b3b	8b 55 fc	 mov	 edx, DWORD PTR _lndir$[ebp]
  00b3e	0f b7 44 4a 1c	 movzx	 eax, WORD PTR [edx+ecx*2+28]
  00b43	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00b46	7d 1a		 jge	 SHORT $LN2@Fat32_get_
  00b48	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00b4b	8b 55 f4	 mov	 edx, DWORD PTR _lndi$[ebp]
  00b4e	8b 45 fc	 mov	 eax, DWORD PTR _lndir$[ebp]
  00b51	8a 54 50 1c	 mov	 dl, BYTE PTR [eax+edx*2+28]
  00b55	88 11		 mov	 BYTE PTR [ecx], dl
  00b57	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00b5a	83 c0 01	 add	 eax, 1
  00b5d	89 45 0c	 mov	 DWORD PTR _name$[ebp], eax
  00b60	eb 1a		 jmp	 SHORT $LN4@Fat32_get_
$LN2@Fat32_get_:
  00b62	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00b65	8b 55 f4	 mov	 edx, DWORD PTR _lndi$[ebp]
  00b68	8b 45 fc	 mov	 eax, DWORD PTR _lndir$[ebp]
  00b6b	66 8b 54 50 1c	 mov	 dx, WORD PTR [eax+edx*2+28]
  00b70	66 89 11	 mov	 WORD PTR [ecx], dx
  00b73	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00b76	83 c0 02	 add	 eax, 2
  00b79	89 45 0c	 mov	 DWORD PTR _name$[ebp], eax
$LN4@Fat32_get_:
  00b7c	33 c9		 xor	 ecx, ecx
  00b7e	75 b8		 jne	 SHORT $LN5@Fat32_get_

; 423  :     }

  00b80	eb 96		 jmp	 SHORT $LN8@Fat32_get_
$LN7@Fat32_get_:

; 424  :     goto fat32_get_long_name;

  00b82	e9 5b fe ff ff	 jmp	 $fat32_get_long_name$2269
$fat32_get_name_end$2275:

; 425  : 
; 426  : fat32_get_name_end:
; 427  :     *name = 0;

  00b87	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00b8a	c6 02 00	 mov	 BYTE PTR [edx], 0

; 428  :     return retname;

  00b8d	8b 45 f0	 mov	 eax, DWORD PTR _retname$[ebp]

; 429  : }

  00b90	8b e5		 mov	 esp, ebp
  00b92	5d		 pop	 ebp
  00b93	c3		 ret	 0
_Fat32_get_directory_name ENDP
; Function compile flags: /Odtp
tv70 = -372						; size = 4
_dir$ = -368						; size = 352
_result$ = -12						; size = 4
_pdo$ = -8						; size = 4
_fs$ = -4						; size = 4
_parents$ = 8						; size = 4
_name$ = 12						; size = 4
_attrs$ = 16						; size = 4
_fnode$ = 20						; size = 4
_Fat32_fnode_create PROC

; 885  : {

  00ba0	55		 push	 ebp
  00ba1	8b ec		 mov	 ebp, esp
  00ba3	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H

; 886  :     fat_dir_t       dir[FATDIR_MAX_DIRCTORYS];
; 887  :     result_t        result  = RESULT_FAILED;

  00ba9	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _result$[ebp], -1

; 888  :     dword_t         pdo     = 0;        /* parents directory offset */

  00bb0	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pdo$[ebp], 0

; 889  :     fs_t          * fs      = NULL;

  00bb7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fs$[ebp], 0

; 890  :     //int             i   = 0;
; 891  : 
; 892  :     _printk("fat32 create fnode\n");

  00bbe	68 00 00 00 00	 push	 OFFSET $SG2600
  00bc3	e8 00 00 00 00	 call	 __printk
  00bc8	83 c4 04	 add	 esp, 4

; 893  :     if( NULL == name)

  00bcb	83 7d 0c 00	 cmp	 DWORD PTR _name$[ebp], 0
  00bcf	75 08		 jne	 SHORT $LN2@Fat32_fnod@2

; 894  :         return RESULT_FAILED;

  00bd1	83 c8 ff	 or	 eax, -1
  00bd4	e9 82 00 00 00	 jmp	 $LN3@Fat32_fnod@2
$LN2@Fat32_fnod@2:

; 895  :     fs = FNODE_GET_FS(parents);

  00bd9	8b 45 08	 mov	 eax, DWORD PTR _parents$[ebp]
  00bdc	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00be0	74 0e		 je	 SHORT $LN5@Fat32_fnod@2
  00be2	8b 4d 08	 mov	 ecx, DWORD PTR _parents$[ebp]
  00be5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00be8	89 95 8c fe ff
	ff		 mov	 DWORD PTR tv70[ebp], edx
  00bee	eb 0c		 jmp	 SHORT $LN6@Fat32_fnod@2
$LN5@Fat32_fnod@2:
  00bf0	8b 45 08	 mov	 eax, DWORD PTR _parents$[ebp]
  00bf3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00bf6	89 8d 8c fe ff
	ff		 mov	 DWORD PTR tv70[ebp], ecx
$LN6@Fat32_fnod@2:
  00bfc	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR tv70[ebp]
  00c02	89 55 fc	 mov	 DWORD PTR _fs$[ebp], edx

; 896  :     /*  查找是否存在重名，存在则返回失败  */
; 897  :     if( RESULT_SUCCEED == 
; 898  :         Fat32_dir_find(FS_DEVICE(fs),FS_PARAM_BLK(fs),
; 899  :             (uint32_t)FAT32_GET_FIRST_CLUS(parents),name,0,dir,&pdo) )

  00c05	8d 45 f8	 lea	 eax, DWORD PTR _pdo$[ebp]
  00c08	50		 push	 eax
  00c09	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _dir$[ebp]
  00c0f	51		 push	 ecx
  00c10	6a 00		 push	 0
  00c12	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00c15	52		 push	 edx
  00c16	8b 45 08	 mov	 eax, DWORD PTR _parents$[ebp]
  00c19	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00c1c	51		 push	 ecx
  00c1d	8b 55 fc	 mov	 edx, DWORD PTR _fs$[ebp]
  00c20	83 c2 64	 add	 edx, 100		; 00000064H
  00c23	52		 push	 edx
  00c24	8b 45 fc	 mov	 eax, DWORD PTR _fs$[ebp]
  00c27	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c29	51		 push	 ecx
  00c2a	e8 00 00 00 00	 call	 _Fat32_dir_find
  00c2f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00c32	85 c0		 test	 eax, eax
  00c34	75 02		 jne	 SHORT $LN1@Fat32_fnod@2

; 900  :         goto fat32_fnode_create_end;

  00c36	eb 20		 jmp	 SHORT $fat32_fnode_create_end$2607
$LN1@Fat32_fnod@2:

; 901  :     _printk("fat32 create fnode.  file not exist！ \n");

  00c38	68 00 00 00 00	 push	 OFFSET $SG2608
  00c3d	e8 00 00 00 00	 call	 __printk
  00c42	83 c4 04	 add	 esp, 4

; 902  :     /*  名称转变为目录条目列表*/
; 903  :     Fat32_name_to_dir(dir,name);

  00c45	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  00c48	52		 push	 edx
  00c49	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _dir$[ebp]
  00c4f	50		 push	 eax
  00c50	e8 00 00 00 00	 call	 _Fat32_name_to_dir
  00c55	83 c4 08	 add	 esp, 8
$fat32_fnode_create_end$2607:

; 904  :     /*  找到目录文件中足够的剩余空间  */
; 905  : 
; 906  :     /*  写入文件    */
; 907  :     //if( Fat32_write(
; 908  : fat32_fnode_create_end:
; 909  :     return result;

  00c58	8b 45 f4	 mov	 eax, DWORD PTR _result$[ebp]
$LN3@Fat32_fnod@2:

; 910  : }

  00c5b	8b e5		 mov	 esp, ebp
  00c5d	5d		 pop	 ebp
  00c5e	c3		 ret	 0
_Fat32_fnode_create ENDP
_TEXT	ENDS
EXTRN	_Time_to_short:PROC
EXTRN	_Date_to_short:PROC
EXTRN	_Machine_time_get:PROC
EXTRN	_Machine_date_get:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_date$ = -12						; size = 4
_time$ = -4						; size = 4
_dir$ = 8						; size = 4
_name$ = 12						; size = 4
_Fat32_name_to_dir PROC

; 850  : {

  00c60	55		 push	 ebp
  00c61	8b ec		 mov	 ebp, esp
  00c63	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 851  :     date_t          date;
; 852  :     time_t          time;
; 853  :     fdir_lnentry_t *lne;
; 854  : 
; 855  :     if( !Fat32_is_short_dir_name(name) )

  00c66	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00c69	50		 push	 eax
  00c6a	e8 00 00 00 00	 call	 _Fat32_is_short_dir_name
  00c6f	83 c4 04	 add	 esp, 4
  00c72	85 c0		 test	 eax, eax
  00c74	75 02		 jne	 SHORT $LN1@Fat32_name

; 856  :         goto fat32_long_dir_name;

  00c76	eb 1f		 jmp	 SHORT $fat32_long_dir_name$2565
$LN1@Fat32_name:

; 857  :     _printk("fat32 create short name\n");

  00c78	68 00 00 00 00	 push	 OFFSET $SG2566
  00c7d	e8 00 00 00 00	 call	 __printk
  00c82	83 c4 04	 add	 esp, 4

; 858  :     Fat32_name_to_short_name(dir->fdir_name,name);

  00c85	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00c88	51		 push	 ecx
  00c89	8b 55 08	 mov	 edx, DWORD PTR _dir$[ebp]
  00c8c	52		 push	 edx
  00c8d	e8 00 00 00 00	 call	 _Fat32_name_to_short_name
  00c92	83 c4 08	 add	 esp, 8

; 859  :     goto fat32_name_to_dir_end;

  00c95	eb 11		 jmp	 SHORT $fat32_name_to_dir_end$2567
$fat32_long_dir_name$2565:

; 860  : fat32_long_dir_name:
; 861  :     /*  处理长文件名，受最大长度。原始文件名消耗完毕或者达到最大长度，都要停止 */
; 862  :     dir->fdir_fsize     = 0;

  00c97	8b 45 08	 mov	 eax, DWORD PTR _dir$[ebp]
  00c9a	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 863  :     dir->fdir_nt_rsvd   = 1;

  00ca1	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00ca4	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
$fat32_name_to_dir_end$2567:

; 864  : fat32_name_to_dir_end:
; 865  :     Machine_date_get(&date);

  00ca8	8d 55 f4	 lea	 edx, DWORD PTR _date$[ebp]
  00cab	52		 push	 edx
  00cac	e8 00 00 00 00	 call	 _Machine_date_get
  00cb1	83 c4 04	 add	 esp, 4

; 866  :     Machine_time_get(&time);

  00cb4	8d 45 fc	 lea	 eax, DWORD PTR _time$[ebp]
  00cb7	50		 push	 eax
  00cb8	e8 00 00 00 00	 call	 _Machine_time_get
  00cbd	83 c4 04	 add	 esp, 4

; 867  :     dir->fdir_cd    = Date_to_short(&date);

  00cc0	8d 4d f4	 lea	 ecx, DWORD PTR _date$[ebp]
  00cc3	51		 push	 ecx
  00cc4	e8 00 00 00 00	 call	 _Date_to_short
  00cc9	83 c4 04	 add	 esp, 4
  00ccc	8b 55 08	 mov	 edx, DWORD PTR _dir$[ebp]
  00ccf	66 89 42 10	 mov	 WORD PTR [edx+16], ax

; 868  :     dir->fdir_ct    = Time_to_short(&time);

  00cd3	8d 45 fc	 lea	 eax, DWORD PTR _time$[ebp]
  00cd6	50		 push	 eax
  00cd7	e8 00 00 00 00	 call	 _Time_to_short
  00cdc	83 c4 04	 add	 esp, 4
  00cdf	8b 4d 08	 mov	 ecx, DWORD PTR _dir$[ebp]
  00ce2	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 869  :     return NULL;

  00ce6	33 c0		 xor	 eax, eax

; 870  : }

  00ce8	8b e5		 mov	 esp, ebp
  00cea	5d		 pop	 ebp
  00ceb	c3		 ret	 0
_Fat32_name_to_dir ENDP
; Function compile flags: /Odtp
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_name$ = 8						; size = 4
_Fat32_is_short_dir_name PROC

; 816  : {

  00cf0	55		 push	 ebp
  00cf1	8b ec		 mov	 ebp, esp
  00cf3	83 ec 08	 sub	 esp, 8

; 817  :     const char    * n = name;

  00cf6	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00cf9	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 818  :     int             i;
; 819  :     /*  严格符合8.3标准，文件名小于等于8字节，扩展名小于等于3字节，中间不能有空格 */
; 820  :     
; 821  :     /*  检测文件名部分 */
; 822  :     for( i = 0 ; i < 8 && *n && '.' != *n ; i++,n++)

  00cfc	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d03	eb 12		 jmp	 SHORT $LN12@Fat32_is_s
$LN11@Fat32_is_s:
  00d05	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00d08	83 c1 01	 add	 ecx, 1
  00d0b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  00d0e	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00d11	83 c2 01	 add	 edx, 1
  00d14	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx
$LN12@Fat32_is_s:
  00d17	83 7d fc 08	 cmp	 DWORD PTR _i$[ebp], 8
  00d1b	7d 29		 jge	 SHORT $LN10@Fat32_is_s
  00d1d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00d20	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00d23	85 c9		 test	 ecx, ecx
  00d25	74 1f		 je	 SHORT $LN10@Fat32_is_s
  00d27	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00d2a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00d2d	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00d30	74 14		 je	 SHORT $LN10@Fat32_is_s

; 823  :     {
; 824  :         /*  段文件名不允许出现空白符，存在则要使用长文件名*/
; 825  :         if( ' ' == *n )

  00d32	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00d35	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00d38	83 fa 20	 cmp	 edx, 32			; 00000020H
  00d3b	75 07		 jne	 SHORT $LN9@Fat32_is_s

; 826  :             return  0;

  00d3d	33 c0		 xor	 eax, eax
  00d3f	e9 8a 00 00 00	 jmp	 $LN13@Fat32_is_s
$LN9@Fat32_is_s:

; 827  :     }

  00d44	eb bf		 jmp	 SHORT $LN11@Fat32_is_s
$LN10@Fat32_is_s:

; 828  :     if( *n &&  '.' != *n )

  00d46	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00d49	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00d4c	85 c9		 test	 ecx, ecx
  00d4e	74 0f		 je	 SHORT $LN7@Fat32_is_s
  00d50	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00d53	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00d56	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00d59	74 04		 je	 SHORT $LN7@Fat32_is_s

; 829  :         return 0;

  00d5b	33 c0		 xor	 eax, eax
  00d5d	eb 6f		 jmp	 SHORT $LN13@Fat32_is_s
$LN7@Fat32_is_s:

; 830  :     /*检测扩展名，过滤中间的点符号*/
; 831  :     while( *n && '.' == *n )

  00d5f	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00d62	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00d65	85 d2		 test	 edx, edx
  00d67	74 16		 je	 SHORT $LN6@Fat32_is_s
  00d69	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00d6c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00d6f	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  00d72	75 0b		 jne	 SHORT $LN6@Fat32_is_s

; 832  :         n++;

  00d74	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00d77	83 c2 01	 add	 edx, 1
  00d7a	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx
  00d7d	eb e0		 jmp	 SHORT $LN7@Fat32_is_s
$LN6@Fat32_is_s:

; 833  :     for( i = 0 ; i < 3 && *n ; i++,n++)

  00d7f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d86	eb 12		 jmp	 SHORT $LN5@Fat32_is_s
$LN4@Fat32_is_s:
  00d88	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00d8b	83 c0 01	 add	 eax, 1
  00d8e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00d91	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00d94	83 c1 01	 add	 ecx, 1
  00d97	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx
$LN5@Fat32_is_s:
  00d9a	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  00d9e	7d 1b		 jge	 SHORT $LN3@Fat32_is_s
  00da0	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00da3	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00da6	85 c0		 test	 eax, eax
  00da8	74 11		 je	 SHORT $LN3@Fat32_is_s

; 834  :     {
; 835  :         if( ' ' == *n )

  00daa	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00dad	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00db0	83 fa 20	 cmp	 edx, 32			; 00000020H
  00db3	75 04		 jne	 SHORT $LN2@Fat32_is_s

; 836  :             return 0;

  00db5	33 c0		 xor	 eax, eax
  00db7	eb 15		 jmp	 SHORT $LN13@Fat32_is_s
$LN2@Fat32_is_s:

; 837  :     }

  00db9	eb cd		 jmp	 SHORT $LN4@Fat32_is_s
$LN3@Fat32_is_s:

; 838  :     if( 0 == *n )

  00dbb	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00dbe	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00dc1	85 c9		 test	 ecx, ecx
  00dc3	75 07		 jne	 SHORT $LN1@Fat32_is_s

; 839  :         return 1;

  00dc5	b8 01 00 00 00	 mov	 eax, 1
  00dca	eb 02		 jmp	 SHORT $LN13@Fat32_is_s
$LN1@Fat32_is_s:

; 840  :     return 0;

  00dcc	33 c0		 xor	 eax, eax
$LN13@Fat32_is_s:

; 841  : }

  00dce	8b e5		 mov	 esp, ebp
  00dd0	5d		 pop	 ebp
  00dd1	c3		 ret	 0
_Fat32_is_short_dir_name ENDP
; Function compile flags: /Odtp
_shortname$ = 8					; size = 4
_name$ = 12						; size = 4
_Fat32_name_to_short_name PROC

; 845  : {

  00de0	55		 push	 ebp
  00de1	8b ec		 mov	 ebp, esp

; 846  :     return shortname;

  00de3	8b 45 08	 mov	 eax, DWORD PTR _shortname$[ebp]

; 847  : }

  00de6	5d		 pop	 ebp
  00de7	c3		 ret	 0
_Fat32_name_to_short_name ENDP
; Function compile flags: /Odtp
tv90 = -8						; size = 4
_fs$ = -4						; size = 4
_fnode$ = 8						; size = 4
_offset$ = 12						; size = 8
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_Fat32_fnode_read PROC

; 918  : {

  00df0	55		 push	 ebp
  00df1	8b ec		 mov	 ebp, esp
  00df3	83 ec 08	 sub	 esp, 8

; 919  :     fs_t          * fs      = NULL;

  00df6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _fs$[ebp], 0
$LN12@Fat32_fnod@3:

; 920  :     
; 921  :     ASSERT(fnode);

  00dfd	83 7d 08 00	 cmp	 DWORD PTR _fnode$[ebp], 0
  00e01	75 29		 jne	 SHORT $LN11@Fat32_fnod@3
  00e03	68 99 03 00 00	 push	 921			; 00000399H
  00e08	68 00 00 00 00	 push	 OFFSET $SG2625
  00e0d	68 00 00 00 00	 push	 OFFSET $SG2626
  00e12	68 00 00 00 00	 push	 OFFSET $SG2627
  00e17	e8 00 00 00 00	 call	 __printf
  00e1c	83 c4 10	 add	 esp, 16			; 00000010H
  00e1f	68 00 00 00 00	 push	 OFFSET $SG2628
  00e24	e8 00 00 00 00	 call	 _Sys_halt
  00e29	83 c4 04	 add	 esp, 4
$LN11@Fat32_fnod@3:
  00e2c	33 c0		 xor	 eax, eax
  00e2e	75 cd		 jne	 SHORT $LN12@Fat32_fnod@3
$LN8@Fat32_fnod@3:

; 922  :     ASSERT(buffer);

  00e30	83 7d 14 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00e34	75 29		 jne	 SHORT $LN7@Fat32_fnod@3
  00e36	68 9a 03 00 00	 push	 922			; 0000039aH
  00e3b	68 00 00 00 00	 push	 OFFSET $SG2633
  00e40	68 00 00 00 00	 push	 OFFSET $SG2634
  00e45	68 00 00 00 00	 push	 OFFSET $SG2635
  00e4a	e8 00 00 00 00	 call	 __printf
  00e4f	83 c4 10	 add	 esp, 16			; 00000010H
  00e52	68 00 00 00 00	 push	 OFFSET $SG2636
  00e57	e8 00 00 00 00	 call	 _Sys_halt
  00e5c	83 c4 04	 add	 esp, 4
$LN7@Fat32_fnod@3:
  00e5f	33 c9		 xor	 ecx, ecx
  00e61	75 cd		 jne	 SHORT $LN8@Fat32_fnod@3
$LN4@Fat32_fnod@3:

; 923  :     ASSERT(size>0);

  00e63	83 7d 18 00	 cmp	 DWORD PTR _size$[ebp], 0
  00e67	7f 29		 jg	 SHORT $LN3@Fat32_fnod@3
  00e69	68 9b 03 00 00	 push	 923			; 0000039bH
  00e6e	68 00 00 00 00	 push	 OFFSET $SG2641
  00e73	68 00 00 00 00	 push	 OFFSET $SG2642
  00e78	68 00 00 00 00	 push	 OFFSET $SG2643
  00e7d	e8 00 00 00 00	 call	 __printf
  00e82	83 c4 10	 add	 esp, 16			; 00000010H
  00e85	68 00 00 00 00	 push	 OFFSET $SG2644
  00e8a	e8 00 00 00 00	 call	 _Sys_halt
  00e8f	83 c4 04	 add	 esp, 4
$LN3@Fat32_fnod@3:
  00e92	33 d2		 xor	 edx, edx
  00e94	75 cd		 jne	 SHORT $LN4@Fat32_fnod@3

; 924  :     _printk("FAT32 fnode read!\n");

  00e96	68 00 00 00 00	 push	 OFFSET $SG2645
  00e9b	e8 00 00 00 00	 call	 __printk
  00ea0	83 c4 04	 add	 esp, 4

; 925  :     fs = FNODE_GET_FS(fnode);

  00ea3	8b 45 08	 mov	 eax, DWORD PTR _fnode$[ebp]
  00ea6	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00eaa	74 0b		 je	 SHORT $LN15@Fat32_fnod@3
  00eac	8b 4d 08	 mov	 ecx, DWORD PTR _fnode$[ebp]
  00eaf	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00eb2	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  00eb5	eb 09		 jmp	 SHORT $LN16@Fat32_fnod@3
$LN15@Fat32_fnod@3:
  00eb7	8b 45 08	 mov	 eax, DWORD PTR _fnode$[ebp]
  00eba	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00ebd	89 4d f8	 mov	 DWORD PTR tv90[ebp], ecx
$LN16@Fat32_fnod@3:
  00ec0	8b 55 f8	 mov	 edx, DWORD PTR tv90[ebp]
  00ec3	89 55 fc	 mov	 DWORD PTR _fs$[ebp], edx

; 926  : 
; 927  :     return Fat32_read(FS_DEVICE(fs),FS_PARAM_BLK(fs),
; 928  :         (uint32_t)fnode->fn_fln,(uint32_t)fnode->fn_size,
; 929  :         (uint32_t)offset,buffer,size);

  00ec6	8b 45 18	 mov	 eax, DWORD PTR _size$[ebp]
  00ec9	50		 push	 eax
  00eca	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00ecd	51		 push	 ecx
  00ece	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00ed1	52		 push	 edx
  00ed2	8b 45 08	 mov	 eax, DWORD PTR _fnode$[ebp]
  00ed5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00ed8	51		 push	 ecx
  00ed9	8b 55 08	 mov	 edx, DWORD PTR _fnode$[ebp]
  00edc	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00edf	50		 push	 eax
  00ee0	8b 4d fc	 mov	 ecx, DWORD PTR _fs$[ebp]
  00ee3	83 c1 64	 add	 ecx, 100		; 00000064H
  00ee6	51		 push	 ecx
  00ee7	8b 55 fc	 mov	 edx, DWORD PTR _fs$[ebp]
  00eea	8b 02		 mov	 eax, DWORD PTR [edx]
  00eec	50		 push	 eax
  00eed	e8 00 00 00 00	 call	 _Fat32_read
  00ef2	83 c4 1c	 add	 esp, 28			; 0000001cH

; 930  : }

  00ef5	8b e5		 mov	 esp, ebp
  00ef7	5d		 pop	 ebp
  00ef8	c3		 ret	 0
_Fat32_fnode_read ENDP
_TEXT	ENDS
EXTRN	__memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv144 = -56						; size = 4
tv142 = -52						; size = 4
_ss$ = -48						; size = 4
_sdi$ = -44						; size = 4
_dircnt$ = -40						; size = 4
_nc$ = -36						; size = 4
_csa$ = -32						; size = 8
__t_bb_$ = -24						; size = 4
_des$ = -20						; size = 4
_fo$ = -16						; size = 4
_left$ = -12						; size = 4
_sectbuf$ = -8						; size = 4
_i$ = -4						; size = 4
_hd$ = 8						; size = 4
_fat$ = 12						; size = 4
_dirclus$ = 16						; size = 4
_filesize$ = 20						; size = 4
_offset$ = 24						; size = 4
_buffer$ = 28						; size = 4
_size$ = 32						; size = 4
_Fat32_read PROC

; 664  : {

  00f00	55		 push	 ebp
  00f01	8b ec		 mov	 ebp, esp
  00f03	83 ec 38	 sub	 esp, 56			; 00000038H

; 665  :     uint64_t        csa         = 0;    /*  cluster sector address  */

  00f06	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _csa$[ebp], 0
  00f0d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _csa$[ebp+4], 0

; 666  :     uint32_t        ss          = 0,    /*  sector start            */

  00f14	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ss$[ebp], 0

; 667  :                     sdi         = 0;    /*  start directory idx     */

  00f1b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _sdi$[ebp], 0

; 668  :     uint_t          i           = 0,

  00f22	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 669  :                     fo          = 0;    /*  file offset             */

  00f29	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fo$[ebp], 0

; 670  :     int             dircnt      = 0,

  00f30	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dircnt$[ebp], 0

; 671  :                     nc          = 0,    /*  number of copy          */

  00f37	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _nc$[ebp], 0

; 672  :                     left        = size; /*  剩余字节数              */

  00f3e	8b 45 20	 mov	 eax, DWORD PTR _size$[ebp]
  00f41	89 45 f4	 mov	 DWORD PTR _left$[ebp], eax

; 673  :     byte_t        * des         = buffer;

  00f44	8b 4d 1c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00f47	89 4d ec	 mov	 DWORD PTR _des$[ebp], ecx

; 674  :     byte_t        * sectbuf     = NULL;

  00f4a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sectbuf$[ebp], 0

; 675  :     BBUF_DECLARE();

  00f51	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __t_bb_$[ebp], 0

; 676  : 
; 677  :     _printk("FAT32 read!\n");

  00f58	68 00 00 00 00	 push	 OFFSET $SG2449
  00f5d	e8 00 00 00 00	 call	 __printk
  00f62	83 c4 04	 add	 esp, 4

; 678  :     /*  首先需要定位 */
; 679  :     dirclus = Fat32_offset_to_clus(hd,fat,dirclus,offset);

  00f65	8b 55 18	 mov	 edx, DWORD PTR _offset$[ebp]
  00f68	52		 push	 edx
  00f69	8b 45 10	 mov	 eax, DWORD PTR _dirclus$[ebp]
  00f6c	50		 push	 eax
  00f6d	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00f70	51		 push	 ecx
  00f71	8b 55 08	 mov	 edx, DWORD PTR _hd$[ebp]
  00f74	52		 push	 edx
  00f75	e8 00 00 00 00	 call	 _Fat32_offset_to_clus
  00f7a	83 c4 10	 add	 esp, 16			; 00000010H
  00f7d	89 45 10	 mov	 DWORD PTR _dirclus$[ebp], eax

; 680  :     ss      = FAT32_OFFSET_TO_SECT(fat,offset);

  00f80	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00f83	8b 45 18	 mov	 eax, DWORD PTR _offset$[ebp]
  00f86	33 d2		 xor	 edx, edx
  00f88	f7 71 30	 div	 DWORD PTR [ecx+48]
  00f8b	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00f8e	8b c2		 mov	 eax, edx
  00f90	33 d2		 xor	 edx, edx
  00f92	f7 71 28	 div	 DWORD PTR [ecx+40]
  00f95	89 45 d0	 mov	 DWORD PTR _ss$[ebp], eax

; 681  :     fo      = offset % fat->fat_bytes_per_sect;

  00f98	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00f9b	8b 45 18	 mov	 eax, DWORD PTR _offset$[ebp]
  00f9e	33 d2		 xor	 edx, edx
  00fa0	f7 71 28	 div	 DWORD PTR [ecx+40]
  00fa3	89 55 f0	 mov	 DWORD PTR _fo$[ebp], edx
$fat32_dir_get_first_begin$2450:

; 682  :     /*  遍历目录文件 */
; 683  : fat32_dir_get_first_begin:
; 684  :     csa = FAT32_CLUS_TO_SECT(fat,dirclus);

  00fa6	8b 55 10	 mov	 edx, DWORD PTR _dirclus$[ebp]
  00fa9	83 ea 02	 sub	 edx, 2
  00fac	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  00faf	0f af 50 2c	 imul	 edx, DWORD PTR [eax+44]
  00fb3	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00fb6	03 51 20	 add	 edx, DWORD PTR [ecx+32]
  00fb9	33 c0		 xor	 eax, eax
  00fbb	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00fbe	03 11		 add	 edx, DWORD PTR [ecx]
  00fc0	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00fc3	13 c8		 adc	 ecx, eax
  00fc5	89 55 e0	 mov	 DWORD PTR _csa$[ebp], edx
  00fc8	89 4d e4	 mov	 DWORD PTR _csa$[ebp+4], ecx

; 685  :     /*  遍历扇区  */
; 686  :     for(i = ss ; 
; 687  :         i < fat->fat_sects_per_clus && left && offset < filesize; 
; 688  :         i++ )

  00fcb	8b 55 d0	 mov	 edx, DWORD PTR _ss$[ebp]
  00fce	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  00fd1	eb 09		 jmp	 SHORT $LN10@Fat32_read
$LN9@Fat32_read:
  00fd3	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00fd6	83 c0 01	 add	 eax, 1
  00fd9	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@Fat32_read:
  00fdc	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  00fdf	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00fe2	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  00fe5	0f 83 12 01 00
	00		 jae	 $LN8@Fat32_read
  00feb	83 7d f4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00fef	0f 84 08 01 00
	00		 je	 $LN8@Fat32_read
  00ff5	8b 45 18	 mov	 eax, DWORD PTR _offset$[ebp]
  00ff8	3b 45 14	 cmp	 eax, DWORD PTR _filesize$[ebp]
  00ffb	0f 83 fc 00 00
	00		 jae	 $LN8@Fat32_read
$LN7@Fat32_read:

; 689  :     {
; 690  :         BBUF_READ_SECTOR(sectbuf,hd,csa+i);

  01001	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  01004	33 d2		 xor	 edx, edx
  01006	03 4d e0	 add	 ecx, DWORD PTR _csa$[ebp]
  01009	8b 45 e4	 mov	 eax, DWORD PTR _csa$[ebp+4]
  0100c	13 c2		 adc	 eax, edx
  0100e	50		 push	 eax
  0100f	51		 push	 ecx
  01010	8b 4d 08	 mov	 ecx, DWORD PTR _hd$[ebp]
  01013	51		 push	 ecx
  01014	e8 00 00 00 00	 call	 _Bbuf_read
  01019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0101c	89 45 e8	 mov	 DWORD PTR __t_bb_$[ebp], eax
  0101f	83 7d e8 00	 cmp	 DWORD PTR __t_bb_$[ebp], 0
  01023	74 2c		 je	 SHORT $LN4@Fat32_read
  01025	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  01028	33 c0		 xor	 eax, eax
  0102a	03 55 e0	 add	 edx, DWORD PTR _csa$[ebp]
  0102d	8b 4d e4	 mov	 ecx, DWORD PTR _csa$[ebp+4]
  01030	13 c8		 adc	 ecx, eax
  01032	83 e2 07	 and	 edx, 7
  01035	83 e1 00	 and	 ecx, 0
  01038	6a 00		 push	 0
  0103a	68 00 02 00 00	 push	 512			; 00000200H
  0103f	51		 push	 ecx
  01040	52		 push	 edx
  01041	e8 00 00 00 00	 call	 __allmul
  01046	8b 55 e8	 mov	 edx, DWORD PTR __t_bb_$[ebp]
  01049	03 42 14	 add	 eax, DWORD PTR [edx+20]
  0104c	89 45 f8	 mov	 DWORD PTR _sectbuf$[ebp], eax
  0104f	eb 07		 jmp	 SHORT $LN6@Fat32_read
$LN4@Fat32_read:
  01051	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sectbuf$[ebp], 0
$LN6@Fat32_read:
  01058	33 c0		 xor	 eax, eax
  0105a	75 a5		 jne	 SHORT $LN7@Fat32_read

; 691  :         if( NULL == sectbuf)

  0105c	83 7d f8 00	 cmp	 DWORD PTR _sectbuf$[ebp], 0
  01060	75 05		 jne	 SHORT $LN2@Fat32_read

; 692  :             goto fat32_dir_get_first_end;

  01062	e9 c2 00 00 00	 jmp	 $fat32_dir_get_first_end$2464
$LN2@Fat32_read:

; 693  :         /*
; 694  :          *    决定扇区内数据复制量的几个条件：剩余缓冲区、扇区剩余字节、文件剩
; 695  :          *  余长度。需要取这三个条件的最小值。
; 696  :          */
; 697  :         nc = MIN(fat->fat_bytes_per_sect - fo,filesize - offset);

  01067	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  0106a	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0106d	2b 55 f0	 sub	 edx, DWORD PTR _fo$[ebp]
  01070	8b 45 14	 mov	 eax, DWORD PTR _filesize$[ebp]
  01073	2b 45 18	 sub	 eax, DWORD PTR _offset$[ebp]
  01076	3b d0		 cmp	 edx, eax
  01078	73 0e		 jae	 SHORT $LN13@Fat32_read
  0107a	8b 4d 0c	 mov	 ecx, DWORD PTR _fat$[ebp]
  0107d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  01080	2b 55 f0	 sub	 edx, DWORD PTR _fo$[ebp]
  01083	89 55 cc	 mov	 DWORD PTR tv142[ebp], edx
  01086	eb 09		 jmp	 SHORT $LN14@Fat32_read
$LN13@Fat32_read:
  01088	8b 45 14	 mov	 eax, DWORD PTR _filesize$[ebp]
  0108b	2b 45 18	 sub	 eax, DWORD PTR _offset$[ebp]
  0108e	89 45 cc	 mov	 DWORD PTR tv142[ebp], eax
$LN14@Fat32_read:
  01091	8b 4d cc	 mov	 ecx, DWORD PTR tv142[ebp]
  01094	89 4d dc	 mov	 DWORD PTR _nc$[ebp], ecx

; 698  :         nc = MIN(nc,left);

  01097	8b 55 dc	 mov	 edx, DWORD PTR _nc$[ebp]
  0109a	3b 55 f4	 cmp	 edx, DWORD PTR _left$[ebp]
  0109d	7d 08		 jge	 SHORT $LN15@Fat32_read
  0109f	8b 45 dc	 mov	 eax, DWORD PTR _nc$[ebp]
  010a2	89 45 c8	 mov	 DWORD PTR tv144[ebp], eax
  010a5	eb 06		 jmp	 SHORT $LN16@Fat32_read
$LN15@Fat32_read:
  010a7	8b 4d f4	 mov	 ecx, DWORD PTR _left$[ebp]
  010aa	89 4d c8	 mov	 DWORD PTR tv144[ebp], ecx
$LN16@Fat32_read:
  010ad	8b 55 c8	 mov	 edx, DWORD PTR tv144[ebp]
  010b0	89 55 dc	 mov	 DWORD PTR _nc$[ebp], edx

; 699  :         _memcpy(des,sectbuf + fo,nc);

  010b3	8b 45 dc	 mov	 eax, DWORD PTR _nc$[ebp]
  010b6	50		 push	 eax
  010b7	8b 4d f8	 mov	 ecx, DWORD PTR _sectbuf$[ebp]
  010ba	03 4d f0	 add	 ecx, DWORD PTR _fo$[ebp]
  010bd	51		 push	 ecx
  010be	8b 55 ec	 mov	 edx, DWORD PTR _des$[ebp]
  010c1	52		 push	 edx
  010c2	e8 00 00 00 00	 call	 __memcpy
  010c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 700  :         BBUF_RELEASE();

  010ca	8b 45 e8	 mov	 eax, DWORD PTR __t_bb_$[ebp]
  010cd	50		 push	 eax
  010ce	e8 00 00 00 00	 call	 _Bbuf_release
  010d3	83 c4 04	 add	 esp, 4

; 701  :         fo       = 0;

  010d6	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _fo$[ebp], 0

; 702  :         left    -= nc;

  010dd	8b 4d f4	 mov	 ecx, DWORD PTR _left$[ebp]
  010e0	2b 4d dc	 sub	 ecx, DWORD PTR _nc$[ebp]
  010e3	89 4d f4	 mov	 DWORD PTR _left$[ebp], ecx

; 703  :         sectbuf += nc;

  010e6	8b 55 f8	 mov	 edx, DWORD PTR _sectbuf$[ebp]
  010e9	03 55 dc	 add	 edx, DWORD PTR _nc$[ebp]
  010ec	89 55 f8	 mov	 DWORD PTR _sectbuf$[ebp], edx

; 704  :         offset  += nc;

  010ef	8b 45 18	 mov	 eax, DWORD PTR _offset$[ebp]
  010f2	03 45 dc	 add	 eax, DWORD PTR _nc$[ebp]
  010f5	89 45 18	 mov	 DWORD PTR _offset$[ebp], eax

; 705  :     }

  010f8	e9 d6 fe ff ff	 jmp	 $LN9@Fat32_read
$LN8@Fat32_read:

; 706  :     ss = 0;

  010fd	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _ss$[ebp], 0

; 707  :     dirclus = Fat32_next_cluster(hd,fat,dirclus);

  01104	8b 4d 10	 mov	 ecx, DWORD PTR _dirclus$[ebp]
  01107	51		 push	 ecx
  01108	8b 55 0c	 mov	 edx, DWORD PTR _fat$[ebp]
  0110b	52		 push	 edx
  0110c	8b 45 08	 mov	 eax, DWORD PTR _hd$[ebp]
  0110f	50		 push	 eax
  01110	e8 00 00 00 00	 call	 _Fat32_next_cluster
  01115	83 c4 0c	 add	 esp, 12			; 0000000cH
  01118	89 45 10	 mov	 DWORD PTR _dirclus$[ebp], eax

; 708  :     if( dirclus < FAT32_END_OF_CLUS )

  0111b	81 7d 10 f8 ff
	ff 0f		 cmp	 DWORD PTR _dirclus$[ebp], 268435448 ; 0ffffff8H
  01122	73 05		 jae	 SHORT $fat32_dir_get_first_end$2464

; 709  :         goto fat32_dir_get_first_begin;

  01124	e9 7d fe ff ff	 jmp	 $fat32_dir_get_first_begin$2450
$fat32_dir_get_first_end$2464:

; 710  : 
; 711  : fat32_dir_get_first_end:
; 712  :     return size - left;

  01129	8b 45 20	 mov	 eax, DWORD PTR _size$[ebp]
  0112c	2b 45 f4	 sub	 eax, DWORD PTR _left$[ebp]

; 713  : }

  0112f	8b e5		 mov	 esp, ebp
  01131	5d		 pop	 ebp
  01132	c3		 ret	 0
_Fat32_read ENDP
; Function compile flags: /Odtp
_ptr$ = -4						; size = 4
_hd$ = 8						; size = 4
_fat$ = 12						; size = 4
_dirclus$ = 16						; size = 4
_offset$ = 20						; size = 4
_Fat32_offset_to_clus PROC

; 314  : {

  01140	55		 push	 ebp
  01141	8b ec		 mov	 ebp, esp
  01143	51		 push	 ecx

; 315  :     uint32_t        ptr = 0;

  01144	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0
$LN2@Fat32_offs:

; 316  : 
; 317  :     while( ptr + fat->fat_clus_size < offset )

  0114b	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  0114e	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  01151	03 48 30	 add	 ecx, DWORD PTR [eax+48]
  01154	3b 4d 14	 cmp	 ecx, DWORD PTR _offset$[ebp]
  01157	73 25		 jae	 SHORT $LN1@Fat32_offs

; 318  :     {
; 319  :         dirclus = Fat32_next_cluster(hd,fat,dirclus);

  01159	8b 55 10	 mov	 edx, DWORD PTR _dirclus$[ebp]
  0115c	52		 push	 edx
  0115d	8b 45 0c	 mov	 eax, DWORD PTR _fat$[ebp]
  01160	50		 push	 eax
  01161	8b 4d 08	 mov	 ecx, DWORD PTR _hd$[ebp]
  01164	51		 push	 ecx
  01165	e8 00 00 00 00	 call	 _Fat32_next_cluster
  0116a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0116d	89 45 10	 mov	 DWORD PTR _dirclus$[ebp], eax

; 320  :         ptr += fat->fat_clus_size;

  01170	8b 55 0c	 mov	 edx, DWORD PTR _fat$[ebp]
  01173	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  01176	03 42 30	 add	 eax, DWORD PTR [edx+48]
  01179	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 321  :     }

  0117c	eb cd		 jmp	 SHORT $LN2@Fat32_offs
$LN1@Fat32_offs:

; 322  : 
; 323  :     return dirclus;

  0117e	8b 45 10	 mov	 eax, DWORD PTR _dirclus$[ebp]

; 324  : }

  01181	8b e5		 mov	 esp, ebp
  01183	5d		 pop	 ebp
  01184	c3		 ret	 0
_Fat32_offset_to_clus ENDP
_TEXT	ENDS
END
