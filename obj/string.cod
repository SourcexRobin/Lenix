; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\libc\string.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__strlen
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\libc\string.c
;	COMDAT __strlen
_TEXT	SEGMENT
_string$ = 8						; size = 4
__strlen PROC						; COMDAT

; 8    :     register const char *   str = string;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _string$[esp-4]

; 9    : 
; 10   :     while( *str )   str++;

  00004	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00007	8b c1		 mov	 eax, ecx
  00009	74 0d		 je	 SHORT $LN1@strlen
  0000b	eb 03 8d 49 00	 npad	 5
$LL2@strlen:
  00010	83 c0 01	 add	 eax, 1
  00013	80 38 00	 cmp	 BYTE PTR [eax], 0
  00016	75 f8		 jne	 SHORT $LL2@strlen
$LN1@strlen:

; 11   : 
; 12   :     return str - string;

  00018	2b c1		 sub	 eax, ecx

; 13   : }

  0001a	c3		 ret	 0
__strlen ENDP
_TEXT	ENDS
PUBLIC	__strcat
; Function compile flags: /Ogtpy
;	COMDAT __strcat
_TEXT	SEGMENT
_des$ = 8						; size = 4
_src$ = 12						; size = 4
__strcat PROC						; COMDAT

; 17   :     register char       *   d = des;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _des$[esp-4]
  00004	56		 push	 esi

; 18   :     register const char *   s = src;

  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _src$[esp]

; 19   : 
; 20   :     if( d == s ) return d;

  00009	3b c6		 cmp	 eax, esi
  0000b	8b c8		 mov	 ecx, eax
  0000d	74 24		 je	 SHORT $LN6@strcat

; 21   : 
; 22   :     while( *d )  d++;

  0000f	80 38 00	 cmp	 BYTE PTR [eax], 0
  00012	74 08		 je	 SHORT $LN9@strcat
$LL4@strcat:
  00014	83 c1 01	 add	 ecx, 1
  00017	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0001a	75 f8		 jne	 SHORT $LL4@strcat
$LN9@strcat:

; 23   : 
; 24   :     while( *s ) *d++ = *s++;

  0001c	8a 16		 mov	 dl, BYTE PTR [esi]
  0001e	84 d2		 test	 dl, dl
  00020	74 0e		 je	 SHORT $LN1@strcat
$LL2@strcat:
  00022	83 c6 01	 add	 esi, 1
  00025	88 11		 mov	 BYTE PTR [ecx], dl
  00027	8a 16		 mov	 dl, BYTE PTR [esi]
  00029	83 c1 01	 add	 ecx, 1
  0002c	84 d2		 test	 dl, dl
  0002e	75 f2		 jne	 SHORT $LL2@strcat
$LN1@strcat:

; 25   : 
; 26   :     *d = 0;

  00030	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN6@strcat:
  00033	5e		 pop	 esi

; 27   : 
; 28   :     return des;
; 29   : }

  00034	c3		 ret	 0
__strcat ENDP
_TEXT	ENDS
PUBLIC	__nstrcat
; Function compile flags: /Ogtpy
;	COMDAT __nstrcat
_TEXT	SEGMENT
_des$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
__nstrcat PROC						; COMDAT

; 33   :     register char       *   d = des;
; 34   :     register const char *   s = src;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _src$[esp-4]
  00004	57		 push	 edi
  00005	8b 7c 24 08	 mov	 edi, DWORD PTR _des$[esp]

; 35   : 
; 36   :     if( d == s ) return d;

  00009	3b fa		 cmp	 edi, edx
  0000b	8b cf		 mov	 ecx, edi
  0000d	74 41		 je	 SHORT $LN13@nstrcat

; 37   : 
; 38   :     while( *d && size )

  0000f	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00012	56		 push	 esi
  00013	8b 74 24 14	 mov	 esi, DWORD PTR _size$[esp+4]
  00017	74 16		 je	 SHORT $LN9@nstrcat
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL4@nstrcat:
  00020	85 f6		 test	 esi, esi
  00022	74 0b		 je	 SHORT $LN9@nstrcat

; 39   :     {
; 40   :         d++;

  00024	83 c1 01	 add	 ecx, 1

; 41   :         size--;

  00027	83 ee 01	 sub	 esi, 1
  0002a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0002d	75 f1		 jne	 SHORT $LL4@nstrcat
$LN9@nstrcat:

; 42   :     }
; 43   : 
; 44   :     while( *s && size-- ) *d++ = *s++;

  0002f	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00032	74 18		 je	 SHORT $LN1@nstrcat
$LL2@nstrcat:
  00034	8b c6		 mov	 eax, esi
  00036	83 ee 01	 sub	 esi, 1
  00039	85 c0		 test	 eax, eax
  0003b	74 0f		 je	 SHORT $LN1@nstrcat
  0003d	8a 02		 mov	 al, BYTE PTR [edx]
  0003f	88 01		 mov	 BYTE PTR [ecx], al
  00041	83 c2 01	 add	 edx, 1
  00044	83 c1 01	 add	 ecx, 1
  00047	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0004a	75 e8		 jne	 SHORT $LL2@nstrcat
$LN1@nstrcat:

; 45   : 
; 46   :     *d = 0;

  0004c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0004f	5e		 pop	 esi
$LN13@nstrcat:

; 47   : 
; 48   :     return des;

  00050	8b c7		 mov	 eax, edi
  00052	5f		 pop	 edi

; 49   : }

  00053	c3		 ret	 0
__nstrcat ENDP
_TEXT	ENDS
PUBLIC	__strcpy
; Function compile flags: /Ogtpy
;	COMDAT __strcpy
_TEXT	SEGMENT
_des$ = 8						; size = 4
_src$ = 12						; size = 4
__strcpy PROC						; COMDAT

; 54   :     register char       *   d = des;
; 55   :     register const char *   s = src;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _src$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 7c 24 0c	 mov	 edi, DWORD PTR _des$[esp+4]

; 56   : 
; 57   :     if( d == s ) return d;

  0000a	3b fa		 cmp	 edi, edx
  0000c	8b f7		 mov	 esi, edi
  0000e	8b ca		 mov	 ecx, edx
  00010	74 4e		 je	 SHORT $LN1@strcpy

; 58   : 
; 59   :     if( (uint_t)d < (uint_t)s )

  00012	73 21		 jae	 SHORT $LN13@strcpy

; 60   :     {
; 61   :         while( *s ) *d++ = *s++;

  00014	8a 0a		 mov	 cl, BYTE PTR [edx]
  00016	84 c9		 test	 cl, cl
  00018	74 13		 je	 SHORT $LN6@strcpy
  0001a	2b d7		 sub	 edx, edi
  0001c	8d 64 24 00	 npad	 4
$LL7@strcpy:
  00020	88 0e		 mov	 BYTE PTR [esi], cl
  00022	8a 4c 32 01	 mov	 cl, BYTE PTR [edx+esi+1]
  00026	83 c6 01	 add	 esi, 1
  00029	84 c9		 test	 cl, cl
  0002b	75 f3		 jne	 SHORT $LL7@strcpy
$LN6@strcpy:

; 69   :     }
; 70   : 
; 71   :     return des;

  0002d	8b c7		 mov	 eax, edi
  0002f	5f		 pop	 edi
  00030	c6 06 00	 mov	 BYTE PTR [esi], 0
  00033	5e		 pop	 esi

; 72   : 
; 73   : }

  00034	c3		 ret	 0
$LN13@strcpy:

; 62   :         *d = 0;
; 63   :     }
; 64   :     else
; 65   :     {
; 66   :         while( *s ) s++;

  00035	80 3a 00	 cmp	 BYTE PTR [edx], 0
  00038	74 0e		 je	 SHORT $LN3@strcpy
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL4@strcpy:
  00040	83 c1 01	 add	 ecx, 1
  00043	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00046	75 f8		 jne	 SHORT $LL4@strcpy
$LN3@strcpy:

; 67   :         d += s - src;

  00048	8b f1		 mov	 esi, ecx
  0004a	2b f2		 sub	 esi, edx
  0004c	03 f7		 add	 esi, edi

; 68   :         while( s >= src ) *d-- = *s--;

  0004e	3b ca		 cmp	 ecx, edx
  00050	72 0e		 jb	 SHORT $LN1@strcpy
$LL2@strcpy:
  00052	8a 01		 mov	 al, BYTE PTR [ecx]
  00054	88 06		 mov	 BYTE PTR [esi], al
  00056	83 e9 01	 sub	 ecx, 1
  00059	83 ee 01	 sub	 esi, 1
  0005c	3b ca		 cmp	 ecx, edx
  0005e	73 f2		 jae	 SHORT $LL2@strcpy
$LN1@strcpy:

; 69   :     }
; 70   : 
; 71   :     return des;

  00060	8b c7		 mov	 eax, edi
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 72   : 
; 73   : }

  00064	c3		 ret	 0
__strcpy ENDP
_TEXT	ENDS
PUBLIC	__nstrcpy
; Function compile flags: /Ogtpy
;	COMDAT __nstrcpy
_TEXT	SEGMENT
_des$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
__nstrcpy PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp

; 77   :     register char       *   d   = des;

  00001	8b 6c 24 08	 mov	 ebp, DWORD PTR _des$[esp]
  00005	56		 push	 esi

; 78   :     register const char *   s   = src;

  00006	8b 74 24 10	 mov	 esi, DWORD PTR _src$[esp+4]
  0000a	57		 push	 edi

; 79   : 
; 80   :     if( 0 == size && d == s ) return d;

  0000b	8b 7c 24 18	 mov	 edi, DWORD PTR _size$[esp+8]
  0000f	85 ff		 test	 edi, edi
  00011	8b d5		 mov	 edx, ebp
  00013	8b ce		 mov	 ecx, esi
  00015	75 0a		 jne	 SHORT $LN9@nstrcpy
  00017	3b ee		 cmp	 ebp, esi
  00019	75 08		 jne	 SHORT $LN18@nstrcpy
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 93   :     }
; 94   : 
; 95   :     return des;

  0001d	8b c5		 mov	 eax, ebp
  0001f	5d		 pop	 ebp

; 96   : }

  00020	c3		 ret	 0
$LN9@nstrcpy:

; 81   : 
; 82   :     if( (uint_t)d < (uint_t)s )

  00021	3b ee		 cmp	 ebp, esi
$LN18@nstrcpy:
  00023	73 28		 jae	 SHORT $LN13@nstrcpy

; 83   :     {
; 84   :         while( *s && --size ) *d++ = *s++;;

  00025	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00028	74 1a		 je	 SHORT $LN6@nstrcpy
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL7@nstrcpy:
  00030	83 ef 01	 sub	 edi, 1
  00033	74 0f		 je	 SHORT $LN6@nstrcpy
  00035	8a 01		 mov	 al, BYTE PTR [ecx]
  00037	88 02		 mov	 BYTE PTR [edx], al
  00039	83 c1 01	 add	 ecx, 1
  0003c	83 c2 01	 add	 edx, 1
  0003f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00042	75 ec		 jne	 SHORT $LL7@nstrcpy
$LN6@nstrcpy:
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi

; 93   :     }
; 94   : 
; 95   :     return des;

  00046	8b c5		 mov	 eax, ebp
  00048	c6 02 00	 mov	 BYTE PTR [edx], 0
  0004b	5d		 pop	 ebp

; 96   : }

  0004c	c3		 ret	 0
$LN13@nstrcpy:

; 85   :         *d = 0;
; 86   :     }
; 87   :     else
; 88   :     {
; 89   :         while( *s && --size ) s++;

  0004d	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00050	74 0d		 je	 SHORT $LN3@nstrcpy
$LL4@nstrcpy:
  00052	83 ef 01	 sub	 edi, 1
  00055	74 08		 je	 SHORT $LN3@nstrcpy
  00057	83 c1 01	 add	 ecx, 1
  0005a	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0005d	75 f3		 jne	 SHORT $LL4@nstrcpy
$LN3@nstrcpy:

; 90   :         d += s - src;

  0005f	8b d1		 mov	 edx, ecx
  00061	2b d6		 sub	 edx, esi
  00063	03 d5		 add	 edx, ebp

; 91   :         *d = 0;
; 92   :         while( s >= src ) *d-- = *s--;

  00065	3b ce		 cmp	 ecx, esi
  00067	c6 02 00	 mov	 BYTE PTR [edx], 0
  0006a	72 12		 jb	 SHORT $LN1@nstrcpy
  0006c	8d 64 24 00	 npad	 4
$LL2@nstrcpy:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	88 02		 mov	 BYTE PTR [edx], al
  00074	83 e9 01	 sub	 ecx, 1
  00077	83 ea 01	 sub	 edx, 1
  0007a	3b ce		 cmp	 ecx, esi
  0007c	73 f2		 jae	 SHORT $LL2@nstrcpy
$LN1@nstrcpy:
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 93   :     }
; 94   : 
; 95   :     return des;

  00080	8b c5		 mov	 eax, ebp
  00082	5d		 pop	 ebp

; 96   : }

  00083	c3		 ret	 0
__nstrcpy ENDP
_TEXT	ENDS
PUBLIC	__strcmp
; Function compile flags: /Ogtpy
;	COMDAT __strcmp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
__strcmp PROC						; COMDAT

; 100  :     register const char *   s1 = str1;
; 101  :     register const char *   s2 = str2;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _str2$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _str1$[esp]

; 102  : 
; 103  :     if( s1 == s2 ) return 0;

  00009	3b f2		 cmp	 esi, edx
  0000b	8b ce		 mov	 ecx, esi
  0000d	75 04		 jne	 SHORT $LN6@strcmp
  0000f	33 c0		 xor	 eax, eax
  00011	5e		 pop	 esi

; 112  : }

  00012	c3		 ret	 0
$LN6@strcmp:

; 104  : 
; 105  :     while( *s1 && *s1 == *s2 )

  00013	8a 06		 mov	 al, BYTE PTR [esi]
  00015	84 c0		 test	 al, al
  00017	74 18		 je	 SHORT $LN1@strcmp
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL2@strcmp:
  00020	3a 02		 cmp	 al, BYTE PTR [edx]
  00022	75 0d		 jne	 SHORT $LN1@strcmp
  00024	8a 41 01	 mov	 al, BYTE PTR [ecx+1]

; 106  :     {
; 107  :         s1++;

  00027	83 c1 01	 add	 ecx, 1

; 108  :         s2++;

  0002a	83 c2 01	 add	 edx, 1
  0002d	84 c0		 test	 al, al
  0002f	75 ef		 jne	 SHORT $LL2@strcmp
$LN1@strcmp:

; 109  :     }
; 110  : 
; 111  :     return *s1 - *s2;

  00031	0f be 12	 movsx	 edx, BYTE PTR [edx]
  00034	0f be 01	 movsx	 eax, BYTE PTR [ecx]
  00037	2b c2		 sub	 eax, edx
  00039	5e		 pop	 esi

; 112  : }

  0003a	c3		 ret	 0
__strcmp ENDP
_TEXT	ENDS
PUBLIC	__namecmp
; Function compile flags: /Ogtpy
;	COMDAT __namecmp
_TEXT	SEGMENT
_name1$ = 8						; size = 4
_name2$ = 12						; size = 4
__namecmp PROC						; COMDAT

; 117  : {

  00000	56		 push	 esi

; 118  :     register char           n1,
; 119  :                             n2;
; 120  :     while( *name1 )

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _name2$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 0c	 mov	 edi, DWORD PTR _name1$[esp+4]
  0000a	8a 07		 mov	 al, BYTE PTR [edi]
  0000c	84 c0		 test	 al, al
  0000e	74 2b		 je	 SHORT $LN4@namecmp
$LL5@namecmp:

; 121  :     {
; 122  :         n1 = *name1++;
; 123  :         n2 = *name2++;

  00010	8a 0e		 mov	 cl, BYTE PTR [esi]

; 124  : 
; 125  :         if( n1 >= 'a' && n1 <= 'z' ) n1 &= ~0x20;       /*  如果是小写字母，则转换为大写    */

  00012	8a d0		 mov	 dl, al
  00014	80 ea 61	 sub	 dl, 97			; 00000061H
  00017	83 c7 01	 add	 edi, 1
  0001a	83 c6 01	 add	 esi, 1
  0001d	80 fa 19	 cmp	 dl, 25			; 00000019H
  00020	77 02		 ja	 SHORT $LN3@namecmp
  00022	24 df		 and	 al, -33			; ffffffdfH
$LN3@namecmp:

; 126  :         if( n2 >= 'a' && n2 <= 'z' ) n2 &= ~0x20;       

  00024	8a d1		 mov	 dl, cl
  00026	80 ea 61	 sub	 dl, 97			; 00000061H
  00029	80 fa 19	 cmp	 dl, 25			; 00000019H
  0002c	77 03		 ja	 SHORT $LN2@namecmp
  0002e	80 e1 df	 and	 cl, -33			; ffffffdfH
$LN2@namecmp:

; 127  : 
; 128  :         if( n1 != n2 )

  00031	3a c1		 cmp	 al, cl
  00033	75 11		 jne	 SHORT $LN9@namecmp
  00035	8a 07		 mov	 al, BYTE PTR [edi]
  00037	84 c0		 test	 al, al
  00039	75 d5		 jne	 SHORT $LL5@namecmp
$LN4@namecmp:

; 130  :     }
; 131  : 
; 132  :     return *name1 - *name2;

  0003b	0f be 07	 movsx	 eax, BYTE PTR [edi]
  0003e	0f be 16	 movsx	 edx, BYTE PTR [esi]
  00041	5f		 pop	 edi
  00042	2b c2		 sub	 eax, edx
  00044	5e		 pop	 esi

; 133  : }

  00045	c3		 ret	 0
$LN9@namecmp:

; 129  :             return n1 - n2;

  00046	0f be c9	 movsx	 ecx, cl
  00049	0f be c0	 movsx	 eax, al
  0004c	5f		 pop	 edi
  0004d	2b c1		 sub	 eax, ecx
  0004f	5e		 pop	 esi

; 133  : }

  00050	c3		 ret	 0
__namecmp ENDP
_TEXT	ENDS
PUBLIC	__atoh
EXTRN	__is_hex:PROC
; Function compile flags: /Ogtpy
;	COMDAT __atoh
_TEXT	SEGMENT
_num$ = 8						; size = 4
__atoh	PROC						; COMDAT

; 137  : {

  00000	56		 push	 esi

; 138  :     int                     n       = 0;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _num$[esp]
  00005	57		 push	 edi
  00006	33 ff		 xor	 edi, edi
$LL9@atoh:

; 139  :     int                     base    = 0;
; 140  : 
; 141  :     while(CHAR_IS_SPACE(*num))

  00008	8a 06		 mov	 al, BYTE PTR [esi]
  0000a	3c 20		 cmp	 al, 32			; 00000020H
  0000c	74 04		 je	 SHORT $LN7@atoh
  0000e	3c 09		 cmp	 al, 9
  00010	75 05		 jne	 SHORT $LN14@atoh
$LN7@atoh:

; 142  :         num++;

  00012	83 c6 01	 add	 esi, 1
  00015	eb f1		 jmp	 SHORT $LL9@atoh
$LN14@atoh:

; 143  : 
; 144  :     while( _is_hex(*num) )

  00017	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __is_hex
  00020	83 c4 04	 add	 esp, 4
  00023	85 c0		 test	 eax, eax
  00025	74 41		 je	 SHORT $LN16@atoh
$LL6@atoh:

; 145  :     {
; 146  :         char c = *num++;

  00027	8a 06		 mov	 al, BYTE PTR [esi]

; 147  :         if( c >= '0' && c <= '9' )

  00029	8a c8		 mov	 cl, al
  0002b	80 e9 30	 sub	 cl, 48			; 00000030H
  0002e	83 c6 01	 add	 esi, 1
  00031	80 f9 09	 cmp	 cl, 9
  00034	77 08		 ja	 SHORT $LN4@atoh

; 148  :             base = c - '0';

  00036	0f be c0	 movsx	 eax, al
  00039	83 e8 30	 sub	 eax, 48			; 00000030H
  0003c	eb 15		 jmp	 SHORT $LN1@atoh
$LN4@atoh:

; 149  :         else if ( c >= 'a' && c <= 'f' )

  0003e	8a d0		 mov	 dl, al
  00040	80 ea 61	 sub	 dl, 97			; 00000061H
  00043	80 fa 05	 cmp	 dl, 5

; 150  :             base = (c - 'a') + 10;

  00046	0f be c0	 movsx	 eax, al
  00049	77 05		 ja	 SHORT $LN2@atoh
  0004b	83 e8 57	 sub	 eax, 87			; 00000057H

; 151  :         else

  0004e	eb 03		 jmp	 SHORT $LN1@atoh
$LN2@atoh:

; 152  :             base = (c - 'A') + 10;

  00050	83 e8 37	 sub	 eax, 55			; 00000037H
$LN1@atoh:

; 153  : 
; 154  :         n = n*16 + base;

  00053	c1 e7 04	 shl	 edi, 4
  00056	03 f8		 add	 edi, eax
  00058	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 __is_hex
  00061	83 c4 04	 add	 esp, 4
  00064	85 c0		 test	 eax, eax
  00066	75 bf		 jne	 SHORT $LL6@atoh
$LN16@atoh:

; 155  :     }
; 156  : 
; 157  :     return n;

  00068	8b c7		 mov	 eax, edi
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 158  : }

  0006c	c3		 ret	 0
__atoh	ENDP
_TEXT	ENDS
PUBLIC	__atoi
; Function compile flags: /Ogtpy
;	COMDAT __atoi
_TEXT	SEGMENT
_num$ = 8						; size = 4
__atoi	PROC						; COMDAT

; 163  :     int                     n       = 0;
; 164  :     int                     sign    = 0;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _num$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	33 f6		 xor	 esi, esi
  00008	33 ff		 xor	 edi, edi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL7@atoi:

; 165  : 
; 166  :     while(CHAR_IS_SPACE(*num))

  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	80 f9 20	 cmp	 cl, 32			; 00000020H
  00015	74 05		 je	 SHORT $LN5@atoi
  00017	80 f9 09	 cmp	 cl, 9
  0001a	75 05		 jne	 SHORT $LN6@atoi
$LN5@atoi:

; 167  :         num++;

  0001c	83 c2 01	 add	 edx, 1
  0001f	eb ef		 jmp	 SHORT $LL7@atoi
$LN6@atoi:

; 168  : 
; 169  :     if( '-' == *num )

  00021	80 3a 2d	 cmp	 BYTE PTR [edx], 45	; 0000002dH
  00024	75 07		 jne	 SHORT $LN14@atoi

; 170  :     {
; 171  :         sign = 1;

  00026	bf 01 00 00 00	 mov	 edi, 1

; 172  :         num++;

  0002b	03 d7		 add	 edx, edi
$LN14@atoi:

; 173  :     }
; 174  : 
; 175  :     while( *num >= '0' && *num <= '9' )

  0002d	8a 0a		 mov	 cl, BYTE PTR [edx]
  0002f	80 f9 30	 cmp	 cl, 48			; 00000030H
  00032	7c 21		 jl	 SHORT $LN2@atoi
$LL3@atoi:
  00034	80 f9 39	 cmp	 cl, 57			; 00000039H
  00037	7f 1c		 jg	 SHORT $LN2@atoi

; 176  :     {
; 177  :         char c = *num++;
; 178  :         if( c >= '0' && c <= '9' )

  00039	8a c1		 mov	 al, cl
  0003b	2c 30		 sub	 al, 48			; 00000030H
  0003d	83 c2 01	 add	 edx, 1
  00040	3c 09		 cmp	 al, 9
  00042	77 0a		 ja	 SHORT $LN1@atoi

; 179  :             n = n * 10 + c - '0';

  00044	0f be c9	 movsx	 ecx, cl
  00047	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0004a	8d 74 41 d0	 lea	 esi, DWORD PTR [ecx+eax*2-48]
$LN1@atoi:
  0004e	8a 0a		 mov	 cl, BYTE PTR [edx]
  00050	80 f9 30	 cmp	 cl, 48			; 00000030H
  00053	7d df		 jge	 SHORT $LL3@atoi
$LN2@atoi:

; 180  :     }
; 181  : 
; 182  : 
; 183  :     return sign ? -n : n;

  00055	85 ff		 test	 edi, edi
  00057	74 02		 je	 SHORT $LN10@atoi
  00059	f7 de		 neg	 esi
$LN10@atoi:
  0005b	5f		 pop	 edi
  0005c	8b c6		 mov	 eax, esi
  0005e	5e		 pop	 esi

; 184  : }

  0005f	c3		 ret	 0
__atoi	ENDP
_TEXT	ENDS
END
