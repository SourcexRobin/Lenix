; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\arch\x86.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@OMPDNAKH@fault?5F?3?5fpu?5?4?$AA@	; `string'
PUBLIC	??_C@_0BA@NIJOEOJJ@fault?5E?3?5page?5?4?$AA@	; `string'
PUBLIC	??_C@_0BD@IJHDHEP@fault?5D?3?5general?5?4?$AA@	; `string'
PUBLIC	??_C@_0BB@MOECCGMA@fault?5C?3?5stack?5?4?$AA@	; `string'
PUBLIC	??_C@_0BD@KDLJEGMO@fault?5B?3?5segment?5?4?$AA@	; `string'
PUBLIC	??_C@_0P@KEEHDLPC@fault?5A?3?5tss?5?4?$AA@	; `string'
PUBLIC	??_C@_0BC@OIJDDCII@fault?59?3?5fpu?5ob?5?4?$AA@	; `string'
PUBLIC	??_C@_0BC@GALMJMOI@fault?58?3?5double?5?4?$AA@	; `string'
PUBLIC	??_C@_0BC@FKJHGCNO@fault?57?3?5device?5?4?$AA@	; `string'
PUBLIC	??_C@_0BL@KFAKHLDN@fault?56?3?5invalide?5opcode?5?4?$AA@ ; `string'
PUBLIC	??_C@_0BB@DFKJNDJL@fault?55?3?5bound?5?4?$AA@	; `string'
PUBLIC	??_C@_0BE@LBJJMHNM@fault?54?3?5overflow?5?4?$AA@ ; `string'
PUBLIC	??_C@_0BI@ONAOFHF@fault?53?3?5single?5setup?5?4?$AA@ ; `string'
PUBLIC	??_C@_0BA@GJHFAJPN@fault?52?3?5null?5?4?$AA@	; `string'
PUBLIC	??_C@_0BB@PMDJMNIO@fault?51?3?5debug?5?4?$AA@	; `string'
PUBLIC	??_C@_0BD@BEGHNHPG@fault?50?3?5div?5zero?4?$AA@	; `string'
PUBLIC	_i386_fault_name
;	COMDAT ??_C@_0P@OMPDNAKH@fault?5F?3?5fpu?5?4?$AA@
CONST	SEGMENT
??_C@_0P@OMPDNAKH@fault?5F?3?5fpu?5?4?$AA@ DB 'fault F: fpu .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NIJOEOJJ@fault?5E?3?5page?5?4?$AA@
CONST	SEGMENT
??_C@_0BA@NIJOEOJJ@fault?5E?3?5page?5?4?$AA@ DB 'fault E: page .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IJHDHEP@fault?5D?3?5general?5?4?$AA@
CONST	SEGMENT
??_C@_0BD@IJHDHEP@fault?5D?3?5general?5?4?$AA@ DB 'fault D: general .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOECCGMA@fault?5C?3?5stack?5?4?$AA@
CONST	SEGMENT
??_C@_0BB@MOECCGMA@fault?5C?3?5stack?5?4?$AA@ DB 'fault C: stack .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDLJEGMO@fault?5B?3?5segment?5?4?$AA@
CONST	SEGMENT
??_C@_0BD@KDLJEGMO@fault?5B?3?5segment?5?4?$AA@ DB 'fault B: segment .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEEHDLPC@fault?5A?3?5tss?5?4?$AA@
CONST	SEGMENT
??_C@_0P@KEEHDLPC@fault?5A?3?5tss?5?4?$AA@ DB 'fault A: tss .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OIJDDCII@fault?59?3?5fpu?5ob?5?4?$AA@
CONST	SEGMENT
??_C@_0BC@OIJDDCII@fault?59?3?5fpu?5ob?5?4?$AA@ DB 'fault 9: fpu ob .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GALMJMOI@fault?58?3?5double?5?4?$AA@
CONST	SEGMENT
??_C@_0BC@GALMJMOI@fault?58?3?5double?5?4?$AA@ DB 'fault 8: double .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKJHGCNO@fault?57?3?5device?5?4?$AA@
CONST	SEGMENT
??_C@_0BC@FKJHGCNO@fault?57?3?5device?5?4?$AA@ DB 'fault 7: device .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KFAKHLDN@fault?56?3?5invalide?5opcode?5?4?$AA@
CONST	SEGMENT
??_C@_0BL@KFAKHLDN@fault?56?3?5invalide?5opcode?5?4?$AA@ DB 'fault 6: inv'
	DB	'alide opcode .', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DFKJNDJL@fault?55?3?5bound?5?4?$AA@
CONST	SEGMENT
??_C@_0BB@DFKJNDJL@fault?55?3?5bound?5?4?$AA@ DB 'fault 5: bound .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LBJJMHNM@fault?54?3?5overflow?5?4?$AA@
CONST	SEGMENT
??_C@_0BE@LBJJMHNM@fault?54?3?5overflow?5?4?$AA@ DB 'fault 4: overflow .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ONAOFHF@fault?53?3?5single?5setup?5?4?$AA@
CONST	SEGMENT
??_C@_0BI@ONAOFHF@fault?53?3?5single?5setup?5?4?$AA@ DB 'fault 3: single '
	DB	'setup .', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GJHFAJPN@fault?52?3?5null?5?4?$AA@
CONST	SEGMENT
??_C@_0BA@GJHFAJPN@fault?52?3?5null?5?4?$AA@ DB 'fault 2: null .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PMDJMNIO@fault?51?3?5debug?5?4?$AA@
CONST	SEGMENT
??_C@_0BB@PMDJMNIO@fault?51?3?5debug?5?4?$AA@ DB 'fault 1: debug .', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BEGHNHPG@fault?50?3?5div?5zero?4?$AA@
CONST	SEGMENT
??_C@_0BD@BEGHNHPG@fault?50?3?5div?5zero?4?$AA@ DB 'fault 0: div zero.', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_gdt	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DW	0ffffH
	DW	00H
	DB	00H
	DB	09aH
	DB	0cfH
	DB	00H
	DW	0ffffH
	DW	00H
	DB	00H
	DB	092H
	DB	0cfH
	DB	00H
	DW	0ffffH
	DW	00H
	DB	00H
	DB	0faH
	DB	0ccH
	DB	00H
	DW	0ffffH
	DW	00H
	DB	00H
	DB	0f2H
	DB	0ccH
	DB	00H
	ORG $+88
_tss	DD	00H
	DD	00H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	08H
	DD	010H
	DD	010H
	DD	010H
	DD	010H
	DD	00H
	DD	00H
	ORG $+256
_i386_fault_name DD FLAT:??_C@_0BD@BEGHNHPG@fault?50?3?5div?5zero?4?$AA@
	DD	FLAT:??_C@_0BB@PMDJMNIO@fault?51?3?5debug?5?4?$AA@
	DD	FLAT:??_C@_0BA@GJHFAJPN@fault?52?3?5null?5?4?$AA@
	DD	FLAT:??_C@_0BI@ONAOFHF@fault?53?3?5single?5setup?5?4?$AA@
	DD	FLAT:??_C@_0BE@LBJJMHNM@fault?54?3?5overflow?5?4?$AA@
	DD	FLAT:??_C@_0BB@DFKJNDJL@fault?55?3?5bound?5?4?$AA@
	DD	FLAT:??_C@_0BL@KFAKHLDN@fault?56?3?5invalide?5opcode?5?4?$AA@
	DD	FLAT:??_C@_0BC@FKJHGCNO@fault?57?3?5device?5?4?$AA@
	DD	FLAT:??_C@_0BC@GALMJMOI@fault?58?3?5double?5?4?$AA@
	DD	FLAT:??_C@_0BC@OIJDDCII@fault?59?3?5fpu?5ob?5?4?$AA@
	DD	FLAT:??_C@_0P@KEEHDLPC@fault?5A?3?5tss?5?4?$AA@
	DD	FLAT:??_C@_0BD@KDLJEGMO@fault?5B?3?5segment?5?4?$AA@
	DD	FLAT:??_C@_0BB@MOECCGMA@fault?5C?3?5stack?5?4?$AA@
	DD	FLAT:??_C@_0BD@IJHDHEP@fault?5D?3?5general?5?4?$AA@
	DD	FLAT:??_C@_0BA@NIJOEOJJ@fault?5E?3?5page?5?4?$AA@
	DD	FLAT:??_C@_0P@OMPDNAKH@fault?5F?3?5fpu?5?4?$AA@
_DATA	ENDS
PUBLIC	_Context_initial
EXTRN	_Seg_get_cs:PROC
EXTRN	_Proc_exit:PROC
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\arch\x86.c
;	COMDAT _Context_initial
_TEXT	SEGMENT
_entry$ = 8						; size = 4
_param$ = 12						; size = 4
_sp$ = 16						; size = 4
_Context_initial PROC					; COMDAT

; 83   :     *--sp   = 0;                                /*  进程退出代码             */
; 84   :     *--sp   = (uint_t)param;                    /*  进程入口参数             */

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _param$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 10	 mov	 esi, DWORD PTR _sp$[esp]
  00009	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00010	83 ee 04	 sub	 esi, 4
  00013	83 ee 04	 sub	 esi, 4
  00016	89 06		 mov	 DWORD PTR [esi], eax

; 85   :     *--sp   = (uint_t)Proc_exit;                /*  进程退出函数入口         */

  00018	83 ee 04	 sub	 esi, 4
  0001b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET _Proc_exit

; 86   :     *--sp   = USER_DEFAULT_EFLAGS;              /*  EFLAGS 新进程默认允许中断*/

  00021	83 ee 04	 sub	 esi, 4
  00024	c7 06 00 02 00
	00		 mov	 DWORD PTR [esi], 512	; 00000200H

; 87   :     *--sp   = Seg_get_cs();                     /*  CS  */

  0002a	83 ee 04	 sub	 esi, 4
  0002d	e8 00 00 00 00	 call	 _Seg_get_cs

; 88   :     *--sp   = (uint_t)entry;                    /*  EIP  进程入口            */

  00032	8b 4c 24 08	 mov	 ecx, DWORD PTR _entry$[esp]
  00036	89 06		 mov	 DWORD PTR [esi], eax
  00038	89 4e fc	 mov	 DWORD PTR [esi-4], ecx
  0003b	83 ee 04	 sub	 esi, 4

; 89   :                                                 /*  以下为寄存器环境         */
; 90   :     *--sp   = 0;                                /*  EAX                      */

  0003e	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00045	83 ee 04	 sub	 esi, 4

; 91   :     *--sp   = 0;                                /*  ECX                      */

  00048	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  0004f	83 ee 04	 sub	 esi, 4

; 92   :     *--sp   = 0;                                /*  EDX                      */

  00052	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00059	83 ee 04	 sub	 esi, 4

; 93   :     *--sp   = 0;                                /*  EBX                      */ 

  0005c	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0
  00063	83 ee 04	 sub	 esi, 4

; 94   :     *--sp   = 0;                                /*  ESP                      */

  00066	83 ee 04	 sub	 esi, 4
  00069	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 95   :     *--sp   = 0;                                /*  EBP                      */

  0006f	83 ee 04	 sub	 esi, 4
  00072	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 96   :     *--sp   = 0;                                /*  ESI                      */

  00078	83 ee 04	 sub	 esi, 4
  0007b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 97   :     *--sp   = 0;                                /*  EDI                      */

  00081	83 ee 04	 sub	 esi, 4
  00084	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 98   :                                                 /*  运行环境设置结束         */
; 99   :     return sp;

  0008a	8b c6		 mov	 eax, esi
  0008c	5e		 pop	 esi

; 100  : }

  0008d	c3		 ret	 0
_Context_initial ENDP
_TEXT	ENDS
PUBLIC	_I386_msd_set
; Function compile flags: /Ogtpy
;	COMDAT _I386_msd_set
_TEXT	SEGMENT
_msd$ = 8						; size = 4
_base$ = 12						; size = 4
_limit$ = 16						; size = 4
_dpl$ = 20						; size = 4
_attr$ = 24						; size = 4
_I386_msd_set PROC					; COMDAT

; 139  :     if( NULL == msd)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _msd$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 04		 jne	 SHORT $LN8@I386_msd_s

; 140  :         return RESULT_FAILED;

  00008	83 c8 ff	 or	 eax, -1

; 154  : }

  0000b	c3		 ret	 0
$LN8@I386_msd_s:

; 141  :     msd->msd_attr       = 0x90;             /*  描述符存在且为存储段    */
; 142  :     msd->msd_attr      |= (dpl & 3) << 5 ;  /*  设置描述符优先级        */
; 143  :     msd->msd_attr      |= (byte_t)(attr & 0x0F );

  0000c	8a 4c 24 14	 mov	 cl, BYTE PTR _attr$[esp-4]
  00010	53		 push	 ebx
  00011	8a 5c 24 14	 mov	 bl, BYTE PTR _dpl$[esp]
  00015	8a d1		 mov	 dl, cl
  00017	80 e2 0f	 and	 dl, 15			; 0000000fH
  0001a	c0 e3 05	 shl	 bl, 5
  0001d	0a d3		 or	 dl, bl

; 144  :     msd->msd_limit_h   |= (byte_t)(attr & 0xF0 );

  0001f	80 e1 f0	 and	 cl, 240			; 000000f0H
  00022	08 48 06	 or	 BYTE PTR [eax+6], cl

; 145  :     if( limit > 0xFFFFF )

  00025	8b 4c 24 10	 mov	 ecx, DWORD PTR _limit$[esp]
  00029	80 ca 90	 or	 dl, 144			; 00000090H
  0002c	81 f9 ff ff 0f
	00		 cmp	 ecx, 1048575		; 000fffffH
  00032	88 50 05	 mov	 BYTE PTR [eax+5], dl
  00035	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00038	5b		 pop	 ebx
  00039	76 09		 jbe	 SHORT $LN6@I386_msd_s

; 146  :     {
; 147  :         limit           /= 0x1000;

  0003b	c1 e9 0c	 shr	 ecx, 12			; 0000000cH

; 148  :         msd->msd_limit_h    |= MSD_ATTR_GRAIN_4K;

  0003e	80 ca 80	 or	 dl, 128			; 00000080H
  00041	88 50 06	 mov	 BYTE PTR [eax+6], dl
$LN6@I386_msd_s:
  00044	56		 push	 esi

; 149  :     }
; 150  :     MSD_BASE_SET(msd,(uint32_t)base);

  00045	8b 74 24 0c	 mov	 esi, DWORD PTR _base$[esp]
  00049	8b d6		 mov	 edx, esi
  0004b	c1 ea 10	 shr	 edx, 16			; 00000010H
  0004e	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00051	8b d6		 mov	 edx, esi
  00053	c1 ea 18	 shr	 edx, 24			; 00000018H
  00056	88 50 07	 mov	 BYTE PTR [eax+7], dl

; 151  :     MSD_LIMIT_SET(msd,limit);

  00059	8b d1		 mov	 edx, ecx
  0005b	c1 ea 10	 shr	 edx, 16			; 00000010H
  0005e	32 50 06	 xor	 dl, BYTE PTR [eax+6]
  00061	66 89 70 02	 mov	 WORD PTR [eax+2], si
  00065	80 e2 0f	 and	 dl, 15			; 0000000fH
  00068	30 50 06	 xor	 BYTE PTR [eax+6], dl
  0006b	66 89 08	 mov	 WORD PTR [eax], cx

; 152  : 
; 153  :     return RESULT_SUCCEED;

  0006e	33 c0		 xor	 eax, eax
  00070	5e		 pop	 esi

; 154  : }

  00071	c3		 ret	 0
_I386_msd_set ENDP
_TEXT	ENDS
PUBLIC	_I386_ssd_set
; Function compile flags: /Ogtpy
;	COMDAT _I386_ssd_set
_TEXT	SEGMENT
_msd$ = 8						; size = 4
_base$ = 12						; size = 4
_limit$ = 16						; size = 4
_dpl$ = 20						; size = 4
_type$ = 24						; size = 4
_attr$ = 28						; size = 4
_I386_ssd_set PROC					; COMDAT

; 159  :     if( NULL == msd)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _msd$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 04		 jne	 SHORT $LN8@I386_ssd_s

; 160  :         return RESULT_FAILED;

  00008	83 c8 ff	 or	 eax, -1

; 174  : }

  0000b	c3		 ret	 0
$LN8@I386_ssd_s:

; 161  :     msd->msd_attr       = 0x80;                 /*  描述符存在且为系统段    */
; 162  :     msd->msd_attr      |= (dpl & 3) << 5 ;      /*  设置描述符优先级        */
; 163  :     msd->msd_attr      |= (byte_t)(type & 0x0F );

  0000c	8a 4c 24 10	 mov	 cl, BYTE PTR _dpl$[esp-4]
  00010	8a 54 24 14	 mov	 dl, BYTE PTR _type$[esp-4]
  00014	80 c9 fc	 or	 cl, 252			; 000000fcH
  00017	c0 e1 05	 shl	 cl, 5
  0001a	80 e2 0f	 and	 dl, 15			; 0000000fH
  0001d	0a ca		 or	 cl, dl
  0001f	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 164  :     msd->msd_limit_h   |= (byte_t)(attr & 0xF0 );

  00022	8a 4c 24 18	 mov	 cl, BYTE PTR _attr$[esp-4]
  00026	80 e1 f0	 and	 cl, 240			; 000000f0H
  00029	08 48 06	 or	 BYTE PTR [eax+6], cl

; 165  :     if( limit > 0xFFFFF )

  0002c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _limit$[esp-4]
  00030	81 f9 ff ff 0f
	00		 cmp	 ecx, 1048575		; 000fffffH
  00036	8a 50 06	 mov	 dl, BYTE PTR [eax+6]
  00039	76 09		 jbe	 SHORT $LN6@I386_ssd_s

; 166  :     {
; 167  :         limit               /= 0x1000;

  0003b	c1 e9 0c	 shr	 ecx, 12			; 0000000cH

; 168  :         msd->msd_limit_h    |= MSD_ATTR_GRAIN_4K;

  0003e	80 ca 80	 or	 dl, 128			; 00000080H
  00041	88 50 06	 mov	 BYTE PTR [eax+6], dl
$LN6@I386_ssd_s:
  00044	56		 push	 esi

; 169  :     }
; 170  :     MSD_BASE_SET(msd,(uint32_t)base);

  00045	8b 74 24 0c	 mov	 esi, DWORD PTR _base$[esp]
  00049	8b d6		 mov	 edx, esi
  0004b	c1 ea 10	 shr	 edx, 16			; 00000010H
  0004e	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00051	8b d6		 mov	 edx, esi
  00053	c1 ea 18	 shr	 edx, 24			; 00000018H
  00056	88 50 07	 mov	 BYTE PTR [eax+7], dl

; 171  :     MSD_LIMIT_SET(msd,limit);

  00059	8b d1		 mov	 edx, ecx
  0005b	c1 ea 10	 shr	 edx, 16			; 00000010H
  0005e	32 50 06	 xor	 dl, BYTE PTR [eax+6]
  00061	66 89 70 02	 mov	 WORD PTR [eax+2], si
  00065	80 e2 0f	 and	 dl, 15			; 0000000fH
  00068	30 50 06	 xor	 BYTE PTR [eax+6], dl
  0006b	66 89 08	 mov	 WORD PTR [eax], cx

; 172  : 
; 173  :     return RESULT_SUCCEED;

  0006e	33 c0		 xor	 eax, eax
  00070	5e		 pop	 esi

; 174  : }

  00071	c3		 ret	 0
_I386_ssd_set ENDP
_TEXT	ENDS
PUBLIC	_I386_gate_set
; Function compile flags: /Ogtpy
;	COMDAT _I386_gate_set
_TEXT	SEGMENT
_gate$ = 8						; size = 4
_selector$ = 12						; size = 2
_offset$ = 16						; size = 4
_dpl$ = 20						; size = 4
_dcount$ = 24						; size = 4
_type$ = 28						; size = 4
_I386_gate_set PROC					; COMDAT

; 208  :     if( NULL == gate )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _gate$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 37		 je	 SHORT $LN5@I386_gate_

; 209  :         return ;
; 210  :     GATE_OFFSET_SET(gate,(uint32_t)offset);

  00008	8b 4c 24 0c	 mov	 ecx, DWORD PTR _offset$[esp-4]

; 211  :     gate->gate_selector     = selector;
; 212  :     gate->gate_dcount       = (byte_t)(dcount & 0x1F);

  0000c	8a 54 24 14	 mov	 dl, BYTE PTR _dcount$[esp-4]
  00010	66 89 08	 mov	 WORD PTR [eax], cx
  00013	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00016	66 89 48 06	 mov	 WORD PTR [eax+6], cx
  0001a	66 8b 4c 24 08	 mov	 cx, WORD PTR _selector$[esp-4]
  0001f	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 213  :     gate->gate_attr         = 0x80;/*  描述符存在且为系统段 */
; 214  :     gate->gate_attr        |= (type & 0x0F) | ((dpl & 0x03)<< 5) ;

  00023	8a 4c 24 10	 mov	 cl, BYTE PTR _dpl$[esp-4]
  00027	80 e2 1f	 and	 dl, 31			; 0000001fH
  0002a	88 50 04	 mov	 BYTE PTR [eax+4], dl
  0002d	8a 54 24 18	 mov	 dl, BYTE PTR _type$[esp-4]
  00031	80 c9 fc	 or	 cl, 252			; 000000fcH
  00034	c0 e1 05	 shl	 cl, 5
  00037	80 e2 0f	 and	 dl, 15			; 0000000fH
  0003a	0a ca		 or	 cl, dl
  0003c	88 48 05	 mov	 BYTE PTR [eax+5], cl
$LN5@I386_gate_:

; 215  : }

  0003f	c3		 ret	 0
_I386_gate_set ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _I386_refresh_cs
_TEXT	SEGMENT
_eflags$ = 8						; size = 4
_selector$ = 12						; size = 4
_I386_refresh_cs PROC					; COMDAT

; 224  :     __asm iretd;

  00000	cf		 iretd
_I386_refresh_cs ENDP
_TEXT	ENDS
PUBLIC	_I386_load_gdt
; Function compile flags: /Ogtpy
;	COMDAT _I386_load_gdt
_TEXT	SEGMENT
_pd$ = -8						; size = 6
_limit$ = 8						; size = 4
_offset$ = 12						; size = 4
_I386_load_gdt PROC					; COMDAT

; 231  : {

  00000	83 ec 08	 sub	 esp, 8

; 232  :     fword_t         pd;
; 233  : 
; 234  :     pd.low_16   = (word_t)limit;

  00003	66 8b 44 24 0c	 mov	 ax, WORD PTR _limit$[esp+4]

; 235  :     pd.high_32  = offset;

  00008	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset$[esp+4]
  0000c	66 89 04 24	 mov	 WORD PTR _pd$[esp+8], ax
  00010	89 4c 24 02	 mov	 DWORD PTR _pd$[esp+10], ecx

; 236  :     __asm lgdt fword ptr pd

  00014	0f 01 14 24	 lgdt	 FWORD PTR _pd$[esp+8]

; 237  : }

  00018	83 c4 08	 add	 esp, 8
  0001b	c3		 ret	 0
_I386_load_gdt ENDP
_TEXT	ENDS
PUBLIC	_I386_load_idt
; Function compile flags: /Ogtpy
;	COMDAT _I386_load_idt
_TEXT	SEGMENT
_pd$ = -8						; size = 6
_limit$ = 8						; size = 4
_offset$ = 12						; size = 4
_I386_load_idt PROC					; COMDAT

; 240  : {

  00000	83 ec 08	 sub	 esp, 8

; 241  :     fword_t     pd;
; 242  : 
; 243  :     pd.low_16   = (word_t)limit;

  00003	66 8b 44 24 0c	 mov	 ax, WORD PTR _limit$[esp+4]

; 244  :     pd.high_32  = offset;

  00008	8b 4c 24 10	 mov	 ecx, DWORD PTR _offset$[esp+4]
  0000c	66 89 04 24	 mov	 WORD PTR _pd$[esp+8], ax
  00010	89 4c 24 02	 mov	 DWORD PTR _pd$[esp+10], ecx

; 245  :     __asm lidt fword ptr pd

  00014	0f 01 1c 24	 lidt	 FWORD PTR _pd$[esp+8]

; 246  : }

  00018	83 c4 08	 add	 esp, 8
  0001b	c3		 ret	 0
_I386_load_idt ENDP
_TEXT	ENDS
PUBLIC	_I386_load_ldt
; Function compile flags: /Ogtpy
;	COMDAT _I386_load_ldt
_TEXT	SEGMENT
_selector$ = 8						; size = 4
_I386_load_ldt PROC					; COMDAT

; 251  :     __asm
; 252  :     {
; 253  :         mov eax,[esp + 4];

  00000	8b 44 24 04	 mov	 eax, DWORD PTR [esp+4]

; 254  :         lldt ax

  00004	0f 00 d0	 lldt	 ax

; 255  :         ret

  00007	c3		 ret	 0
_I386_load_ldt ENDP
_TEXT	ENDS
PUBLIC	_I386_load_tr
; Function compile flags: /Ogtpy
;	COMDAT _I386_load_tr
_TEXT	SEGMENT
_selector$ = 8						; size = 4
_I386_load_tr PROC					; COMDAT

; 262  :     __asm
; 263  :     {
; 264  :         mov eax,[esp + 4];

  00000	8b 44 24 04	 mov	 eax, DWORD PTR [esp+4]

; 265  :         ltr ax

  00004	0f 00 d8	 ltr	 ax

; 266  :         ret

  00007	c3		 ret	 0
_I386_load_tr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@PIBKECFA@DS?$DN?$CF04X?5ES?$DN?$CF04X?5FS?$DN?$CF04X?5GS?$DN?$CF04X?6@ ; `string'
PUBLIC	??_C@_0BM@KIFNCEGI@CR0?$DN?$CF08X?5CR2?$DN?$CF08X?5CR3?$DN?$CF08X?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@GNKIMLFD@ESP?$DN?$CF08X?5EBP?$DN?$CF08X?5ESI?$DN?$CF08X?5EDI?$DN?$CF@ ; `string'
PUBLIC	??_C@_0CF@BAOINNOB@EAX?$DN?$CF08X?5ECX?$DN?$CF08X?5EDX?$DN?$CF08X?5EBX?$DN?$CF@ ; `string'
PUBLIC	??_C@_0BP@IMMNFPCH@?6CS?3EIP?$DN?$CF04X?3?$CF08X?5EFLAGS?$DN?$CF08X?6?$AA@ ; `string'
PUBLIC	_I386_reg_dump
EXTRN	__printk:PROC
;	COMDAT ??_C@_0CB@PIBKECFA@DS?$DN?$CF04X?5ES?$DN?$CF04X?5FS?$DN?$CF04X?5GS?$DN?$CF04X?6@
CONST	SEGMENT
??_C@_0CB@PIBKECFA@DS?$DN?$CF04X?5ES?$DN?$CF04X?5FS?$DN?$CF04X?5GS?$DN?$CF04X?6@ DB 'D'
	DB	'S=%04X ES=%04X FS=%04X GS=%04X', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KIFNCEGI@CR0?$DN?$CF08X?5CR2?$DN?$CF08X?5CR3?$DN?$CF08X?6?$AA@
CONST	SEGMENT
??_C@_0BM@KIFNCEGI@CR0?$DN?$CF08X?5CR2?$DN?$CF08X?5CR3?$DN?$CF08X?6?$AA@ DB 'C'
	DB	'R0=%08X CR2=%08X CR3=%08X', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GNKIMLFD@ESP?$DN?$CF08X?5EBP?$DN?$CF08X?5ESI?$DN?$CF08X?5EDI?$DN?$CF@
CONST	SEGMENT
??_C@_0CF@GNKIMLFD@ESP?$DN?$CF08X?5EBP?$DN?$CF08X?5ESI?$DN?$CF08X?5EDI?$DN?$CF@ DB 'E'
	DB	'SP=%08X EBP=%08X ESI=%08X EDI=%08X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BAOINNOB@EAX?$DN?$CF08X?5ECX?$DN?$CF08X?5EDX?$DN?$CF08X?5EBX?$DN?$CF@
CONST	SEGMENT
??_C@_0CF@BAOINNOB@EAX?$DN?$CF08X?5ECX?$DN?$CF08X?5EDX?$DN?$CF08X?5EBX?$DN?$CF@ DB 'E'
	DB	'AX=%08X ECX=%08X EDX=%08X EBX=%08X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IMMNFPCH@?6CS?3EIP?$DN?$CF04X?3?$CF08X?5EFLAGS?$DN?$CF08X?6?$AA@
CONST	SEGMENT
??_C@_0BP@IMMNFPCH@?6CS?3EIP?$DN?$CF04X?3?$CF08X?5EFLAGS?$DN?$CF08X?6?$AA@ DB 0aH
	DB	'CS:EIP=%04X:%08X EFLAGS=%08X', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _I386_reg_dump
_TEXT	SEGMENT
_cr3$ = 8						; size = 4
_cr2$ = 12						; size = 4
_cr0$ = 16						; size = 4
_ds$ = 20						; size = 4
_es$ = 24						; size = 4
_fs$ = 28						; size = 4
_gs$ = 32						; size = 4
_edi$ = 36						; size = 4
_esi$ = 40						; size = 4
_ebp$ = 44						; size = 4
_esp$ = 48						; size = 4
_ebx$ = 52						; size = 4
_edx$ = 56						; size = 4
_ecx$ = 60						; size = 4
_eax$ = 64						; size = 4
_eip$ = 68						; size = 4
_cs$ = 72						; size = 4
_eflags$ = 76						; size = 4
_I386_reg_dump PROC					; COMDAT

; 315  :     _printk("\nCS:EIP=%04X:%08X EFLAGS=%08X\n",cs & 0xFFFF,eip,eflags);

  00000	8b 44 24 48	 mov	 eax, DWORD PTR _eflags$[esp-4]
  00004	8b 4c 24 40	 mov	 ecx, DWORD PTR _eip$[esp-4]
  00008	8b 54 24 44	 mov	 edx, DWORD PTR _cs$[esp-4]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00014	52		 push	 edx
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IMMNFPCH@?6CS?3EIP?$DN?$CF04X?3?$CF08X?5EFLAGS?$DN?$CF08X?6?$AA@
  0001a	e8 00 00 00 00	 call	 __printk

; 316  :     _printk("EAX=%08X ECX=%08X EDX=%08X EBX=%08X\n",eax,ecx,edx,ebx);

  0001f	8b 44 24 40	 mov	 eax, DWORD PTR _ebx$[esp+12]
  00023	8b 4c 24 44	 mov	 ecx, DWORD PTR _edx$[esp+12]
  00027	8b 54 24 48	 mov	 edx, DWORD PTR _ecx$[esp+12]
  0002b	50		 push	 eax
  0002c	8b 44 24 50	 mov	 eax, DWORD PTR _eax$[esp+16]
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BAOINNOB@EAX?$DN?$CF08X?5ECX?$DN?$CF08X?5EDX?$DN?$CF08X?5EBX?$DN?$CF@
  00038	e8 00 00 00 00	 call	 __printk

; 317  :     _printk("ESP=%08X EBP=%08X ESI=%08X EDI=%08X\n",esp,ebp,esi,edi);

  0003d	8b 4c 24 44	 mov	 ecx, DWORD PTR _edi$[esp+32]
  00041	8b 54 24 48	 mov	 edx, DWORD PTR _esi$[esp+32]
  00045	8b 44 24 4c	 mov	 eax, DWORD PTR _ebp$[esp+32]
  00049	51		 push	 ecx
  0004a	8b 4c 24 54	 mov	 ecx, DWORD PTR _esp$[esp+36]
  0004e	52		 push	 edx
  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GNKIMLFD@ESP?$DN?$CF08X?5EBP?$DN?$CF08X?5ESI?$DN?$CF08X?5EDI?$DN?$CF@
  00056	e8 00 00 00 00	 call	 __printk

; 318  :     _printk("CR0=%08X CR2=%08X CR3=%08X\n",cr0,cr2,cr3);

  0005b	8b 54 24 3c	 mov	 edx, DWORD PTR _cr3$[esp+52]
  0005f	8b 44 24 40	 mov	 eax, DWORD PTR _cr2$[esp+52]
  00063	8b 4c 24 44	 mov	 ecx, DWORD PTR _cr0$[esp+52]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KIFNCEGI@CR0?$DN?$CF08X?5CR2?$DN?$CF08X?5CR3?$DN?$CF08X?6?$AA@
  0006f	e8 00 00 00 00	 call	 __printk

; 319  :     _printk("DS=%04X ES=%04X FS=%04X GS=%04X\n",
; 320  :         ds & 0xFFFF,es & 0xFFFF,fs & 0xFFFF,gs & 0xFFFF);

  00074	8b 54 24 64	 mov	 edx, DWORD PTR _gs$[esp+68]
  00078	8b 44 24 60	 mov	 eax, DWORD PTR _fs$[esp+68]
  0007c	8b 4c 24 5c	 mov	 ecx, DWORD PTR _es$[esp+68]
  00080	83 c4 48	 add	 esp, 72			; 00000048H
  00083	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00089	52		 push	 edx
  0008a	8b 54 24 14	 mov	 edx, DWORD PTR _ds$[esp]
  0008e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00093	50		 push	 eax
  00094	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0009a	51		 push	 ecx
  0009b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000a1	52		 push	 edx
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PIBKECFA@DS?$DN?$CF04X?5ES?$DN?$CF04X?5FS?$DN?$CF04X?5GS?$DN?$CF04X?6@
  000a7	e8 00 00 00 00	 call	 __printk
  000ac	83 c4 14	 add	 esp, 20			; 00000014H

; 321  : }

  000af	c3		 ret	 0
_I386_reg_dump ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@PKLNCCNP@Err?5code?$DN?$CF08X?6?$AA@	; `string'
PUBLIC	_I386_reg_dumpe
;	COMDAT ??_C@_0P@PKLNCCNP@Err?5code?$DN?$CF08X?6?$AA@
CONST	SEGMENT
??_C@_0P@PKLNCCNP@Err?5code?$DN?$CF08X?6?$AA@ DB 'Err code=%08X', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _I386_reg_dumpe
_TEXT	SEGMENT
_cr3$ = 8						; size = 4
_cr2$ = 12						; size = 4
_cr0$ = 16						; size = 4
_ds$ = 20						; size = 4
_es$ = 24						; size = 4
_fs$ = 28						; size = 4
_gs$ = 32						; size = 4
_edi$ = 36						; size = 4
_esi$ = 40						; size = 4
_ebp$ = 44						; size = 4
_esp$ = 48						; size = 4
_ebx$ = 52						; size = 4
_edx$ = 56						; size = 4
_ecx$ = 60						; size = 4
_eax$ = 64						; size = 4
_err$ = 68						; size = 4
_eip$ = 72						; size = 4
_cs$ = 76						; size = 4
_eflags$ = 80						; size = 4
_I386_reg_dumpe PROC					; COMDAT

; 364  :     _printk("\nCS:EIP=%04X:%08X EFLAGS=%08X\n",cs & 0xFFFF,eip,eflags);

  00000	8b 44 24 4c	 mov	 eax, DWORD PTR _eflags$[esp-4]
  00004	8b 4c 24 44	 mov	 ecx, DWORD PTR _eip$[esp-4]
  00008	8b 54 24 48	 mov	 edx, DWORD PTR _cs$[esp-4]
  0000c	50		 push	 eax
  0000d	51		 push	 ecx
  0000e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00014	52		 push	 edx
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IMMNFPCH@?6CS?3EIP?$DN?$CF04X?3?$CF08X?5EFLAGS?$DN?$CF08X?6?$AA@
  0001a	e8 00 00 00 00	 call	 __printk

; 365  :     _printk("EAX=%08X ECX=%08X EDX=%08X EBX=%08X\n",eax,ecx,edx,ebx);

  0001f	8b 44 24 40	 mov	 eax, DWORD PTR _ebx$[esp+12]
  00023	8b 4c 24 44	 mov	 ecx, DWORD PTR _edx$[esp+12]
  00027	8b 54 24 48	 mov	 edx, DWORD PTR _ecx$[esp+12]
  0002b	50		 push	 eax
  0002c	8b 44 24 50	 mov	 eax, DWORD PTR _eax$[esp+16]
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BAOINNOB@EAX?$DN?$CF08X?5ECX?$DN?$CF08X?5EDX?$DN?$CF08X?5EBX?$DN?$CF@
  00038	e8 00 00 00 00	 call	 __printk

; 366  :     _printk("ESP=%08X EBP=%08X ESI=%08X EDI=%08X\n",esp,ebp,esi,edi);

  0003d	8b 4c 24 44	 mov	 ecx, DWORD PTR _edi$[esp+32]
  00041	8b 54 24 48	 mov	 edx, DWORD PTR _esi$[esp+32]
  00045	8b 44 24 4c	 mov	 eax, DWORD PTR _ebp$[esp+32]
  00049	51		 push	 ecx
  0004a	8b 4c 24 54	 mov	 ecx, DWORD PTR _esp$[esp+36]
  0004e	52		 push	 edx
  0004f	50		 push	 eax
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GNKIMLFD@ESP?$DN?$CF08X?5EBP?$DN?$CF08X?5ESI?$DN?$CF08X?5EDI?$DN?$CF@
  00056	e8 00 00 00 00	 call	 __printk

; 367  :     _printk("CR0=%08X CR2=%08X CR3=%08X\n",cr0,cr2,cr3);

  0005b	8b 54 24 3c	 mov	 edx, DWORD PTR _cr3$[esp+52]
  0005f	8b 44 24 40	 mov	 eax, DWORD PTR _cr2$[esp+52]
  00063	8b 4c 24 44	 mov	 ecx, DWORD PTR _cr0$[esp+52]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	51		 push	 ecx
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KIFNCEGI@CR0?$DN?$CF08X?5CR2?$DN?$CF08X?5CR3?$DN?$CF08X?6?$AA@
  0006f	e8 00 00 00 00	 call	 __printk

; 368  :     _printk("DS=%04X ES=%04X FS=%04X GS=%04X\n",
; 369  :         ds & 0xFFFF,es & 0xFFFF,fs & 0xFFFF,gs & 0xFFFF);

  00074	8b 54 24 64	 mov	 edx, DWORD PTR _gs$[esp+68]
  00078	8b 44 24 60	 mov	 eax, DWORD PTR _fs$[esp+68]
  0007c	8b 4c 24 5c	 mov	 ecx, DWORD PTR _es$[esp+68]
  00080	83 c4 48	 add	 esp, 72			; 00000048H
  00083	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00089	52		 push	 edx
  0008a	8b 54 24 14	 mov	 edx, DWORD PTR _ds$[esp]
  0008e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00093	50		 push	 eax
  00094	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0009a	51		 push	 ecx
  0009b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000a1	52		 push	 edx
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PIBKECFA@DS?$DN?$CF04X?5ES?$DN?$CF04X?5FS?$DN?$CF04X?5GS?$DN?$CF04X?6@
  000a7	e8 00 00 00 00	 call	 __printk

; 370  :     _printk("Err code=%08X\n",err);

  000ac	8b 44 24 54	 mov	 eax, DWORD PTR _err$[esp+16]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0P@PKLNCCNP@Err?5code?$DN?$CF08X?6?$AA@
  000b6	e8 00 00 00 00	 call	 __printk
  000bb	83 c4 1c	 add	 esp, 28			; 0000001cH

; 371  : }

  000be	c3		 ret	 0
_I386_reg_dumpe ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	_I386_fault_div_zero
EXTRN	_Cpu_hlt:PROC
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _I386_fault_div_zero
_TEXT	SEGMENT
_I386_fault_div_zero PROC				; COMDAT

; 375  :     I386_CLI;

  00000	fa		 cli

; 376  :     _printk("%s\n",i386_fault_name[0]);

  00001	a1 00 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault:

; 377  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault
_I386_fault_div_zero ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_debug
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_debug
_TEXT	SEGMENT
_I386_fault_debug PROC					; COMDAT

; 383  :     I386_CLI;

  00000	fa		 cli

; 384  :     _printk("%s\n",i386_fault_name[1]);

  00001	a1 04 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+4
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@2:

; 385  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@2
_I386_fault_debug ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_single_step
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_single_step
_TEXT	SEGMENT
_I386_fault_single_step PROC				; COMDAT

; 391  :     __asm
; 392  :     {
; 393  :         pushad

  00000	60		 pushad

; 394  :         push gs

  00001	0f a8		 push	 gs

; 395  :         push fs

  00003	0f a0		 push	 fs

; 396  :         push es

  00005	06		 push	 es

; 397  :         push ds

  00006	1e		 push	 ds

; 398  :         mov eax,cr0

  00007	0f 20 c0	 mov	 eax, cr0

; 399  :         push eax

  0000a	50		 push	 eax

; 400  :         mov eax,cr3

  0000b	0f 20 d8	 mov	 eax, cr3

; 401  :         push eax

  0000e	50		 push	 eax

; 402  :         call I386_reg_dump

  0000f	e8 00 00 00 00	 call	 _I386_reg_dump

; 403  :     }
; 404  :     I386_CLI;

  00014	fa		 cli

; 405  :     _printk("%s\n",i386_fault_name[3]);

  00015	a1 0c 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+12
  0001a	50		 push	 eax
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00020	e8 00 00 00 00	 call	 __printk
  00025	83 c4 08	 add	 esp, 8
$LL2@I386_fault@3:

; 406  :     for(;;) Cpu_hlt();

  00028	e8 00 00 00 00	 call	 _Cpu_hlt
  0002d	eb f9		 jmp	 SHORT $LL2@I386_fault@3
_I386_fault_single_step ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_overflow
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_overflow
_TEXT	SEGMENT
_I386_fault_overflow PROC				; COMDAT

; 412  :     I386_CLI;

  00000	fa		 cli

; 413  :     _printk("%s\n",i386_fault_name[4]);

  00001	a1 10 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+16
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@4:

; 414  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@4
_I386_fault_overflow ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_bound
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_bound
_TEXT	SEGMENT
_I386_fault_bound PROC					; COMDAT

; 420  :     I386_CLI;

  00000	fa		 cli

; 421  :     _printk("%s\n",i386_fault_name[5]);

  00001	a1 14 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+20
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@5:

; 422  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@5
_I386_fault_bound ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_invalid_opcode
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_invalid_opcode
_TEXT	SEGMENT
_I386_fault_invalid_opcode PROC				; COMDAT

; 428  :     I386_CLI;

  00000	fa		 cli

; 429  :     _printk("%s\n",i386_fault_name[6]);

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+24
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@6:

; 430  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@6
_I386_fault_invalid_opcode ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_device
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_device
_TEXT	SEGMENT
_I386_fault_device PROC					; COMDAT

; 436  :     I386_CLI;

  00000	fa		 cli

; 437  :     _printk("%s\n",i386_fault_name[7]);

  00001	a1 1c 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+28
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@7:

; 438  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@7
_I386_fault_device ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_double
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_double
_TEXT	SEGMENT
_I386_fault_double PROC					; COMDAT

; 444  :     I386_CLI;

  00000	fa		 cli

; 445  :     _printk("%s\n",i386_fault_name[8]);

  00001	a1 20 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+32
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@8:

; 446  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@8
_I386_fault_double ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_fpu_ob
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_fpu_ob
_TEXT	SEGMENT
_I386_fault_fpu_ob PROC					; COMDAT

; 452  :     I386_CLI;

  00000	fa		 cli

; 453  :     _printk("%s\n",i386_fault_name[9]);

  00001	a1 24 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+36
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@9:

; 454  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@9
_I386_fault_fpu_ob ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_tss
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_tss
_TEXT	SEGMENT
_I386_fault_tss PROC					; COMDAT

; 460  :     I386_CLI;

  00000	fa		 cli

; 461  :     _printk("%s\n",i386_fault_name[0xA]);

  00001	a1 28 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+40
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@10:

; 462  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@10
_I386_fault_tss ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_segment
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_segment
_TEXT	SEGMENT
_I386_fault_segment PROC				; COMDAT

; 468  :     I386_CLI;

  00000	fa		 cli

; 469  :     _printk("%s\n",i386_fault_name[0xB]);

  00001	a1 2c 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+44
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@11:

; 470  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@11
_I386_fault_segment ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_stack
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_stack
_TEXT	SEGMENT
_I386_fault_stack PROC					; COMDAT

; 476  :     I386_CLI;

  00000	fa		 cli

; 477  :     _printk("%s\n",i386_fault_name[0xC]);

  00001	a1 30 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+48
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@12:

; 478  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@12
_I386_fault_stack ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_general
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_general
_TEXT	SEGMENT
_I386_fault_general PROC				; COMDAT

; 484  :     I386_CLI;

  00000	fa		 cli

; 485  :     _printk("%s\n",i386_fault_name[0xD]);

  00001	a1 34 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+52
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@13:

; 486  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@13
_I386_fault_general ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_page
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_page
_TEXT	SEGMENT
_I386_fault_page PROC					; COMDAT

; 492  :     I386_CLI;

  00000	fa		 cli

; 493  :     I386_REG_DUMPE();

  00001	60		 pushad
  00002	0f a8		 push	 gs
  00004	0f a0		 push	 fs
  00006	06		 push	 es
  00007	1e		 push	 ds
  00008	0f 20 c0	 mov	 eax, cr0
  0000b	50		 push	 eax
  0000c	0f 20 d0	 mov	 eax, cr2
  0000f	50		 push	 eax
  00010	0f 20 d8	 mov	 eax, cr3
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _I386_reg_dumpe
  00019	83 c4 3c	 add	 esp, 60			; 0000003cH

; 494  :     DEBUG_HLT(i386_fault_name[0xE]);

  0001c	a1 38 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+56
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00027	e8 00 00 00 00	 call	 __printk
  0002c	83 c4 08	 add	 esp, 8
  0002f	90		 npad	 1
$LL2@I386_fault@14:
  00030	e8 00 00 00 00	 call	 _Cpu_hlt
  00035	eb f9		 jmp	 SHORT $LL2@I386_fault@14
_I386_fault_page ENDP
_TEXT	ENDS
PUBLIC	_I386_fault_fpu
; Function compile flags: /Ogtpy
;	COMDAT _I386_fault_fpu
_TEXT	SEGMENT
_I386_fault_fpu PROC					; COMDAT

; 500  :     I386_CLI;

  00000	fa		 cli

; 501  :     _printk("%s\n",i386_fault_name[0xF]);

  00001	a1 3c 00 00 00	 mov	 eax, DWORD PTR _i386_fault_name+60
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0000c	e8 00 00 00 00	 call	 __printk
  00011	83 c4 08	 add	 esp, 8
$LL2@I386_fault@15:

; 502  :     for(;;) Cpu_hlt();

  00014	e8 00 00 00 00	 call	 _Cpu_hlt
  00019	eb f9		 jmp	 SHORT $LL2@I386_fault@15
_I386_fault_fpu ENDP
_TEXT	ENDS
PUBLIC	_Ivt_set
_BSS	SEGMENT
_idt	DQ	0100H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Ivt_set
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_offset$ = 12						; size = 4
_Ivt_set PROC						; COMDAT

; 525  :     dword_t         po = 0; /* 原处理程序, prev offset   */
; 526  : 
; 527  :     po = GATE_OFFSET_GET(idt + (idx & 0xFF));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _idx$[esp-4]
  00004	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00009	03 c0		 add	 eax, eax
  0000b	03 c0		 add	 eax, eax
  0000d	03 c0		 add	 eax, eax
  0000f	0f b7 90 00 00
	00 00		 movzx	 edx, WORD PTR _idt[eax]
  00016	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR _idt[eax]
  0001c	0f b7 80 06 00
	00 00		 movzx	 eax, WORD PTR _idt[eax+6]
  00023	c1 e0 10	 shl	 eax, 16			; 00000010H
  00026	03 c2		 add	 eax, edx

; 528  :     I386_gate_set(idt + (idx & 0xFF),SELECTOR_KERNEL_CODE,(void *)offset,
; 529  :                   0,0,GATE_TYPE_INT_32);

  00028	85 c9		 test	 ecx, ecx
  0002a	74 1c		 je	 SHORT $LN7@Ivt_set
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR _offset$[esp-4]
  00030	66 89 11	 mov	 WORD PTR [ecx], dx
  00033	c1 ea 10	 shr	 edx, 16			; 00000010H
  00036	66 89 51 06	 mov	 WORD PTR [ecx+6], dx
  0003a	66 c7 41 02 08
	00		 mov	 WORD PTR [ecx+2], 8
  00040	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00044	c6 41 05 8e	 mov	 BYTE PTR [ecx+5], 142	; 0000008eH
$LN7@Ivt_set:

; 530  : 
; 531  :     return po;
; 532  : }

  00048	c3		 ret	 0
_Ivt_set ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _I386_sys_trap_initial
_TEXT	SEGMENT
_I386_sys_trap_initial PROC				; COMDAT

; 551  : {

  00000	56		 push	 esi

; 552  :     I386_gate_set(idt + 0,SELECTOR_KERNEL_CODE,I386_fault_div_zero,
; 553  :         3,0,GATE_TYPE_TRAP_32);

  00001	33 f6		 xor	 esi, esi
  00003	32 c9		 xor	 cl, cl
  00005	81 fe 00 00 00
	00		 cmp	 esi, OFFSET _idt
  0000b	ba 08 00 00 00	 mov	 edx, 8
  00010	b0 ef		 mov	 al, 239			; 000000efH
  00012	74 2d		 je	 SHORT $LN7@I386_sys_t
  00014	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_div_zero
  00019	66 89 35 00 00
	00 00		 mov	 WORD PTR _idt, si
  00020	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_div_zero
  00025	c1 ee 10	 shr	 esi, 16			; 00000010H
  00028	66 89 35 06 00
	00 00		 mov	 WORD PTR _idt+6, si
  0002f	66 89 15 02 00
	00 00		 mov	 WORD PTR _idt+2, dx
  00036	88 0d 04 00 00
	00		 mov	 BYTE PTR _idt+4, cl
  0003c	a2 05 00 00 00	 mov	 BYTE PTR _idt+5, al
$LN7@I386_sys_t:

; 554  :     I386_gate_set(idt + 1,SELECTOR_KERNEL_CODE,I386_fault_debug,
; 555  :         3,0,GATE_TYPE_TRAP_32);

  00041	33 f6		 xor	 esi, esi
  00043	81 fe 08 00 00
	00		 cmp	 esi, OFFSET _idt+8
  00049	74 2d		 je	 SHORT $LN13@I386_sys_t
  0004b	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_debug
  00050	66 89 35 08 00
	00 00		 mov	 WORD PTR _idt+8, si
  00057	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_debug
  0005c	c1 ee 10	 shr	 esi, 16			; 00000010H
  0005f	66 89 35 0e 00
	00 00		 mov	 WORD PTR _idt+14, si
  00066	66 89 15 0a 00
	00 00		 mov	 WORD PTR _idt+10, dx
  0006d	88 0d 0c 00 00
	00		 mov	 BYTE PTR _idt+12, cl
  00073	a2 0d 00 00 00	 mov	 BYTE PTR _idt+13, al
$LN13@I386_sys_t:

; 556  :     I386_gate_set(idt + 3,SELECTOR_KERNEL_CODE,I386_fault_single_step,
; 557  :         3,0,GATE_TYPE_TRAP_32);

  00078	33 f6		 xor	 esi, esi
  0007a	81 fe 18 00 00
	00		 cmp	 esi, OFFSET _idt+24
  00080	74 2d		 je	 SHORT $LN19@I386_sys_t
  00082	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_single_step
  00087	66 89 35 18 00
	00 00		 mov	 WORD PTR _idt+24, si
  0008e	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_single_step
  00093	c1 ee 10	 shr	 esi, 16			; 00000010H
  00096	66 89 35 1e 00
	00 00		 mov	 WORD PTR _idt+30, si
  0009d	66 89 15 1a 00
	00 00		 mov	 WORD PTR _idt+26, dx
  000a4	88 0d 1c 00 00
	00		 mov	 BYTE PTR _idt+28, cl
  000aa	a2 1d 00 00 00	 mov	 BYTE PTR _idt+29, al
$LN19@I386_sys_t:

; 558  :     I386_gate_set(idt + 4,SELECTOR_KERNEL_CODE,I386_fault_overflow,
; 559  :         3,0,GATE_TYPE_TRAP_32);

  000af	33 f6		 xor	 esi, esi
  000b1	81 fe 20 00 00
	00		 cmp	 esi, OFFSET _idt+32
  000b7	74 2d		 je	 SHORT $LN25@I386_sys_t
  000b9	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_overflow
  000be	66 89 35 20 00
	00 00		 mov	 WORD PTR _idt+32, si
  000c5	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_overflow
  000ca	c1 ee 10	 shr	 esi, 16			; 00000010H
  000cd	66 89 35 26 00
	00 00		 mov	 WORD PTR _idt+38, si
  000d4	66 89 15 22 00
	00 00		 mov	 WORD PTR _idt+34, dx
  000db	88 0d 24 00 00
	00		 mov	 BYTE PTR _idt+36, cl
  000e1	a2 25 00 00 00	 mov	 BYTE PTR _idt+37, al
$LN25@I386_sys_t:

; 560  :     I386_gate_set(idt + 5,SELECTOR_KERNEL_CODE,I386_fault_bound,
; 561  :         3,0,GATE_TYPE_TRAP_32);

  000e6	33 f6		 xor	 esi, esi
  000e8	81 fe 28 00 00
	00		 cmp	 esi, OFFSET _idt+40
  000ee	74 2d		 je	 SHORT $LN31@I386_sys_t
  000f0	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_bound
  000f5	66 89 35 28 00
	00 00		 mov	 WORD PTR _idt+40, si
  000fc	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_bound
  00101	c1 ee 10	 shr	 esi, 16			; 00000010H
  00104	66 89 35 2e 00
	00 00		 mov	 WORD PTR _idt+46, si
  0010b	66 89 15 2a 00
	00 00		 mov	 WORD PTR _idt+42, dx
  00112	88 0d 2c 00 00
	00		 mov	 BYTE PTR _idt+44, cl
  00118	a2 2d 00 00 00	 mov	 BYTE PTR _idt+45, al
$LN31@I386_sys_t:

; 562  :     I386_gate_set(idt + 6,SELECTOR_KERNEL_CODE,I386_fault_invalid_opcode,
; 563  :         3,0,GATE_TYPE_TRAP_32);

  0011d	33 f6		 xor	 esi, esi
  0011f	81 fe 30 00 00
	00		 cmp	 esi, OFFSET _idt+48
  00125	74 2d		 je	 SHORT $LN37@I386_sys_t
  00127	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_invalid_opcode
  0012c	66 89 35 30 00
	00 00		 mov	 WORD PTR _idt+48, si
  00133	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_invalid_opcode
  00138	c1 ee 10	 shr	 esi, 16			; 00000010H
  0013b	66 89 35 36 00
	00 00		 mov	 WORD PTR _idt+54, si
  00142	66 89 15 32 00
	00 00		 mov	 WORD PTR _idt+50, dx
  00149	88 0d 34 00 00
	00		 mov	 BYTE PTR _idt+52, cl
  0014f	a2 35 00 00 00	 mov	 BYTE PTR _idt+53, al
$LN37@I386_sys_t:

; 564  :     I386_gate_set(idt + 7,SELECTOR_KERNEL_CODE,I386_fault_device,
; 565  :         3,0,GATE_TYPE_TRAP_32);

  00154	33 f6		 xor	 esi, esi
  00156	81 fe 38 00 00
	00		 cmp	 esi, OFFSET _idt+56
  0015c	74 2d		 je	 SHORT $LN43@I386_sys_t
  0015e	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_device
  00163	66 89 35 38 00
	00 00		 mov	 WORD PTR _idt+56, si
  0016a	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_device
  0016f	c1 ee 10	 shr	 esi, 16			; 00000010H
  00172	66 89 35 3e 00
	00 00		 mov	 WORD PTR _idt+62, si
  00179	66 89 15 3a 00
	00 00		 mov	 WORD PTR _idt+58, dx
  00180	88 0d 3c 00 00
	00		 mov	 BYTE PTR _idt+60, cl
  00186	a2 3d 00 00 00	 mov	 BYTE PTR _idt+61, al
$LN43@I386_sys_t:

; 566  :     I386_gate_set(idt + 8,SELECTOR_KERNEL_CODE,I386_fault_double,
; 567  :         3,0,GATE_TYPE_TRAP_32);

  0018b	33 f6		 xor	 esi, esi
  0018d	81 fe 40 00 00
	00		 cmp	 esi, OFFSET _idt+64
  00193	74 2d		 je	 SHORT $LN49@I386_sys_t
  00195	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_double
  0019a	66 89 35 40 00
	00 00		 mov	 WORD PTR _idt+64, si
  001a1	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_double
  001a6	c1 ee 10	 shr	 esi, 16			; 00000010H
  001a9	66 89 35 46 00
	00 00		 mov	 WORD PTR _idt+70, si
  001b0	66 89 15 42 00
	00 00		 mov	 WORD PTR _idt+66, dx
  001b7	88 0d 44 00 00
	00		 mov	 BYTE PTR _idt+68, cl
  001bd	a2 45 00 00 00	 mov	 BYTE PTR _idt+69, al
$LN49@I386_sys_t:

; 568  :     I386_gate_set(idt + 9,SELECTOR_KERNEL_CODE,I386_fault_fpu_ob,
; 569  :         3,0,GATE_TYPE_TRAP_32);

  001c2	33 f6		 xor	 esi, esi
  001c4	81 fe 48 00 00
	00		 cmp	 esi, OFFSET _idt+72
  001ca	74 2d		 je	 SHORT $LN55@I386_sys_t
  001cc	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_fpu_ob
  001d1	66 89 35 48 00
	00 00		 mov	 WORD PTR _idt+72, si
  001d8	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_fpu_ob
  001dd	c1 ee 10	 shr	 esi, 16			; 00000010H
  001e0	66 89 35 4e 00
	00 00		 mov	 WORD PTR _idt+78, si
  001e7	66 89 15 4a 00
	00 00		 mov	 WORD PTR _idt+74, dx
  001ee	88 0d 4c 00 00
	00		 mov	 BYTE PTR _idt+76, cl
  001f4	a2 4d 00 00 00	 mov	 BYTE PTR _idt+77, al
$LN55@I386_sys_t:

; 570  :     I386_gate_set(idt +10,SELECTOR_KERNEL_CODE,I386_fault_tss,
; 571  :         3,0,GATE_TYPE_TRAP_32);

  001f9	33 f6		 xor	 esi, esi
  001fb	81 fe 50 00 00
	00		 cmp	 esi, OFFSET _idt+80
  00201	74 2d		 je	 SHORT $LN61@I386_sys_t
  00203	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_tss
  00208	66 89 35 50 00
	00 00		 mov	 WORD PTR _idt+80, si
  0020f	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_tss
  00214	c1 ee 10	 shr	 esi, 16			; 00000010H
  00217	66 89 35 56 00
	00 00		 mov	 WORD PTR _idt+86, si
  0021e	66 89 15 52 00
	00 00		 mov	 WORD PTR _idt+82, dx
  00225	88 0d 54 00 00
	00		 mov	 BYTE PTR _idt+84, cl
  0022b	a2 55 00 00 00	 mov	 BYTE PTR _idt+85, al
$LN61@I386_sys_t:

; 572  :     I386_gate_set(idt +11,SELECTOR_KERNEL_CODE,I386_fault_segment,
; 573  :         3,0,GATE_TYPE_TRAP_32);

  00230	33 f6		 xor	 esi, esi
  00232	81 fe 58 00 00
	00		 cmp	 esi, OFFSET _idt+88
  00238	74 2d		 je	 SHORT $LN67@I386_sys_t
  0023a	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_segment
  0023f	66 89 35 58 00
	00 00		 mov	 WORD PTR _idt+88, si
  00246	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_segment
  0024b	c1 ee 10	 shr	 esi, 16			; 00000010H
  0024e	66 89 35 5e 00
	00 00		 mov	 WORD PTR _idt+94, si
  00255	66 89 15 5a 00
	00 00		 mov	 WORD PTR _idt+90, dx
  0025c	88 0d 5c 00 00
	00		 mov	 BYTE PTR _idt+92, cl
  00262	a2 5d 00 00 00	 mov	 BYTE PTR _idt+93, al
$LN67@I386_sys_t:

; 574  :     I386_gate_set(idt +12,SELECTOR_KERNEL_CODE,I386_fault_stack,
; 575  :         3,0,GATE_TYPE_TRAP_32);

  00267	33 f6		 xor	 esi, esi
  00269	81 fe 60 00 00
	00		 cmp	 esi, OFFSET _idt+96
  0026f	74 2d		 je	 SHORT $LN79@I386_sys_t

; 576  :     I386_gate_set(idt +12,SELECTOR_KERNEL_CODE,I386_fault_general,
; 577  :         3,0,GATE_TYPE_TRAP_32);

  00271	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_general
  00276	66 89 35 60 00
	00 00		 mov	 WORD PTR _idt+96, si
  0027d	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_general
  00282	c1 ee 10	 shr	 esi, 16			; 00000010H
  00285	66 89 35 66 00
	00 00		 mov	 WORD PTR _idt+102, si
  0028c	66 89 15 62 00
	00 00		 mov	 WORD PTR _idt+98, dx
  00293	88 0d 64 00 00
	00		 mov	 BYTE PTR _idt+100, cl
  00299	a2 65 00 00 00	 mov	 BYTE PTR _idt+101, al
$LN79@I386_sys_t:

; 578  :     I386_gate_set(idt +14,SELECTOR_KERNEL_CODE,I386_fault_page,
; 579  :         3,0,GATE_TYPE_TRAP_32);

  0029e	33 f6		 xor	 esi, esi
  002a0	81 fe 70 00 00
	00		 cmp	 esi, OFFSET _idt+112
  002a6	74 2d		 je	 SHORT $LN85@I386_sys_t
  002a8	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_page
  002ad	66 89 35 70 00
	00 00		 mov	 WORD PTR _idt+112, si
  002b4	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_page
  002b9	c1 ee 10	 shr	 esi, 16			; 00000010H
  002bc	66 89 35 76 00
	00 00		 mov	 WORD PTR _idt+118, si
  002c3	66 89 15 72 00
	00 00		 mov	 WORD PTR _idt+114, dx
  002ca	88 0d 74 00 00
	00		 mov	 BYTE PTR _idt+116, cl
  002d0	a2 75 00 00 00	 mov	 BYTE PTR _idt+117, al
$LN85@I386_sys_t:

; 580  :     I386_gate_set(idt +15,SELECTOR_KERNEL_CODE,I386_fault_fpu,
; 581  :         3,0,GATE_TYPE_TRAP_32);

  002d5	33 f6		 xor	 esi, esi
  002d7	81 fe 78 00 00
	00		 cmp	 esi, OFFSET _idt+120
  002dd	74 2d		 je	 SHORT $LN91@I386_sys_t
  002df	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_fpu
  002e4	66 89 35 78 00
	00 00		 mov	 WORD PTR _idt+120, si
  002eb	be 00 00 00 00	 mov	 esi, OFFSET _I386_fault_fpu
  002f0	c1 ee 10	 shr	 esi, 16			; 00000010H
  002f3	66 89 35 7e 00
	00 00		 mov	 WORD PTR _idt+126, si
  002fa	66 89 15 7a 00
	00 00		 mov	 WORD PTR _idt+122, dx
  00301	88 0d 7c 00 00
	00		 mov	 BYTE PTR _idt+124, cl
  00307	a2 7d 00 00 00	 mov	 BYTE PTR _idt+125, al
$LN91@I386_sys_t:
  0030c	5e		 pop	 esi

; 582  : 
; 583  : }

  0030d	c3		 ret	 0
_I386_sys_trap_initial ENDP
_TEXT	ENDS
PUBLIC	??_C@_03JLOMOCCD@OK?6?$AA@			; `string'
PUBLIC	??_C@_0BH@FALGLGML@CPU?5pm32?5initial?4?4?4?5?5?5?$AA@ ; `string'
PUBLIC	_Cpu_initial
;	COMDAT ??_C@_03JLOMOCCD@OK?6?$AA@
CONST	SEGMENT
??_C@_03JLOMOCCD@OK?6?$AA@ DB 'OK', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FALGLGML@CPU?5pm32?5initial?4?4?4?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BH@FALGLGML@CPU?5pm32?5initial?4?4?4?5?5?5?$AA@ DB 'CPU pm32 initi'
	DB	'al...   ', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Cpu_initial
_TEXT	SEGMENT
_pd$1732 = -8						; size = 6
_pd$1749 = -8						; size = 6
_Cpu_initial PROC					; COMDAT

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 602  :     /*
; 603  :      *    重新初始化gdt寄存器。虽然引导程序已经初始化了gdt，但其所填写的地址是
; 604  :      *  引导程序提供的地址。如果以后的程序需要使用到gdt，就可能造成错误，因此必
; 605  :      *  须更换为内核的gdt，更换GDT后，需要刷新所有的段选择符
; 606  :      */
; 607  :     _printk("CPU pm32 initial...   ");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@FALGLGML@CPU?5pm32?5initial?4?4?4?5?5?5?$AA@
  0000b	e8 00 00 00 00	 call	 __printk
  00010	83 c4 04	 add	 esp, 4

; 608  :     I386_load_gdt(GDT_MAX * sizeof(msd_t) - 1,(uint_t)&gdt);

  00013	66 c7 45 f8 7f
	00		 mov	 WORD PTR _pd$1732[ebp], 127 ; 0000007fH
  00019	c7 45 fa 00 00
	00 00		 mov	 DWORD PTR _pd$1732[ebp+2], OFFSET _gdt
  00020	0f 01 55 f8	 lgdt	 FWORD PTR _pd$1732[ebp]

; 609  :     I386_LOAD_DS(SELECTOR_KERNEL_DATA);

  00024	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00029	66 8e d8	 mov	 ds, ax

; 610  :     I386_LOAD_ES(SELECTOR_KERNEL_DATA);

  0002c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00031	66 8e c0	 mov	 es, ax

; 611  :     I386_LOAD_FS(SELECTOR_KERNEL_DATA);

  00034	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00039	66 8e e0	 mov	 fs, ax

; 612  :     I386_LOAD_GS(SELECTOR_KERNEL_DATA);

  0003c	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00041	66 8e e8	 mov	 gs, ax

; 613  :     I386_LOAD_SS(SELECTOR_KERNEL_DATA);

  00044	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00049	66 8e d0	 mov	 ss, ax

; 614  :     /*  刷新代码段选择符和标志寄存器  */
; 615  :     I386_REFRESH_CS(I386_EFLAGS_NONE,SELECTOR_KERNEL_CODE);

  0004c	6a 00		 push	 0
  0004e	6a 08		 push	 8
  00050	e8 00 00 00 00	 call	 _I386_refresh_cs

; 616  :     /*  装载局部选择符，因为没有使用，所以实际上装在了一个无效的选择符    */
; 617  :     I386_load_ldt(0);

  00055	6a 00		 push	 0
  00057	e8 00 00 00 00	 call	 _I386_load_ldt

; 618  :     /*  装载TSS段描述符，涉及特权级变化时需要使用  */
; 619  :     I386_ssd_set(gdt + 5,&tss,sizeof(tss_t),MSD_DPL_RING0,SSD_TYPE_TSS_32,0);

  0005c	33 c0		 xor	 eax, eax
  0005e	83 c4 04	 add	 esp, 4
  00061	3d 28 00 00 00	 cmp	 eax, OFFSET _gdt+40
  00066	74 3d		 je	 SHORT $LN23@Cpu_initia
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET _tss
  0006d	8b c1		 mov	 eax, ecx
  0006f	c1 e8 18	 shr	 eax, 24			; 00000018H
  00072	a2 2f 00 00 00	 mov	 BYTE PTR _gdt+47, al
  00077	a0 2e 00 00 00	 mov	 al, BYTE PTR _gdt+46
  0007c	8b d1		 mov	 edx, ecx
  0007e	c1 ea 10	 shr	 edx, 16			; 00000010H
  00081	24 f0		 and	 al, 240			; 000000f0H
  00083	c6 05 2d 00 00
	00 89		 mov	 BYTE PTR _gdt+45, 137	; 00000089H
  0008a	66 89 0d 2a 00
	00 00		 mov	 WORD PTR _gdt+42, cx
  00091	88 15 2c 00 00
	00		 mov	 BYTE PTR _gdt+44, dl
  00097	a2 2e 00 00 00	 mov	 BYTE PTR _gdt+46, al
  0009c	66 c7 05 28 00
	00 00 68 01	 mov	 WORD PTR _gdt+40, 360	; 00000168H
$LN23@Cpu_initia:

; 620  :     I386_load_tr(SELECTOR_TSS);

  000a5	6a 28		 push	 40			; 00000028H
  000a7	e8 00 00 00 00	 call	 _I386_load_tr
  000ac	83 c4 04	 add	 esp, 4

; 621  :     /*  装载IDT  */
; 622  :     I386_load_idt(IDT_MAX * sizeof(gate_t) - 1,(uint_t)&idt);   

  000af	66 c7 45 f8 ff
	07		 mov	 WORD PTR _pd$1749[ebp], 2047 ; 000007ffH
  000b5	c7 45 fa 00 00
	00 00		 mov	 DWORD PTR _pd$1749[ebp+2], OFFSET _idt
  000bc	0f 01 5d f8	 lidt	 FWORD PTR _pd$1749[ebp]

; 623  :     /*  初始化系统陷阱  */
; 624  :     I386_sys_trap_initial();

  000c0	e8 00 00 00 00	 call	 _I386_sys_trap_initial

; 625  :     _printk("OK\n");

  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_03JLOMOCCD@OK?6?$AA@
  000ca	e8 00 00 00 00	 call	 __printk
  000cf	83 c4 04	 add	 esp, 4

; 626  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_Cpu_initial ENDP
_TEXT	ENDS
END
