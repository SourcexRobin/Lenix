; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\demo\kernel32\fs_test.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG2524	DB	'/shemox/system/kerncfg.xml', 00H
	ORG $+1
$SG2526	DB	'file system test...', 0aH, 00H
	ORG $+3
$SG2528	DB	'%s open failed!', 0aH, 00H
	ORG $+3
$SG2529	DB	'%s open OK!', 0aH, 00H
	ORG $+3
$SG2531	DB	'file read: %s', 0aH, 00H
	ORG $+1
$SG2533	DB	'file read failed!', 0aH, 00H
	ORG $+1
$SG2540	DB	'/open.txt', 00H
	ORG $+2
$SG2542	DB	'file system create file test...', 0aH, 00H
	ORG $+3
$SG2544	DB	'%s open failed!', 0aH, 00H
	ORG $+3
$SG2545	DB	'%s open OK!', 0aH, 00H
	ORG $+3
$SG2551	DB	'ata', 00H
$SG2552	DB	'ata register failed!', 0aH, 00H
	ORG $+2
$SG2557	DB	'fst', 00H
_DATA	ENDS
PUBLIC	_Time_to_stime
; Function compile flags: /Odtp
; File e:\sourcexstudio\lenix\lenix\demo\kernel32\fs_test.c
_TEXT	SEGMENT
_stime$ = -4						; size = 2
_time$ = 8						; size = 4
_Time_to_stime PROC

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 29   :     stime_t         stime;
; 30   : 
; 31   :     stime.st_hour   = time->time_hour;

  00004	8b 45 08	 mov	 eax, DWORD PTR _time$[ebp]
  00007	66 0f b6 08	 movzx	 cx, BYTE PTR [eax]
  0000b	66 83 e1 1f	 and	 cx, 31			; 0000001fH
  0000f	66 c1 e1 0b	 shl	 cx, 11			; 0000000bH
  00013	66 8b 55 fc	 mov	 dx, WORD PTR _stime$[ebp]
  00017	66 81 e2 ff 07	 and	 dx, 2047		; 000007ffH
  0001c	66 0b d1	 or	 dx, cx
  0001f	66 89 55 fc	 mov	 WORD PTR _stime$[ebp], dx

; 32   :     stime.st_minute = time->time_minute;

  00023	8b 45 08	 mov	 eax, DWORD PTR _time$[ebp]
  00026	66 0f b6 48 01	 movzx	 cx, BYTE PTR [eax+1]
  0002b	66 83 e1 3f	 and	 cx, 63			; 0000003fH
  0002f	66 c1 e1 05	 shl	 cx, 5
  00033	66 8b 55 fc	 mov	 dx, WORD PTR _stime$[ebp]
  00037	66 81 e2 1f f8	 and	 dx, 63519		; 0000f81fH
  0003c	66 0b d1	 or	 dx, cx
  0003f	66 89 55 fc	 mov	 WORD PTR _stime$[ebp], dx

; 33   :     stime.st_hour   = time->time_hour;

  00043	8b 45 08	 mov	 eax, DWORD PTR _time$[ebp]
  00046	66 0f b6 08	 movzx	 cx, BYTE PTR [eax]
  0004a	66 83 e1 1f	 and	 cx, 31			; 0000001fH
  0004e	66 c1 e1 0b	 shl	 cx, 11			; 0000000bH
  00052	66 8b 55 fc	 mov	 dx, WORD PTR _stime$[ebp]
  00056	66 81 e2 ff 07	 and	 dx, 2047		; 000007ffH
  0005b	66 0b d1	 or	 dx, cx
  0005e	66 89 55 fc	 mov	 WORD PTR _stime$[ebp], dx

; 34   : 
; 35   :     return stime;

  00062	66 8b 45 fc	 mov	 ax, WORD PTR _stime$[ebp]

; 36   : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_Time_to_stime ENDP
_TEXT	ENDS
PUBLIC	_Date_to_sdate
; Function compile flags: /Odtp
_TEXT	SEGMENT
_sdate$ = -4						; size = 2
_date$ = 8						; size = 4
_Date_to_sdate PROC

; 39   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp
  00073	51		 push	 ecx

; 40   :     sdate_t         sdate;
; 41   : 
; 42   :     sdate.sd_year   = date->date_year - 1980;

  00074	8b 45 08	 mov	 eax, DWORD PTR _date$[ebp]
  00077	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0007a	81 e9 bc 07 00
	00		 sub	 ecx, 1980		; 000007bcH
  00080	66 83 e1 7f	 and	 cx, 127			; 0000007fH
  00084	66 c1 e1 09	 shl	 cx, 9
  00088	66 8b 55 fc	 mov	 dx, WORD PTR _sdate$[ebp]
  0008c	66 81 e2 ff 01	 and	 dx, 511			; 000001ffH
  00091	66 0b d1	 or	 dx, cx
  00094	66 89 55 fc	 mov	 WORD PTR _sdate$[ebp], dx

; 43   :     sdate.sd_month  = date->date_month;

  00098	8b 45 08	 mov	 eax, DWORD PTR _date$[ebp]
  0009b	66 0f b6 48 02	 movzx	 cx, BYTE PTR [eax+2]
  000a0	66 83 e1 0f	 and	 cx, 15			; 0000000fH
  000a4	66 c1 e1 05	 shl	 cx, 5
  000a8	66 8b 55 fc	 mov	 dx, WORD PTR _sdate$[ebp]
  000ac	66 81 e2 1f fe	 and	 dx, 65055		; 0000fe1fH
  000b1	66 0b d1	 or	 dx, cx
  000b4	66 89 55 fc	 mov	 WORD PTR _sdate$[ebp], dx

; 44   :     sdate.sd_day    = date->date_day;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _date$[ebp]
  000bb	66 0f b6 48 03	 movzx	 cx, BYTE PTR [eax+3]
  000c0	66 83 e1 1f	 and	 cx, 31			; 0000001fH
  000c4	66 8b 55 fc	 mov	 dx, WORD PTR _sdate$[ebp]
  000c8	66 81 e2 e0 ff	 and	 dx, 65504		; 0000ffe0H
  000cd	66 0b d1	 or	 dx, cx
  000d0	66 89 55 fc	 mov	 WORD PTR _sdate$[ebp], dx

; 45   : 
; 46   :     return sdate;

  000d4	66 8b 45 fc	 mov	 ax, WORD PTR _sdate$[ebp]

; 47   : }

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
_Date_to_sdate ENDP
_TEXT	ENDS
PUBLIC	_Fs_test
EXTRN	_Fs_read:PROC
EXTRN	_Fs_open:PROC
EXTRN	__printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_buf$ = -120						; size = 100
_name$ = -12						; size = 4
_nr$ = -8						; size = 4
_file$ = -4						; size = 4
_param$ = 8						; size = 4
_Fs_test PROC

; 54   : {

  000e0	55		 push	 ebp
  000e1	8b ec		 mov	 ebp, esp
  000e3	83 ec 78	 sub	 esp, 120		; 00000078H

; 55   :     handle_t        file;
; 56   :     char            buf[100];
; 57   :     char          * name = "/shemox/system/kerncfg.xml";

  000e6	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _name$[ebp], OFFSET $SG2524

; 58   :     int             nr;
; 59   :     _printf("file system test...\n");

  000ed	68 00 00 00 00	 push	 OFFSET $SG2526
  000f2	e8 00 00 00 00	 call	 __printf
  000f7	83 c4 04	 add	 esp, 4

; 60   :     file = Fs_open(name,FS_OPEN_FLAG_READ);

  000fa	6a 02		 push	 2
  000fc	8b 45 f4	 mov	 eax, DWORD PTR _name$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _Fs_open
  00105	83 c4 08	 add	 esp, 8
  00108	89 45 fc	 mov	 DWORD PTR _file$[ebp], eax

; 61   :     if( INVALID_HANDLE == file)

  0010b	83 7d fc 00	 cmp	 DWORD PTR _file$[ebp], 0
  0010f	75 13		 jne	 SHORT $LN3@Fs_test

; 62   :     {
; 63   :         _printf("%s open failed!\n",name);

  00111	8b 4d f4	 mov	 ecx, DWORD PTR _name$[ebp]
  00114	51		 push	 ecx
  00115	68 00 00 00 00	 push	 OFFSET $SG2528
  0011a	e8 00 00 00 00	 call	 __printf
  0011f	83 c4 08	 add	 esp, 8

; 64   :         return ;

  00122	eb 54		 jmp	 SHORT $LN4@Fs_test
$LN3@Fs_test:

; 65   :     }
; 66   :     _printf("%s open OK!\n",name);

  00124	8b 55 f4	 mov	 edx, DWORD PTR _name$[ebp]
  00127	52		 push	 edx
  00128	68 00 00 00 00	 push	 OFFSET $SG2529
  0012d	e8 00 00 00 00	 call	 __printf
  00132	83 c4 08	 add	 esp, 8

; 67   :     if( (nr = Fs_read(file,buf,100) ) >= 0 )

  00135	6a 64		 push	 100			; 00000064H
  00137	8d 45 88	 lea	 eax, DWORD PTR _buf$[ebp]
  0013a	50		 push	 eax
  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _file$[ebp]
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 _Fs_read
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
  00147	89 45 f8	 mov	 DWORD PTR _nr$[ebp], eax
  0014a	83 7d f8 00	 cmp	 DWORD PTR _nr$[ebp], 0
  0014e	7c 1b		 jl	 SHORT $LN2@Fs_test

; 68   :     {
; 69   :         buf[nr] = 0;

  00150	8b 55 f8	 mov	 edx, DWORD PTR _nr$[ebp]
  00153	c6 44 15 88 00	 mov	 BYTE PTR _buf$[ebp+edx], 0

; 70   :         _printf("file read: %s\n",buf);

  00158	8d 45 88	 lea	 eax, DWORD PTR _buf$[ebp]
  0015b	50		 push	 eax
  0015c	68 00 00 00 00	 push	 OFFSET $SG2531
  00161	e8 00 00 00 00	 call	 __printf
  00166	83 c4 08	 add	 esp, 8

; 71   :         //_mprintf(buf,100);
; 72   :         
; 73   :     }
; 74   :     else

  00169	eb 0d		 jmp	 SHORT $LN4@Fs_test
$LN2@Fs_test:

; 75   :     {
; 76   :         _printf("file read failed!\n");

  0016b	68 00 00 00 00	 push	 OFFSET $SG2533
  00170	e8 00 00 00 00	 call	 __printf
  00175	83 c4 04	 add	 esp, 4
$LN4@Fs_test:

; 77   :     }
; 78   : }

  00178	8b e5		 mov	 esp, ebp
  0017a	5d		 pop	 ebp
  0017b	c3		 ret	 0
_Fs_test ENDP
_TEXT	ENDS
PUBLIC	_Fs_create_test
; Function compile flags: /Odtp
_TEXT	SEGMENT
_name$ = -12						; size = 4
_nr$ = -8						; size = 4
_file$ = -4						; size = 4
_param$ = 8						; size = 4
_Fs_create_test PROC

; 82   : {

  00180	55		 push	 ebp
  00181	8b ec		 mov	 ebp, esp
  00183	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 83   :     /*  创建一个新文件*/
; 84   :     handle_t        file    = INVALID_HANDLE;

  00186	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _file$[ebp], 0

; 85   :     char          * name    = "/open.txt";

  0018d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _name$[ebp], OFFSET $SG2540

; 86   :     int             nr      = 0;

  00194	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nr$[ebp], 0

; 87   : 
; 88   :     _printf("file system create file test...\n");

  0019b	68 00 00 00 00	 push	 OFFSET $SG2542
  001a0	e8 00 00 00 00	 call	 __printf
  001a5	83 c4 04	 add	 esp, 4

; 89   :     file = Fs_open(name,FS_OPEN_FLAG_READ | FS_OPEN_FLAG_WRITE);

  001a8	6a 06		 push	 6
  001aa	8b 45 f4	 mov	 eax, DWORD PTR _name$[ebp]
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 _Fs_open
  001b3	83 c4 08	 add	 esp, 8
  001b6	89 45 fc	 mov	 DWORD PTR _file$[ebp], eax

; 90   :     if( INVALID_HANDLE == file)

  001b9	83 7d fc 00	 cmp	 DWORD PTR _file$[ebp], 0
  001bd	75 13		 jne	 SHORT $LN1@Fs_create_

; 91   :     {
; 92   :         _printf("%s open failed!\n",name);

  001bf	8b 4d f4	 mov	 ecx, DWORD PTR _name$[ebp]
  001c2	51		 push	 ecx
  001c3	68 00 00 00 00	 push	 OFFSET $SG2544
  001c8	e8 00 00 00 00	 call	 __printf
  001cd	83 c4 08	 add	 esp, 8

; 93   :         return ;

  001d0	eb 11		 jmp	 SHORT $LN2@Fs_create_
$LN1@Fs_create_:

; 94   :     }
; 95   :     _printf("%s open OK!\n",name);

  001d2	8b 55 f4	 mov	 edx, DWORD PTR _name$[ebp]
  001d5	52		 push	 edx
  001d6	68 00 00 00 00	 push	 OFFSET $SG2545
  001db	e8 00 00 00 00	 call	 __printf
  001e0	83 c4 08	 add	 esp, 8
$LN2@Fs_create_:

; 96   : }

  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
_Fs_create_test ENDP
_TEXT	ENDS
PUBLIC	_User_initial
EXTRN	_Proc_create:PROC
EXTRN	_Fs_initial:PROC
EXTRN	_Dev_registe:PROC
EXTRN	_Ata_entry:PROC
EXTRN	_Bbuf_initial:PROC
EXTRN	_Shell_cmd_initial:PROC
EXTRN	_Tty_echo_hook_set:PROC
EXTRN	_Con_print_char:PROC
_BSS	SEGMENT
___lenix_proc_stack_fst DB 0800H DUP (?)
; Function compile flags: /Odtp
_BSS	ENDS
_TEXT	SEGMENT
_hd$ = -4						; size = 4
_User_initial PROC

; 99   : {

  001f0	55		 push	 ebp
  001f1	8b ec		 mov	 ebp, esp
  001f3	51		 push	 ecx

; 100  :     int         hd = 0;

  001f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hd$[ebp], 0

; 101  : 
; 102  :     Tty_echo_hook_set(TTY_MAJOR,Con_print_char);

  001fb	68 00 00 00 00	 push	 OFFSET _Con_print_char
  00200	6a 00		 push	 0
  00202	e8 00 00 00 00	 call	 _Tty_echo_hook_set
  00207	83 c4 08	 add	 esp, 8

; 103  : 
; 104  :     //Clk_ticks_hook_set(Clk_msg);
; 105  : 
; 106  :     Shell_cmd_initial();

  0020a	e8 00 00 00 00	 call	 _Shell_cmd_initial

; 107  : 
; 108  :     Bbuf_initial();

  0020f	e8 00 00 00 00	 call	 _Bbuf_initial

; 109  : 
; 110  : 
; 111  :     if( Dev_registe("ata",Ata_entry,&hd) != RESULT_SUCCEED )

  00214	8d 45 fc	 lea	 eax, DWORD PTR _hd$[ebp]
  00217	50		 push	 eax
  00218	68 00 00 00 00	 push	 OFFSET _Ata_entry
  0021d	68 00 00 00 00	 push	 OFFSET $SG2551
  00222	e8 00 00 00 00	 call	 _Dev_registe
  00227	83 c4 0c	 add	 esp, 12			; 0000000cH
  0022a	85 c0		 test	 eax, eax
  0022c	74 0d		 je	 SHORT $LN1@User_initi

; 112  :         _printf("ata register failed!\n");

  0022e	68 00 00 00 00	 push	 OFFSET $SG2552
  00233	e8 00 00 00 00	 call	 __printf
  00238	83 c4 04	 add	 esp, 4
$LN1@User_initi:

; 113  : 
; 114  :     Fs_initial();

  0023b	e8 00 00 00 00	 call	 _Fs_initial

; 115  : 
; 116  :     PROC_CREATE(fst,60,3,Fs_create_test,NULL);

  00240	68 00 08 00 00	 push	 2048			; 00000800H
  00245	b9 00 08 00 00	 mov	 ecx, OFFSET ___lenix_proc_stack_fst+2048
  0024a	83 e1 fc	 and	 ecx, -4			; fffffffcH
  0024d	51		 push	 ecx
  0024e	6a 00		 push	 0
  00250	68 00 00 00 00	 push	 OFFSET _Fs_create_test
  00255	6a 03		 push	 3
  00257	6a 3c		 push	 60			; 0000003cH
  00259	68 00 00 00 00	 push	 OFFSET $SG2557
  0025e	e8 00 00 00 00	 call	 _Proc_create
  00263	83 c4 1c	 add	 esp, 28			; 0000001cH

; 117  : }

  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
_User_initial ENDP
_TEXT	ENDS
PUBLIC	_main
; Function compile flags: /Odtp
_TEXT	SEGMENT
_main	PROC

; 120  : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp

; 121  :     User_initial();

  00273	e8 00 00 00 00	 call	 _User_initial

; 122  : 
; 123  : }

  00278	33 c0		 xor	 eax, eax
  0027a	5d		 pop	 ebp
  0027b	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END
