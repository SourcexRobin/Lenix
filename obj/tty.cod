; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\tty.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\kernel\tty.c
;	COMDAT _Tty_echo_hook_default
_TEXT	SEGMENT
_c$ = 8							; size = 1
_Tty_echo_hook_default PROC				; COMDAT

; 49   :     c = c;
; 50   : }

  00000	c3		 ret	 0
_Tty_echo_hook_default ENDP
_TEXT	ENDS
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Cpu_disable_interrupt:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Tty_copy_to_cook
_TEXT	SEGMENT
_Tty_copy_to_cook PROC					; COMDAT
; _tty$ = esi

; 58   : {

  00000	57		 push	 edi

; 59   :     byte_t                  c       = 0;
; 60   :     CRITICAL_DECLARE(tty->tty_lock);
; 61   : 
; 62   :     CRITICAL_BEGIN();

  00001	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00006	8b f8		 mov	 edi, eax
  00008	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL23@Tty_copy_t:

; 73   :                 continue;

  00010	0f b6 96 a4 00
	00 00		 movzx	 edx, BYTE PTR [esi+164]
  00017	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL22@Tty_copy_t:

; 63   : 
; 64   :     /*  输入缓冲区有数据才能对其进行加工  */
; 65   :     while( !TQ_IS_EMPTY(tty->tty_read_queue)  )

  00020	8a 8e a5 00 00
	00		 mov	 cl, BYTE PTR [esi+165]
  00026	0f b6 c1	 movzx	 eax, cl
  00029	83 c0 01	 add	 eax, 1
  0002c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0002f	3b c2		 cmp	 eax, edx
  00031	74 64		 je	 SHORT $LN21@Tty_copy_t

; 66   :     {
; 67   :         TQ_GET_CHAR(tty->tty_read_queue,c);

  00033	80 c1 01	 add	 cl, 1
  00036	80 e1 7f	 and	 cl, 127			; 0000007fH
  00039	88 8e a5 00 00
	00		 mov	 BYTE PTR [esi+165], cl
  0003f	0f b6 c9	 movzx	 ecx, cl
  00042	8a 4c 31 24	 mov	 cl, BYTE PTR [ecx+esi+36]

; 68   : 
; 69   :         switch(c)

  00046	80 f9 08	 cmp	 cl, 8
  00049	75 29		 jne	 SHORT $LN6@Tty_copy_t

; 70   :         {
; 71   :         case CHAR_BACK:
; 72   :             if( TQ_IS_EMPTY(tty->tty_second_queue) )

  0004b	0f b6 86 a9 01
	00 00		 movzx	 eax, BYTE PTR [esi+425]
  00052	83 c0 01	 add	 eax, 1
  00055	83 e0 7f	 and	 eax, 127		; 0000007fH
  00058	3a 86 a8 01 00
	00		 cmp	 al, BYTE PTR [esi+424]
  0005e	74 c0		 je	 SHORT $LL22@Tty_copy_t

; 74   :             TQ_DEC(tty->tty_second_queue.tq_head);

  00060	8a 8e a8 01 00
	00		 mov	 cl, BYTE PTR [esi+424]
  00066	80 e9 01	 sub	 cl, 1
  00069	80 e1 7f	 and	 cl, 127			; 0000007fH
  0006c	88 8e a8 01 00
	00		 mov	 BYTE PTR [esi+424], cl

; 79   :         }
; 80   :     }

  00072	eb 9c		 jmp	 SHORT $LL23@Tty_copy_t
$LN6@Tty_copy_t:

; 75   :             break;
; 76   :         default:
; 77   :             TQ_PUT_CHAR(tty->tty_second_queue,c);

  00074	0f b6 96 a8 01
	00 00		 movzx	 edx, BYTE PTR [esi+424]
  0007b	88 8c 32 28 01
	00 00		 mov	 BYTE PTR [edx+esi+296], cl
  00082	8a 86 a8 01 00
	00		 mov	 al, BYTE PTR [esi+424]
  00088	04 01		 add	 al, 1
  0008a	24 7f		 and	 al, 127			; 0000007fH
  0008c	88 86 a8 01 00
	00		 mov	 BYTE PTR [esi+424], al

; 78   :             break;

  00092	e9 79 ff ff ff	 jmp	 $LL23@Tty_copy_t
$LN21@Tty_copy_t:

; 81   : 
; 82   :     CRITICAL_END();

  00097	57		 push	 edi
  00098	e8 00 00 00 00	 call	 _Cpu_psw_set
  0009d	83 c4 04	 add	 esp, 4
  000a0	5f		 pop	 edi

; 83   : }

  000a1	c3		 ret	 0
_Tty_copy_to_cook ENDP
_TEXT	ENDS
PUBLIC	_Tty_echo_hook_set
_BSS	SEGMENT
_tty_pool DB	0354H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Tty_echo_hook_set
_TEXT	SEGMENT
_ttyid$ = 8						; size = 4
_echo$ = 12						; size = 4
_Tty_echo_hook_set PROC					; COMDAT

; 88   :     tty_t               *   tty         = tty_pool + ttyid;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ttyid$[esp-4]
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax
  00007	69 f6 aa 01 00
	00		 imul	 esi, 426		; 000001aaH
  0000d	81 c6 00 00 00
	00		 add	 esi, OFFSET _tty_pool

; 89   :     void                *   handle      = NULL;
; 90   :     CRITICAL_DECLARE(tty->tty_lock);
; 91   : 
; 92   : #ifdef _CFG_CHECK_PARAMETER_
; 93   :     if( ttyid >= TTY_MAX )  return NULL;

  00013	83 f8 02	 cmp	 eax, 2
  00016	7c 04		 jl	 SHORT $LN5@Tty_echo_h
  00018	33 c0		 xor	 eax, eax
  0001a	5e		 pop	 esi

; 103  : }

  0001b	c3		 ret	 0
$LN5@Tty_echo_h:
  0001c	53		 push	 ebx

; 94   :     if( NULL == echo )      return NULL;

  0001d	8b 5c 24 10	 mov	 ebx, DWORD PTR _echo$[esp+4]
  00021	85 db		 test	 ebx, ebx
  00023	75 05		 jne	 SHORT $LN3@Tty_echo_h
  00025	5b		 pop	 ebx
  00026	33 c0		 xor	 eax, eax
  00028	5e		 pop	 esi

; 103  : }

  00029	c3		 ret	 0
$LN3@Tty_echo_h:
  0002a	57		 push	 edi

; 95   : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 96   : 
; 97   :     CRITICAL_BEGIN();

  0002b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 98   :     handle = tty->tty_echo_hook;

  00030	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]

; 99   :     tty->tty_echo_hook = echo;
; 100  :     CRITICAL_END();

  00033	50		 push	 eax
  00034	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00037	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003c	83 c4 04	 add	 esp, 4

; 101  : 
; 102  :     return handle;

  0003f	8b c7		 mov	 eax, edi
  00041	5f		 pop	 edi
  00042	5b		 pop	 ebx
  00043	5e		 pop	 esi

; 103  : }

  00044	c3		 ret	 0
_Tty_echo_hook_set ENDP
_TEXT	ENDS
PUBLIC	_Tty_put_char
EXTRN	_Proc_resume_on:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Tty_put_char
_TEXT	SEGMENT
_ttyid$ = 8						; size = 4
_c$ = 12						; size = 1
_Tty_put_char PROC					; COMDAT

; 134  :     tty_t               *   tty     = tty_pool + ttyid;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ttyid$[esp-4]
  00004	56		 push	 esi
  00005	8b f0		 mov	 esi, eax
  00007	69 f6 aa 01 00
	00		 imul	 esi, 426		; 000001aaH
  0000d	81 c6 00 00 00
	00		 add	 esi, OFFSET _tty_pool

; 135  :     result_t                result  = RESULT_SUCCEED;
; 136  :     CRITICAL_DECLARE(tty->tty_lock );
; 137  : 
; 138  :     if( ttyid >= TTY_MAX )

  00013	83 f8 02	 cmp	 eax, 2
  00016	7c 04		 jl	 SHORT $LN46@Tty_put_ch

; 139  :         return result;

  00018	33 c0		 xor	 eax, eax
  0001a	5e		 pop	 esi

; 201  : }

  0001b	c3		 ret	 0
$LN46@Tty_put_ch:
  0001c	53		 push	 ebx

; 140  : 
; 141  :     CRITICAL_BEGIN();

  0001d	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 142  :     /*
; 143  : 	 *  1、普通tty缓冲区满则丢弃数据，因为并不一定有等待数据的进程
; 144  : 	 *  2、如果是交互终端，则需要留下回车符和退格符的空间  
; 145  : 	 */
; 146  : 	if( TQ_LEFT(tty->tty_second_queue) == 0 ||
; 147  : 		( tty->tty_termios.temo_type == TERMIOS_TYPE_TTY && 
; 148  : 		!( TQ_LEFT(tty->tty_second_queue) > 4 || CHAR_BACK == c || CHAR_CR == c ) ) )

  00022	0f b6 8e a9 01
	00 00		 movzx	 ecx, BYTE PTR [esi+425]
  00029	0f b6 96 a8 01
	00 00		 movzx	 edx, BYTE PTR [esi+424]
  00030	2b ca		 sub	 ecx, edx
  00032	83 e9 01	 sub	 ecx, 1
  00035	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00038	0f 84 eb 00 00
	00		 je	 $LN42@Tty_put_ch
  0003e	83 3e 02	 cmp	 DWORD PTR [esi], 2
  00041	8a 5c 24 10	 mov	 bl, BYTE PTR _c$[esp+4]
  00045	75 13		 jne	 SHORT $LN41@Tty_put_ch
  00047	83 f9 04	 cmp	 ecx, 4
  0004a	7f 0e		 jg	 SHORT $LN41@Tty_put_ch
  0004c	80 fb 08	 cmp	 bl, 8
  0004f	74 09		 je	 SHORT $LN41@Tty_put_ch
  00051	80 fb 0d	 cmp	 bl, 13			; 0000000dH
  00054	0f 85 cf 00 00
	00		 jne	 $LN42@Tty_put_ch
$LN41@Tty_put_ch:

; 152  : 	}
; 153  :     TQ_PUT_CHAR( tty->tty_read_queue,c);

  0005a	0f b6 8e a4 00
	00 00		 movzx	 ecx, BYTE PTR [esi+164]
  00061	88 5c 31 24	 mov	 BYTE PTR [ecx+esi+36], bl
  00065	8a 96 a4 00 00
	00		 mov	 dl, BYTE PTR [esi+164]
  0006b	80 c2 01	 add	 dl, 1
  0006e	80 e2 7f	 and	 dl, 127			; 0000007fH

; 154  :     CRITICAL_END();

  00071	50		 push	 eax
  00072	88 96 a4 00 00
	00		 mov	 BYTE PTR [esi+164], dl
  00078	e8 00 00 00 00	 call	 _Cpu_psw_set
  0007d	83 c4 04	 add	 esp, 4

; 155  :     /*  定义了数据加工标志，则要对数据进行加工。  */
; 156  :     if( tty->tty_termios.temo_iflags & TERMIOS_IFLAG_NEED_COOK )

  00080	f6 46 04 02	 test	 BYTE PTR [esi+4], 2
  00084	74 07		 je	 SHORT $LN33@Tty_put_ch

; 157  :         Tty_copy_to_cook(tty);

  00086	e8 00 00 00 00	 call	 _Tty_copy_to_cook

; 158  :     else

  0008b	eb 30		 jmp	 SHORT $LN28@Tty_put_ch
$LN33@Tty_put_ch:

; 159  :     {
; 160  : 		TQ_INC((tty->tty_read_queue).tq_tail);

  0008d	8a 86 a5 00 00
	00		 mov	 al, BYTE PTR [esi+165]

; 161  : 		TQ_PUT_CHAR(tty->tty_second_queue,c);

  00093	0f b6 8e a8 01
	00 00		 movzx	 ecx, BYTE PTR [esi+424]
  0009a	04 01		 add	 al, 1
  0009c	24 7f		 and	 al, 127			; 0000007fH
  0009e	88 86 a5 00 00
	00		 mov	 BYTE PTR [esi+165], al
  000a4	88 9c 31 28 01
	00 00		 mov	 BYTE PTR [ecx+esi+296], bl
  000ab	8a 96 a8 01 00
	00		 mov	 dl, BYTE PTR [esi+424]
  000b1	80 c2 01	 add	 dl, 1
  000b4	80 e2 7f	 and	 dl, 127			; 0000007fH
  000b7	88 96 a8 01 00
	00		 mov	 BYTE PTR [esi+424], dl
$LN28@Tty_put_ch:

; 162  :     }
; 163  : 
; 164  :     /*  如果终端定义了回显，也就是实时输出，则需要立即输出获得的数据  */
; 165  :     if( tty->tty_termios.temo_oflags & TERMIOS_OFLAG_ECHO )

  000bd	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  000c0	a8 01		 test	 al, 1
  000c2	74 21		 je	 SHORT $LN24@Tty_put_ch

; 166  :     {
; 167  :         /*
; 168  :          *  如果进入密码模式，一般的字符显示改为*号
; 169  :          *  控制字符不改变显示
; 170  :          */
; 171  :         if( tty->tty_termios.temo_oflags & TERMIOS_OFLAG_PSW )

  000c4	a8 02		 test	 al, 2
  000c6	74 10		 je	 SHORT $LN20@Tty_put_ch

; 172  :         {
; 173  :             switch(c)

  000c8	80 fb 08	 cmp	 bl, 8
  000cb	74 0b		 je	 SHORT $LN20@Tty_put_ch
  000cd	80 fb 0d	 cmp	 bl, 13			; 0000000dH
  000d0	74 06		 je	 SHORT $LN20@Tty_put_ch

; 174  :             {
; 175  :             case CHAR_CR:
; 176  :             case CHAR_BACK:
; 177  :                 break;
; 178  :             default:
; 179  :                 c = '*';

  000d2	b3 2a		 mov	 bl, 42			; 0000002aH
  000d4	88 5c 24 10	 mov	 BYTE PTR _c$[esp+4], bl
$LN20@Tty_put_ch:

; 180  :                 break;
; 181  :             }
; 182  :         }
; 183  :         tty->tty_echo_hook(c);

  000d8	8b 44 24 10	 mov	 eax, DWORD PTR _c$[esp+4]
  000dc	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000df	50		 push	 eax
  000e0	ff d1		 call	 ecx
  000e2	83 c4 04	 add	 esp, 4
$LN24@Tty_put_ch:

; 184  :     }
; 185  : 
; 186  : 	switch(tty->tty_termios.temo_type)

  000e5	8b 06		 mov	 eax, DWORD PTR [esi]
  000e7	83 e8 02	 sub	 eax, 2
  000ea	57		 push	 edi
  000eb	74 18		 je	 SHORT $LN16@Tty_put_ch

; 192  : 		break;
; 193  : 	default:
; 194  : 		/*  一般的tty在缓冲区满的时候，需要唤醒等待的进程  */
; 195  : 		if( TQ_LEFT(tty->tty_second_queue) == 0 )

  000ed	0f b6 96 a9 01
	00 00		 movzx	 edx, BYTE PTR [esi+425]
  000f4	0f b6 86 a8 01
	00 00		 movzx	 eax, BYTE PTR [esi+424]
  000fb	2b d0		 sub	 edx, eax
  000fd	83 ea 01	 sub	 edx, 1
  00100	f6 c2 7f	 test	 dl, 127			; 0000007fH

; 196  : 			TTY_WAKEUP(tty);
; 197  : 		break;

  00103	eb 03		 jmp	 SHORT $LN51@Tty_put_ch
$LN16@Tty_put_ch:

; 187  : 	{
; 188  : 	case TERMIOS_TYPE_TTY:
; 189  : 		/*  交互终端对于回车符需要唤醒等待输入的进程 */
; 190  : 		if( CHAR_CR == c )

  00105	80 fb 0d	 cmp	 bl, 13			; 0000000dH
$LN51@Tty_put_ch:
  00108	75 19		 jne	 SHORT $LN12@Tty_put_ch

; 191  : 			TTY_WAKEUP(tty);

  0010a	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  0010f	83 c6 0c	 add	 esi, 12			; 0000000cH
  00112	56		 push	 esi
  00113	8b f8		 mov	 edi, eax
  00115	e8 00 00 00 00	 call	 _Proc_resume_on
  0011a	57		 push	 edi
  0011b	e8 00 00 00 00	 call	 _Cpu_psw_set
  00120	83 c4 08	 add	 esp, 8
$LN12@Tty_put_ch:
  00123	5f		 pop	 edi
  00124	5b		 pop	 ebx

; 198  : 	}
; 199  : 
; 200  :     return RESULT_SUCCEED;

  00125	33 c0		 xor	 eax, eax
  00127	5e		 pop	 esi

; 201  : }

  00128	c3		 ret	 0
$LN42@Tty_put_ch:

; 149  : 	{
; 150  :         CRITICAL_END();

  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _Cpu_psw_set
  0012f	83 c4 04	 add	 esp, 4
  00132	5b		 pop	 ebx

; 151  : 		return RESULT_FAILED;

  00133	83 c8 ff	 or	 eax, -1
  00136	5e		 pop	 esi

; 201  : }

  00137	c3		 ret	 0
_Tty_put_char ENDP
_TEXT	ENDS
PUBLIC	_Tty_read
EXTRN	_Proc_sched:PROC
EXTRN	_Lck_free:PROC
EXTRN	_Proc_wait_on:PROC
EXTRN	_Lck_lock:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Tty_read
_TEXT	SEGMENT
tv164 = 8						; size = 4
_ttyid$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_Tty_read PROC						; COMDAT

; 231  :     tty_t               *   tty     = tty_pool + ttyid;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ttyid$[esp-4]
  00004	55		 push	 ebp

; 232  :     byte_t              *   buf     = buffer;

  00005	8b 6c 24 0c	 mov	 ebp, DWORD PTR _buffer$[esp]
  00009	56		 push	 esi
  0000a	8b f0		 mov	 esi, eax
  0000c	69 f6 aa 01 00
	00		 imul	 esi, 426		; 000001aaH
  00012	81 c6 00 00 00
	00		 add	 esi, OFFSET _tty_pool

; 233  :     byte_t                  c       = 0;
; 234  :     CRITICAL_DECLARE(tty->tty_lock);
; 235  : 
; 236  : #ifdef _CFG_CHECK_PARAMETER_
; 237  :     if( ttyid >= TTY_MAX )	return -1;

  00018	83 f8 02	 cmp	 eax, 2
  0001b	7c 06		 jl	 SHORT $LN16@Tty_read
$LN22@Tty_read:
  0001d	5e		 pop	 esi
  0001e	83 c8 ff	 or	 eax, -1
  00021	5d		 pop	 ebp

; 269  : }

  00022	c3		 ret	 0
$LN16@Tty_read:

; 238  :     if( NULL == buffer )    return -1;

  00023	85 ed		 test	 ebp, ebp
  00025	74 f6		 je	 SHORT $LN22@Tty_read
  00027	53		 push	 ebx

; 239  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 240  : 
; 241  :     /*  终止条件是缓冲区满    */
; 242  :     TTY_LOCK(tty);

  00028	8d 5e 14	 lea	 ebx, DWORD PTR [esi+20]
  0002b	53		 push	 ebx
  0002c	89 5c 24 14	 mov	 DWORD PTR tv164[esp+12], ebx
  00030	e8 00 00 00 00	 call	 _Lck_lock
  00035	83 c4 04	 add	 esp, 4

; 243  :     while( size )

  00038	83 7c 24 18 00	 cmp	 DWORD PTR _size$[esp+8], 0
  0003d	0f 84 a7 00 00
	00		 je	 $LN13@Tty_read
  00043	57		 push	 edi
$LL14@Tty_read:

; 244  :     {
; 245  :         CRITICAL_BEGIN();

  00044	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00049	8b f8		 mov	 edi, eax

; 246  :         if( TQ_IS_EMPTY(tty->tty_second_queue) )

  0004b	8a 86 a9 01 00
	00		 mov	 al, BYTE PTR [esi+425]
  00051	0f b6 c8	 movzx	 ecx, al
  00054	83 c1 01	 add	 ecx, 1
  00057	83 e1 7f	 and	 ecx, 127		; 0000007fH
  0005a	3a 8e a8 01 00
	00		 cmp	 cl, BYTE PTR [esi+424]
  00060	75 27		 jne	 SHORT $LN7@Tty_read

; 247  :         {	/*  缓冲区空需要等待数据  */
; 248  :             Proc_wait_on(&(tty->tty_wait));

  00062	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 _Proc_wait_on

; 249  :             TTY_FREE(tty);  /*  */

  0006b	53		 push	 ebx
  0006c	e8 00 00 00 00	 call	 _Lck_free

; 250  :             CRITICAL_END();

  00071	57		 push	 edi
  00072	e8 00 00 00 00	 call	 _Cpu_psw_set

; 251  :             Proc_sched(0);

  00077	6a 00		 push	 0
  00079	e8 00 00 00 00	 call	 _Proc_sched

; 252  :             TTY_LOCK(tty);

  0007e	53		 push	 ebx
  0007f	e8 00 00 00 00	 call	 _Lck_lock
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 253  :         }
; 254  :         else

  00087	eb 36		 jmp	 SHORT $LN8@Tty_read
$LN7@Tty_read:

; 255  :         {
; 256  :             TQ_GET_CHAR(tty->tty_second_queue,c);

  00089	04 01		 add	 al, 1
  0008b	24 7f		 and	 al, 127			; 0000007fH
  0008d	88 86 a9 01 00
	00		 mov	 BYTE PTR [esi+425], al
  00093	0f b6 c0	 movzx	 eax, al
  00096	8a 9c 30 28 01
	00 00		 mov	 bl, BYTE PTR [eax+esi+296]

; 257  :             CRITICAL_END();

  0009d	57		 push	 edi
  0009e	e8 00 00 00 00	 call	 _Cpu_psw_set

; 258  :             *buf++ = c;

  000a3	88 5d 00	 mov	 BYTE PTR [ebp], bl
  000a6	83 c4 04	 add	 esp, 4
  000a9	83 c5 01	 add	 ebp, 1

; 259  :             if( CHAR_CR == c && ( tty->tty_termios.temo_type & TERMIOS_TYPE_TTY ) )

  000ac	80 fb 0d	 cmp	 bl, 13			; 0000000dH
  000af	75 05		 jne	 SHORT $LN1@Tty_read
  000b1	f6 06 02	 test	 BYTE PTR [esi], 2
  000b4	75 28		 jne	 SHORT $LN20@Tty_read
$LN1@Tty_read:

; 262  :                 break;
; 263  : 			}
; 264  :             --size;

  000b6	83 6c 24 1c 01	 sub	 DWORD PTR _size$[esp+12], 1
  000bb	8b 5c 24 14	 mov	 ebx, DWORD PTR tv164[esp+12]
$LN8@Tty_read:

; 243  :     while( size )

  000bf	83 7c 24 1c 00	 cmp	 DWORD PTR _size$[esp+12], 0
  000c4	0f 85 7a ff ff
	ff		 jne	 $LL14@Tty_read
  000ca	5f		 pop	 edi

; 265  :         }
; 266  :     }
; 267  :     TTY_FREE(tty);

  000cb	53		 push	 ebx
  000cc	e8 00 00 00 00	 call	 _Lck_free
  000d1	83 c4 04	 add	 esp, 4
  000d4	5b		 pop	 ebx

; 268  :     return buf - (byte_t *)buffer;

  000d5	8b c5		 mov	 eax, ebp
  000d7	2b 44 24 10	 sub	 eax, DWORD PTR _buffer$[esp+4]
  000db	5e		 pop	 esi
  000dc	5d		 pop	 ebp

; 269  : }

  000dd	c3		 ret	 0
$LN20@Tty_read:

; 260  : 			{	/*  如果TTY是终端，遇到回车符需要返回。将回车符修改为0  */
; 261  : 				*--buf = 0;

  000de	8b 5c 24 14	 mov	 ebx, DWORD PTR tv164[esp+12]
  000e2	83 ed 01	 sub	 ebp, 1
  000e5	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  000e9	5f		 pop	 edi
$LN13@Tty_read:

; 265  :         }
; 266  :     }
; 267  :     TTY_FREE(tty);

  000ea	53		 push	 ebx
  000eb	e8 00 00 00 00	 call	 _Lck_free
  000f0	83 c4 04	 add	 esp, 4
  000f3	5b		 pop	 ebx

; 268  :     return buf - (byte_t *)buffer;

  000f4	8b c5		 mov	 eax, ebp
  000f6	2b 44 24 10	 sub	 eax, DWORD PTR _buffer$[esp+4]
  000fa	5e		 pop	 esi
  000fb	5d		 pop	 ebp

; 269  : }

  000fc	c3		 ret	 0
_Tty_read ENDP
_TEXT	ENDS
PUBLIC	_Tty_write
; Function compile flags: /Ogtpy
;	COMDAT _Tty_write
_TEXT	SEGMENT
_ttyid$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_Tty_write PROC						; COMDAT

; 277  :     tty_t               *   tty     = tty_pool + ttyid;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ttyid$[esp-4]
  00004	53		 push	 ebx

; 278  :     const byte_t        *   buf     = buffer;

  00005	8b 5c 24 0c	 mov	 ebx, DWORD PTR _buffer$[esp]
  00009	56		 push	 esi
  0000a	8b f0		 mov	 esi, eax
  0000c	69 f6 aa 01 00
	00		 imul	 esi, 426		; 000001aaH
  00012	81 c6 00 00 00
	00		 add	 esi, OFFSET _tty_pool

; 279  :     //CRITICAL_DECLARE(tty->tty_lock);
; 280  : 
; 281  : #ifdef _CFG_CHECK_PARAMETER_
; 282  :     if( ttyid >= TTY_MAX )	return -1;

  00018	83 f8 02	 cmp	 eax, 2
  0001b	7c 06		 jl	 SHORT $LN4@Tty_write
$LN10@Tty_write:
  0001d	5e		 pop	 esi
  0001e	83 c8 ff	 or	 eax, -1
  00021	5b		 pop	 ebx

; 292  : }

  00022	c3		 ret	 0
$LN4@Tty_write:

; 283  :     if( NULL == buffer )    return -1;

  00023	85 db		 test	 ebx, ebx
  00025	74 f6		 je	 SHORT $LN10@Tty_write
  00027	55		 push	 ebp
  00028	57		 push	 edi

; 284  : #endif  /*  _CFG_CHECK_PARAMETER_   */
; 285  : 
; 286  : 	TTY_LOCK(tty);

  00029	8d 6e 14	 lea	 ebp, DWORD PTR [esi+20]
  0002c	55		 push	 ebp
  0002d	e8 00 00 00 00	 call	 _Lck_lock

; 287  :     while( size-- > 0 )

  00032	8b 7c 24 20	 mov	 edi, DWORD PTR _size$[esp+16]
  00036	83 c4 04	 add	 esp, 4
  00039	85 ff		 test	 edi, edi
  0003b	76 19		 jbe	 SHORT $LN8@Tty_write
  0003d	8d 49 00	 npad	 3
$LL2@Tty_write:

; 288  :         tty->tty_echo_hook(*buf++);        

  00040	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  00043	50		 push	 eax
  00044	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00047	83 ef 01	 sub	 edi, 1
  0004a	ff d0		 call	 eax
  0004c	83 c4 04	 add	 esp, 4
  0004f	83 c3 01	 add	 ebx, 1
  00052	85 ff		 test	 edi, edi
  00054	77 ea		 ja	 SHORT $LL2@Tty_write
$LN8@Tty_write:

; 289  : 	TTY_FREE(tty);

  00056	55		 push	 ebp
  00057	e8 00 00 00 00	 call	 _Lck_free
  0005c	83 c4 04	 add	 esp, 4
  0005f	5f		 pop	 edi
  00060	5d		 pop	 ebp

; 290  : 
; 291  :     return buf - (const byte_t *)buffer;

  00061	8b c3		 mov	 eax, ebx
  00063	2b 44 24 10	 sub	 eax, DWORD PTR _buffer$[esp+4]
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx

; 292  : }

  00069	c3		 ret	 0
_Tty_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GMALNMBL@OK?$CB?6?$AA@			; `string'
PUBLIC	??_C@_0BD@JEIFALBJ@tty?5initial?4?4?4?5?5?5?5?$AA@ ; `string'
PUBLIC	_Tty_initial
EXTRN	__memzero:PROC
EXTRN	__printk:PROC
;	COMDAT ??_C@_04GMALNMBL@OK?$CB?6?$AA@
CONST	SEGMENT
??_C@_04GMALNMBL@OK?$CB?6?$AA@ DB 'OK!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JEIFALBJ@tty?5initial?4?4?4?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BD@JEIFALBJ@tty?5initial?4?4?4?5?5?5?5?$AA@ DB 'tty initial...    '
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Tty_initial
_TEXT	SEGMENT
_Tty_initial PROC					; COMDAT

; 296  :     tty_t               *   tty     = NULL;
; 297  :     
; 298  :     _printk("tty initial...    ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JEIFALBJ@tty?5initial?4?4?4?5?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 299  :     /*
; 300  :      *  初始化主TTY设备。
; 301  :      */
; 302  :     tty = tty_pool;
; 303  : 
; 304  :     tty->tty_echo_hook              = Tty_echo_hook_default;
; 305  : 	tty->tty_termios.temo_type		= TERMIOS_TYPE_TTY;

  0000a	b8 02 00 00 00	 mov	 eax, 2

; 306  :     tty->tty_termios.temo_iflags    = TERMIOS_IFLAG_NEED_COOK ;
; 307  :     tty->tty_termios.temo_oflags    = TERMIOS_OFLAG_ECHO ;
; 308  : 
; 309  :     TQ_INIT(tty->tty_read_queue);

  0000f	68 82 00 00 00	 push	 130			; 00000082H
  00014	68 24 00 00 00	 push	 OFFSET _tty_pool+36
  00019	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR _tty_pool+16, OFFSET _Tty_echo_hook_default
  00023	a3 00 00 00 00	 mov	 DWORD PTR _tty_pool, eax
  00028	a2 04 00 00 00	 mov	 BYTE PTR _tty_pool+4, al
  0002d	c6 05 05 00 00
	00 01		 mov	 BYTE PTR _tty_pool+5, 1
  00034	e8 00 00 00 00	 call	 __memzero

; 310  :     TQ_INIT(tty->tty_write_queue);

  00039	68 82 00 00 00	 push	 130			; 00000082H
  0003e	68 a6 00 00 00	 push	 OFFSET _tty_pool+166
  00043	c6 05 a5 00 00
	00 7f		 mov	 BYTE PTR _tty_pool+165, 127 ; 0000007fH
  0004a	e8 00 00 00 00	 call	 __memzero

; 311  :     TQ_INIT(tty->tty_second_queue);

  0004f	68 82 00 00 00	 push	 130			; 00000082H
  00054	68 28 01 00 00	 push	 OFFSET _tty_pool+296
  00059	c6 05 27 01 00
	00 7f		 mov	 BYTE PTR _tty_pool+295, 127 ; 0000007fH
  00060	e8 00 00 00 00	 call	 __memzero

; 312  :     _printk("OK!\n");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  0006a	c6 05 a9 01 00
	00 7f		 mov	 BYTE PTR _tty_pool+425, 127 ; 0000007fH
  00071	e8 00 00 00 00	 call	 __printk
  00076	83 c4 20	 add	 esp, 32			; 00000020H

; 313  : }

  00079	c3		 ret	 0
_Tty_initial ENDP
_TEXT	ENDS
END
