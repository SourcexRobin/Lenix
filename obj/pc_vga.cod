; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\driver\pc_vga.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BG@HCMNMGHC@LDM?5vga?5driver?5open?5?6?$AA@ ; `string'
EXTRN	__printf:PROC
;	COMDAT ??_C@_0BG@HCMNMGHC@LDM?5vga?5driver?5open?5?6?$AA@
; File e:\sourcexstudio\lenix\lenix\src\driver\pc_vga.c
CONST	SEGMENT
??_C@_0BG@HCMNMGHC@LDM?5vga?5driver?5open?5?6?$AA@ DB 'LDM vga driver ope'
	DB	'n ', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Vga_open
_TEXT	SEGMENT
_device$ = 8						; size = 4
_Vga_open PROC						; COMDAT

; 22   :     _printf("LDM vga driver open \n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HCMNMGHC@LDM?5vga?5driver?5open?5?6?$AA@
  00005	e8 00 00 00 00	 call	 __printf

; 23   :     if( NULL == device )

  0000a	8b 44 24 08	 mov	 eax, DWORD PTR _device$[esp]
  0000e	83 c4 04	 add	 esp, 4
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	f7 d8		 neg	 eax
  00017	83 e8 01	 sub	 eax, 1

; 24   :         return RESULT_FAILED;
; 25   :     return RESULT_SUCCEED;
; 26   : }

  0001a	c3		 ret	 0
_Vga_open ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FPOLLGCO@LDM?5vga?5driver?5close?6?$AA@ ; `string'
;	COMDAT ??_C@_0BG@FPOLLGCO@LDM?5vga?5driver?5close?6?$AA@
CONST	SEGMENT
??_C@_0BG@FPOLLGCO@LDM?5vga?5driver?5close?6?$AA@ DB 'LDM vga driver clos'
	DB	'e', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Vga_close
_TEXT	SEGMENT
_device$ = 8						; size = 4
_Vga_close PROC						; COMDAT

; 29   :     _printf("LDM vga driver close\n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@FPOLLGCO@LDM?5vga?5driver?5close?6?$AA@
  00005	e8 00 00 00 00	 call	 __printf

; 30   :     if( NULL == device )

  0000a	8b 44 24 08	 mov	 eax, DWORD PTR _device$[esp]
  0000e	83 c4 04	 add	 esp, 4
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	f7 d8		 neg	 eax
  00017	83 e8 01	 sub	 eax, 1

; 31   :         return RESULT_FAILED;
; 32   : 
; 33   :     return RESULT_SUCCEED;
; 34   : }

  0001a	c3		 ret	 0
_Vga_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NAKCMJMG@LDM?5vga?5driver?5read?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@NAKCMJMG@LDM?5vga?5driver?5read?6?$AA@
CONST	SEGMENT
??_C@_0BF@NAKCMJMG@LDM?5vga?5driver?5read?6?$AA@ DB 'LDM vga driver read', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Vga_read
_TEXT	SEGMENT
_device$ = 8						; size = 4
_pos$ = 12						; size = 8
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_Vga_read PROC						; COMDAT

; 39   : {

  00000	53		 push	 ebx

; 40   :     vga_t               *   vga     = NULL;
; 41   :     byte_t              *   dbuf    = buffer;
; 42   :     byte_t FAR          *   sbuf    = NULL;
; 43   :     int                     left    = size;

  00001	8b 5c 24 18	 mov	 ebx, DWORD PTR _size$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 1c	 mov	 edi, DWORD PTR _buffer$[esp+8]

; 44   :     uint32_t                range   = 0;
; 45   : 
; 46   :     _printf("LDM vga driver read\n");

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@NAKCMJMG@LDM?5vga?5driver?5read?6?$AA@
  00010	8b f3		 mov	 esi, ebx
  00012	e8 00 00 00 00	 call	 __printf

; 47   :     if( NULL == device )

  00017	8b 44 24 14	 mov	 eax, DWORD PTR _device$[esp+12]
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN4@Vga_read
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 48   :         return RESULT_FAILED;

  00024	83 c8 ff	 or	 eax, -1
  00027	5b		 pop	 ebx

; 65   : }

  00028	c3		 ret	 0
$LN4@Vga_read:

; 49   : 
; 50   :     vga     = DEV_DATA(device);

  00029	8b 50 78	 mov	 edx, DWORD PTR [eax+120]
  0002c	85 d2		 test	 edx, edx
  0002e	75 03		 jne	 SHORT $LN8@Vga_read
  00030	8d 50 58	 lea	 edx, DWORD PTR [eax+88]
$LN8@Vga_read:

; 51   :     range   = vga->vga_scale_x * vga->vga_scale_y * 2;

  00033	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00037	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  0003b	0f af c8	 imul	 ecx, eax
  0003e	55		 push	 ebp

; 52   : 
; 53   :     if( pos >= range )

  0003f	8b 6c 24 1c	 mov	 ebp, DWORD PTR _pos$[esp+16]
  00043	33 c0		 xor	 eax, eax
  00045	03 c9		 add	 ecx, ecx
  00047	3b e8		 cmp	 ebp, eax
  00049	8b 44 24 18	 mov	 eax, DWORD PTR _pos$[esp+12]
  0004d	7c 0d		 jl	 SHORT $LN3@Vga_read
  0004f	7f 04		 jg	 SHORT $LN11@Vga_read
  00051	3b c1		 cmp	 eax, ecx
  00053	72 07		 jb	 SHORT $LN3@Vga_read
$LN11@Vga_read:
  00055	5d		 pop	 ebp
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 54   :         return 0;

  00058	33 c0		 xor	 eax, eax
  0005a	5b		 pop	 ebx

; 65   : }

  0005b	c3		 ret	 0
$LN3@Vga_read:

; 55   :     
; 56   :     sbuf    = (byte_t FAR *)vga->vga_buffer;
; 57   : 
; 58   :     while(left > 0 && pos < range )

  0005c	85 db		 test	 ebx, ebx
  0005e	8b 12		 mov	 edx, DWORD PTR [edx]
  00060	7e 25		 jle	 SHORT $LN1@Vga_read
$LL2@Vga_read:
  00062	33 db		 xor	 ebx, ebx
  00064	3b eb		 cmp	 ebp, ebx
  00066	7f 1b		 jg	 SHORT $LN13@Vga_read
  00068	7c 04		 jl	 SHORT $LN12@Vga_read
  0006a	3b c1		 cmp	 eax, ecx
  0006c	73 15		 jae	 SHORT $LN13@Vga_read
$LN12@Vga_read:

; 59   :     {
; 60   :         *dbuf++ = sbuf[pos++];

  0006e	8a 1c 10	 mov	 bl, BYTE PTR [eax+edx]
  00071	88 1f		 mov	 BYTE PTR [edi], bl
  00073	83 c7 01	 add	 edi, 1
  00076	83 c0 01	 add	 eax, 1
  00079	83 d5 00	 adc	 ebp, 0

; 61   :         left--;

  0007c	83 ee 01	 sub	 esi, 1
  0007f	85 f6		 test	 esi, esi
  00081	7f df		 jg	 SHORT $LL2@Vga_read
$LN13@Vga_read:

; 55   :     
; 56   :     sbuf    = (byte_t FAR *)vga->vga_buffer;
; 57   : 
; 58   :     while(left > 0 && pos < range )

  00083	8b 5c 24 24	 mov	 ebx, DWORD PTR _size$[esp+12]
$LN1@Vga_read:
  00087	5d		 pop	 ebp

; 62   :     }
; 63   :     
; 64   :     return size - left;

  00088	8b c3		 mov	 eax, ebx
  0008a	5f		 pop	 edi
  0008b	2b c6		 sub	 eax, esi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx

; 65   : }

  0008f	c3		 ret	 0
_Vga_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@OHDBKAAB@LDM?5vga?5driver?5write?6?$AA@ ; `string'
;	COMDAT ??_C@_0BG@OHDBKAAB@LDM?5vga?5driver?5write?6?$AA@
CONST	SEGMENT
??_C@_0BG@OHDBKAAB@LDM?5vga?5driver?5write?6?$AA@ DB 'LDM vga driver writ'
	DB	'e', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Vga_write
_TEXT	SEGMENT
_device$ = 8						; size = 4
_pos$ = 12						; size = 8
_buffer$ = 20						; size = 4
_size$ = 24						; size = 4
_Vga_write PROC						; COMDAT

; 69   : {

  00000	56		 push	 esi

; 70   :     vga_t               *   vga     = NULL;
; 71   :     byte_t FAR          *   dbuf    = NULL;
; 72   :     const byte_t        *   sbuf    = buffer;
; 73   :     int                     left    = size;

  00001	8b 74 24 18	 mov	 esi, DWORD PTR _size$[esp]
  00005	57		 push	 edi
  00006	8b 7c 24 18	 mov	 edi, DWORD PTR _buffer$[esp+4]

; 74   :     uint32_t                range   = 0;
; 75   : 
; 76   :     _printf("LDM vga driver write\n");

  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@OHDBKAAB@LDM?5vga?5driver?5write?6?$AA@
  0000f	e8 00 00 00 00	 call	 __printf

; 77   :     if( NULL == device )

  00014	8b 54 24 10	 mov	 edx, DWORD PTR _device$[esp+8]
  00018	83 c4 04	 add	 esp, 4
  0001b	85 d2		 test	 edx, edx
  0001d	75 06		 jne	 SHORT $LN4@Vga_write
  0001f	5f		 pop	 edi

; 78   :         return RESULT_FAILED;

  00020	83 c8 ff	 or	 eax, -1
  00023	5e		 pop	 esi

; 95   : }

  00024	c3		 ret	 0
$LN4@Vga_write:

; 79   : 
; 80   :     vga     = DEV_DATA(device);

  00025	8b 42 78	 mov	 eax, DWORD PTR [edx+120]
  00028	85 c0		 test	 eax, eax
  0002a	74 04		 je	 SHORT $LN7@Vga_write
  0002c	8b d0		 mov	 edx, eax
  0002e	eb 03		 jmp	 SHORT $LN8@Vga_write
$LN7@Vga_write:
  00030	83 c2 58	 add	 edx, 88			; 00000058H
$LN8@Vga_write:

; 81   :     range   = vga->vga_scale_x * vga->vga_scale_y * 2;

  00033	0f b7 42 06	 movzx	 eax, WORD PTR [edx+6]
  00037	0f b7 4a 08	 movzx	 ecx, WORD PTR [edx+8]
  0003b	0f af c8	 imul	 ecx, eax
  0003e	55		 push	 ebp

; 82   : 
; 83   :     if( pos >= range )

  0003f	8b 6c 24 18	 mov	 ebp, DWORD PTR _pos$[esp+12]
  00043	33 c0		 xor	 eax, eax
  00045	03 c9		 add	 ecx, ecx
  00047	3b e8		 cmp	 ebp, eax
  00049	8b 44 24 14	 mov	 eax, DWORD PTR _pos$[esp+8]
  0004d	7c 0c		 jl	 SHORT $LN3@Vga_write
  0004f	7f 04		 jg	 SHORT $LN11@Vga_write
  00051	3b c1		 cmp	 eax, ecx
  00053	72 06		 jb	 SHORT $LN3@Vga_write
$LN11@Vga_write:
  00055	5d		 pop	 ebp
  00056	5f		 pop	 edi

; 84   :         return 0;

  00057	33 c0		 xor	 eax, eax
  00059	5e		 pop	 esi

; 95   : }

  0005a	c3		 ret	 0
$LN3@Vga_write:

; 85   :     
; 86   :     dbuf    = (byte_t FAR *)vga->vga_buffer;
; 87   : 
; 88   :     while(left > 0 && pos < range )

  0005b	85 f6		 test	 esi, esi
  0005d	8b 12		 mov	 edx, DWORD PTR [edx]
  0005f	7e 23		 jle	 SHORT $LN14@Vga_write
  00061	53		 push	 ebx
$LL2@Vga_write:
  00062	33 db		 xor	 ebx, ebx
  00064	3b eb		 cmp	 ebp, ebx
  00066	7f 1b		 jg	 SHORT $LN16@Vga_write
  00068	7c 04		 jl	 SHORT $LN12@Vga_write
  0006a	3b c1		 cmp	 eax, ecx
  0006c	73 15		 jae	 SHORT $LN16@Vga_write
$LN12@Vga_write:

; 89   :     {
; 90   :         dbuf[pos++] = *sbuf++;

  0006e	8a 1f		 mov	 bl, BYTE PTR [edi]
  00070	88 1c 10	 mov	 BYTE PTR [eax+edx], bl
  00073	83 c0 01	 add	 eax, 1
  00076	83 d5 00	 adc	 ebp, 0

; 91   :         left--;

  00079	83 ee 01	 sub	 esi, 1
  0007c	83 c7 01	 add	 edi, 1
  0007f	85 f6		 test	 esi, esi
  00081	7f df		 jg	 SHORT $LL2@Vga_write
$LN16@Vga_write:
  00083	5b		 pop	 ebx
$LN14@Vga_write:

; 92   :     }
; 93   :     
; 94   :     return size - left;

  00084	8b 44 24 20	 mov	 eax, DWORD PTR _size$[esp+8]
  00088	5d		 pop	 ebp
  00089	5f		 pop	 edi
  0008a	2b c6		 sub	 eax, esi
  0008c	5e		 pop	 esi

; 95   : }

  0008d	c3		 ret	 0
_Vga_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@JBHAPAD@LDM?5vga?5driver?5ctrl?6?$AA@	; `string'
;	COMDAT ??_C@_0BF@JBHAPAD@LDM?5vga?5driver?5ctrl?6?$AA@
CONST	SEGMENT
??_C@_0BF@JBHAPAD@LDM?5vga?5driver?5ctrl?6?$AA@ DB 'LDM vga driver ctrl', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Vga_ctrl
_TEXT	SEGMENT
_device$ = 8						; size = 4
_cmd$ = 12						; size = 1
_arg$ = 16						; size = 4
_Vga_ctrl PROC						; COMDAT

; 100  :     vga_t               *   vga     = NULL;
; 101  : 
; 102  :     _printf("LDM vga driver ctrl\n");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JBHAPAD@LDM?5vga?5driver?5ctrl?6?$AA@
  00005	e8 00 00 00 00	 call	 __printf
  0000a	83 c4 04	 add	 esp, 4

; 103  :     if( NULL == device )

  0000d	83 7c 24 04 00	 cmp	 DWORD PTR _device$[esp-4], 0

; 104  :         return RESULT_FAILED;

  00012	74 08		 je	 SHORT $LN1@Vga_ctrl

; 105  : 
; 106  :     vga = DEV_DATA(device);
; 107  : 
; 108  :     switch(cmd)

  00014	0f b6 44 24 08	 movzx	 eax, BYTE PTR _cmd$[esp-4]
  00019	83 e8 01	 sub	 eax, 1
$LN1@Vga_ctrl:

; 109  :     {
; 110  :     case VGA_CMD_SET_ATTR:
; 111  :         arg = arg;
; 112  :         vga = vga;
; 113  :         return RESULT_FAILED;

  0001c	83 c8 ff	 or	 eax, -1

; 114  :     }
; 115  :     return RESULT_FAILED;
; 116  : }

  0001f	c3		 ret	 0
_Vga_ctrl ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FHJNBMBJ@LDM?5vga?5driver?5entry?5registe?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BDEIKDJL@LDM?5vga?5driver?5entry?5unregiste?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@MLEDLJPN@LDM?5vga?5driver?5entry?6?$AA@ ; `string'
PUBLIC	_Vga_entry
;	COMDAT ??_C@_0BO@FHJNBMBJ@LDM?5vga?5driver?5entry?5registe?6?$AA@
CONST	SEGMENT
??_C@_0BO@FHJNBMBJ@LDM?5vga?5driver?5entry?5registe?6?$AA@ DB 'LDM vga dr'
	DB	'iver entry registe', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BDEIKDJL@LDM?5vga?5driver?5entry?5unregiste?6?$AA@
CONST	SEGMENT
??_C@_0CA@BDEIKDJL@LDM?5vga?5driver?5entry?5unregiste?6?$AA@ DB 'LDM vga '
	DB	'driver entry unregiste', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MLEDLJPN@LDM?5vga?5driver?5entry?6?$AA@
CONST	SEGMENT
??_C@_0BG@MLEDLJPN@LDM?5vga?5driver?5entry?6?$AA@ DB 'LDM vga driver entr'
	DB	'y', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Vga_entry
_TEXT	SEGMENT
_device$ = 8						; size = 4
_flag$ = 12						; size = 4
_param$ = 16						; size = 4
_Vga_entry PROC						; COMDAT

; 119  : {

  00000	56		 push	 esi

; 120  :     vga_t               *   vga     = NULL;
; 121  : 
; 122  :     _printf("LDM vga driver entry\n");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@MLEDLJPN@LDM?5vga?5driver?5entry?6?$AA@
  00006	e8 00 00 00 00	 call	 __printf

; 123  :     if( NULL == device )

  0000b	8b 74 24 0c	 mov	 esi, DWORD PTR _device$[esp+4]
  0000f	83 c4 04	 add	 esp, 4
  00012	85 f6		 test	 esi, esi
  00014	75 05		 jne	 SHORT $LN5@Vga_entry
$LN13@Vga_entry:

; 124  :     {
; 125  :         param = param;
; 126  :         return RESULT_FAILED;

  00016	83 c8 ff	 or	 eax, -1
  00019	5e		 pop	 esi

; 155  : }

  0001a	c3		 ret	 0
$LN5@Vga_entry:

; 127  :     }
; 128  : 
; 129  :     switch(flag)

  0001b	8b 44 24 0c	 mov	 eax, DWORD PTR _flag$[esp]
  0001f	83 e8 00	 sub	 eax, 0
  00022	74 16		 je	 SHORT $LN2@Vga_entry
  00024	83 e8 01	 sub	 eax, 1

; 148  :     case DEV_ENTRY_FLAG_UNREG:
; 149  :         _printf("LDM vga driver entry unregiste\n");
; 150  :         vga = DEV_DATA(device);
; 151  :         return RESULT_SUCCEED;
; 152  :     }
; 153  : 
; 154  :     return RESULT_FAILED;

  00027	75 ed		 jne	 SHORT $LN13@Vga_entry
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BDEIKDJL@LDM?5vga?5driver?5entry?5unregiste?6?$AA@
  0002e	e8 00 00 00 00	 call	 __printf
  00033	83 c4 04	 add	 esp, 4
  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 155  : }

  00039	c3		 ret	 0
$LN2@Vga_entry:

; 130  :     {
; 131  :     case DEV_ENTRY_FLAG_REG:
; 132  :         _printf("LDM vga driver entry registe\n");

  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FHJNBMBJ@LDM?5vga?5driver?5entry?5registe?6?$AA@
  0003f	e8 00 00 00 00	 call	 __printf

; 133  :         device->dev_data_ext = NULL;

  00044	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0

; 134  :         vga = DEV_DATA(device);
; 135  : 
; 136  :         vga->vga_buffer     = (word_t FAR *)0xB8000000;

  0004b	c7 46 58 00 00
	00 b8		 mov	 DWORD PTR [esi+88], -1207959552 ; b8000000H

; 137  :         vga->vga_scale_x    = 80;

  00052	66 c7 46 5e 50
	00		 mov	 WORD PTR [esi+94], 80	; 00000050H

; 138  :         vga->vga_scale_y    = 25;

  00058	66 c7 46 60 19
	00		 mov	 WORD PTR [esi+96], 25	; 00000019H

; 139  :         vga->vga_attr       = 0x07;

  0005e	c6 46 5d 07	 mov	 BYTE PTR [esi+93], 7
  00062	83 c4 04	 add	 esp, 4

; 140  : 
; 141  :         device->dev_ddo.ddo_open    = Vga_open;

  00065	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], OFFSET _Vga_open

; 142  :         device->dev_ddo.ddo_close   = Vga_close;

  0006c	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], OFFSET _Vga_close

; 143  :         device->dev_ddo.ddo_read    = Vga_read;

  00073	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], OFFSET _Vga_read

; 144  :         device->dev_ddo.ddo_write   = Vga_write;

  0007a	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], OFFSET _Vga_write

; 145  :         device->dev_ddo.ddo_ctrl    = Vga_ctrl;

  00081	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], OFFSET _Vga_ctrl

; 146  : 
; 147  :         return RESULT_SUCCEED;

  00088	33 c0		 xor	 eax, eax
  0008a	5e		 pop	 esi

; 155  : }

  0008b	c3		 ret	 0
_Vga_entry ENDP
_TEXT	ENDS
END
