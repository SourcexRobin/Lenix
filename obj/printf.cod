; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\libc\printf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_alphabet_A DB	'0123456789ABCDEF', 00H
	ORG $+3
_alphabet_a DB	'0123456789abcdef', 00H
	ORG $+3
CONST	ENDS
PUBLIC	__nvsprintf
EXTRN	__up_case:PROC
EXTRN	__strlen:PROC
EXTRN	_Tty_write:PROC
EXTRN	__aulldvrm:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\libc\printf.c
;	COMDAT __nvsprintf
_TEXT	SEGMENT
_pad_space$ = -133					; size = 1
_count$ = -132						; size = 4
_pad$ = -125						; size = 1
_buf$ = -124						; size = 4
_field_width$ = -120					; size = 4
_i$ = -116						; size = 4
_c$870 = -109						; size = 1
_len$1099 = -108					; size = 4
_len$1038 = -108					; size = 4
_len$976 = -108						; size = 4
_sign$ = -108						; size = 4
_flag$ = -104						; size = 4
_c$1100 = -100						; size = 1
tv943 = -96						; size = 8
_upcase$ = -96						; size = 4
tv673 = -88						; size = 8
_num_buf$ = -80						; size = 80
_buffer$ = 8						; size = 4
_fmt$ = 12						; size = 4
_al$ = 16						; size = 4
_bufsize$ = 20						; size = 4
__nvsprintf PROC					; COMDAT

; 76   : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	53		 push	 ebx
  00007	55		 push	 ebp

; 77   :     char          * buf             = buffer;   /*      */

  00008	8b ac 24 94 00
	00 00		 mov	 ebp, DWORD PTR _buffer$[esp+140]
  0000f	56		 push	 esi
  00010	57		 push	 edi

; 78   :     int             status          = 0;        /*  0表示扫描格式字符串，

  00011	33 ff		 xor	 edi, edi

; 79   :                                                     1表示处理参数           */
; 80   : 
; 81   :     char            pad             = 0;        /*      */
; 82   :     char            pad_space       = ' ';      /*      */
; 83   : 
; 84   :     int             upcase          = 0;
; 85   :     int             flag            = 0;        /*  格式标志                */
; 86   :     int             field_width     = 0;        /*  格式化宽度              */
; 87   :     int             precision       = 0;        /*  格式精度，浮点数用      */
; 88   :     char            qualifier       = 0;        /*  长格式标志              */
; 89   :     unsigned int    sign            = 0;        /*  符号标志，仅对10进制有效*/
; 90   :     unsigned int    base            = 0;        /*  数字进制                */
; 91   :     const char    * alphabet        = NULL;
; 92   : 
; 93   :     int             count           = 0;
; 94   :     int             i               = 0;
; 95   :     char            num_buf[MAX_NUM_BUF]     = {0};

  00013	6a 4f		 push	 79			; 0000004fH
  00015	8d 44 24 4d	 lea	 eax, DWORD PTR _num_buf$[esp+157]
  00019	57		 push	 edi
  0001a	8b f5		 mov	 esi, ebp
  0001c	50		 push	 eax
  0001d	89 74 24 28	 mov	 DWORD PTR _buf$[esp+164], esi
  00021	c6 44 24 27 00	 mov	 BYTE PTR _pad$[esp+164], 0
  00026	c6 44 24 1f 20	 mov	 BYTE PTR _pad_space$[esp+164], 32 ; 00000020H
  0002b	89 7c 24 20	 mov	 DWORD PTR _count$[esp+164], edi
  0002f	89 7c 24 30	 mov	 DWORD PTR _i$[esp+164], edi
  00033	c6 44 24 54 00	 mov	 BYTE PTR _num_buf$[esp+164], 0
  00038	e8 00 00 00 00	 call	 _memset

; 96   : 
; 97   :     /*
; 98   :      *  直至格式化字符串处理完毕
; 99   :      */
; 100  :     for( ; *fmt && bufsize > 0; fmt++ )

  0003d	8b 9c 24 ac 00
	00 00		 mov	 ebx, DWORD PTR _fmt$[esp+160]
  00044	8a 03		 mov	 al, BYTE PTR [ebx]
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	84 c0		 test	 al, al
  0004b	0f 84 f3 08 00
	00		 je	 $LN295@nvsprintf
$LL211@nvsprintf:
  00051	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR _bufsize$[esp+148], 0
  00059	0f 8e e5 08 00
	00		 jle	 $LN295@nvsprintf

; 101  :     {
; 102  :         char c = *fmt;
; 103  :         
; 104  :         if( 0 == status )

  0005f	85 ff		 test	 edi, edi
  00061	8a c8		 mov	 cl, al
  00063	88 4c 24 2b	 mov	 BYTE PTR _c$870[esp+152], cl
  00067	75 6d		 jne	 SHORT $LN208@nvsprintf

; 105  :         {
; 106  :             if( '%' == c )

  00069	80 f9 25	 cmp	 cl, 37			; 00000025H
  0006c	75 0a		 jne	 SHORT $LN205@nvsprintf

; 107  :                 status = 1;

  0006e	bf 01 00 00 00	 mov	 edi, 1

; 108  :             else

  00073	e9 b0 08 00 00	 jmp	 $LN210@nvsprintf
$LN205@nvsprintf:

; 109  :                 OUTPUT_CHAR(buf,c,bufsize);

  00078	85 f6		 test	 esi, esi
  0007a	75 27		 jne	 SHORT $LN202@nvsprintf
  0007c	80 f9 08	 cmp	 cl, 8
  0007f	75 07		 jne	 SHORT $LN201@nvsprintf
  00081	83 6c 24 14 01	 sub	 DWORD PTR _count$[esp+152], 1
  00086	eb 05		 jmp	 SHORT $LN200@nvsprintf
$LN201@nvsprintf:
  00088	83 44 24 14 01	 add	 DWORD PTR _count$[esp+152], 1
$LN200@nvsprintf:
  0008d	6a 01		 push	 1
  0008f	8d 4c 24 2f	 lea	 ecx, DWORD PTR _c$870[esp+156]
  00093	51		 push	 ecx
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 _Tty_write
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	e9 85 08 00 00	 jmp	 $LN210@nvsprintf
$LN202@nvsprintf:
  000a3	80 f9 08	 cmp	 cl, 8
  000a6	75 18		 jne	 SHORT $LN197@nvsprintf
  000a8	3b f5		 cmp	 esi, ebp
  000aa	76 14		 jbe	 SHORT $LN197@nvsprintf
  000ac	83 ee 01	 sub	 esi, 1
  000af	83 84 24 a8 00
	00 00 01	 add	 DWORD PTR _bufsize$[esp+148], 1
  000b7	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
  000bb	e9 68 08 00 00	 jmp	 $LN210@nvsprintf
$LN197@nvsprintf:
  000c0	88 0e		 mov	 BYTE PTR [esi], cl
  000c2	83 c6 01	 add	 esi, 1
  000c5	83 ac 24 a8 00
	00 00 01	 sub	 DWORD PTR _bufsize$[esp+148], 1
  000cd	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi

; 110  :             continue;

  000d1	e9 52 08 00 00	 jmp	 $LN210@nvsprintf
$LN208@nvsprintf:

; 111  :         }
; 112  : 
; 113  :         flag    = 0;

  000d6	33 c9		 xor	 ecx, ecx

; 114  :         pad     = ' ';
; 115  : 
; 116  :         /*
; 117  :          *  取格式化标志
; 118  :          */
; 119  :         for( ; *fmt ; fmt++)

  000d8	84 c0		 test	 al, al
  000da	89 4c 24 30	 mov	 DWORD PTR _flag$[esp+152], ecx
  000de	c6 44 24 1b 20	 mov	 BYTE PTR _pad$[esp+152], 32 ; 00000020H
  000e3	74 45		 je	 SHORT $get_flag_end$897
$LL195@nvsprintf:

; 120  :         {
; 121  :             switch(*fmt)

  000e5	0f be c0	 movsx	 eax, al
  000e8	83 c0 e0	 add	 eax, -32		; ffffffe0H
  000eb	83 f8 10	 cmp	 eax, 16			; 00000010H
  000ee	77 2f		 ja	 SHORT $LN304@nvsprintf
  000f0	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN260@nvsprintf[eax]
  000f7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN332@nvsprintf[edx*4]
$LN190@nvsprintf:

; 122  :             {
; 123  :             case '0':    flag |= FLAG_ZERO_PAD; pad = '0';  break;

  000fe	83 c9 01	 or	 ecx, 1
  00101	c6 44 24 1b 30	 mov	 BYTE PTR _pad$[esp+152], 48 ; 00000030H
  00106	eb 0d		 jmp	 SHORT $LN194@nvsprintf
$LN189@nvsprintf:

; 124  :             case '-':    flag |= FLAG_LEFT_ALIGN;           break;

  00108	83 c9 02	 or	 ecx, 2
  0010b	eb 08		 jmp	 SHORT $LN194@nvsprintf
$LN188@nvsprintf:

; 125  :             case ' ':    flag |= FLAG_SPACE;                break;

  0010d	83 c9 04	 or	 ecx, 4
  00110	eb 03		 jmp	 SHORT $LN194@nvsprintf
$LN187@nvsprintf:

; 126  :             case '+':    flag |= FLAG_PLUS;                 break;

  00112	83 c9 08	 or	 ecx, 8
$LN194@nvsprintf:

; 114  :         pad     = ' ';
; 115  : 
; 116  :         /*
; 117  :          *  取格式化标志
; 118  :          */
; 119  :         for( ; *fmt ; fmt++)

  00115	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00118	83 c3 01	 add	 ebx, 1
  0011b	84 c0		 test	 al, al
  0011d	75 c6		 jne	 SHORT $LL195@nvsprintf
$LN304@nvsprintf:
  0011f	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR _fmt$[esp+148], ebx

; 122  :             {
; 123  :             case '0':    flag |= FLAG_ZERO_PAD; pad = '0';  break;

  00126	89 4c 24 30	 mov	 DWORD PTR _flag$[esp+152], ecx
$get_flag_end$897:

; 127  :             default :    goto get_flag_end; /*  不是可识别的符号，则跳出*/
; 128  :             }
; 129  :         }
; 130  : get_flag_end:
; 131  : 
; 132  :         /*
; 133  :          *  取字段宽度
; 134  :          */
; 135  :         field_width = 0;
; 136  :         for( ; CHAR_IS_DIGITAL(*fmt) ; fmt++)

  0012a	8a 03		 mov	 al, BYTE PTR [ebx]
  0012c	33 c9		 xor	 ecx, ecx
  0012e	3c 30		 cmp	 al, 48			; 00000030H
  00130	89 4c 24 20	 mov	 DWORD PTR _field_width$[esp+152], ecx
  00134	7c 22		 jl	 SHORT $LN183@nvsprintf
$LL185@nvsprintf:
  00136	3c 39		 cmp	 al, 57			; 00000039H
  00138	7f 13		 jg	 SHORT $LN306@nvsprintf
  0013a	83 c3 01	 add	 ebx, 1

; 137  :             field_width = field_width * 10 + *fmt - '0';

  0013d	0f be d0	 movsx	 edx, al
  00140	8a 03		 mov	 al, BYTE PTR [ebx]
  00142	3c 30		 cmp	 al, 48			; 00000030H
  00144	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00147	8d 4c 4a d0	 lea	 ecx, DWORD PTR [edx+ecx*2-48]
  0014b	7d e9		 jge	 SHORT $LL185@nvsprintf
$LN306@nvsprintf:
  0014d	89 4c 24 20	 mov	 DWORD PTR _field_width$[esp+152], ecx
  00151	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR _fmt$[esp+148], ebx
$LN183@nvsprintf:

; 138  : 
; 139  :         /*
; 140  :          *  取精度域
; 141  :          */
; 142  :         precision = 0;
; 143  :         if( *fmt == '.')

  00158	80 3b 2e	 cmp	 BYTE PTR [ebx], 46	; 0000002eH
  0015b	75 28		 jne	 SHORT $LN179@nvsprintf

; 144  :         {
; 145  :             fmt++;
; 146  :             for( ; CHAR_IS_DIGITAL(*fmt) ; fmt++)

  0015d	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00160	83 c3 01	 add	 ebx, 1
  00163	3c 30		 cmp	 al, 48			; 00000030H
  00165	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR _fmt$[esp+148], ebx
  0016c	7c 17		 jl	 SHORT $LN179@nvsprintf
  0016e	8b ff		 npad	 2
$LL181@nvsprintf:
  00170	3c 39		 cmp	 al, 57			; 00000039H
  00172	7f 0a		 jg	 SHORT $LN308@nvsprintf
  00174	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00177	83 c3 01	 add	 ebx, 1
  0017a	3c 30		 cmp	 al, 48			; 00000030H
  0017c	7d f2		 jge	 SHORT $LL181@nvsprintf
$LN308@nvsprintf:
  0017e	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR _fmt$[esp+148], ebx
$LN179@nvsprintf:

; 147  :                 precision = precision * 10 + *fmt - '0';
; 148  :         }
; 149  : 
; 150  :         /*
; 151  :          *  取长格式
; 152  :          */
; 153  :         qualifier = 0;
; 154  :         if( *fmt == 'h' || *fmt == 'l' || *fmt == 'L' )

  00185	8a 03		 mov	 al, BYTE PTR [ebx]
  00187	32 c9		 xor	 cl, cl
  00189	3c 68		 cmp	 al, 104			; 00000068H
  0018b	74 08		 je	 SHORT $LN279@nvsprintf
  0018d	3c 6c		 cmp	 al, 108			; 0000006cH
  0018f	74 04		 je	 SHORT $LN279@nvsprintf
  00191	3c 4c		 cmp	 al, 76			; 0000004cH
  00193	75 0c		 jne	 SHORT $LN178@nvsprintf
$LN279@nvsprintf:

; 155  :             qualifier = *fmt++;

  00195	83 c3 01	 add	 ebx, 1
  00198	8a c8		 mov	 cl, al
  0019a	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR _fmt$[esp+148], ebx
$LN178@nvsprintf:

; 156  : 
; 157  :         sign        = 0;
; 158  :         base        = 10;
; 159  :         alphabet    = alphabet_A;
; 160  :         upcase      = 0;
; 161  : 
; 162  :         switch( *fmt )

  001a1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR _fmt$[esp+148]
  001a8	0f be 00	 movsx	 eax, BYTE PTR [eax]
  001ab	33 db		 xor	 ebx, ebx
  001ad	33 d2		 xor	 edx, edx
  001af	83 c0 bd	 add	 eax, -67		; ffffffbdH
  001b2	83 f8 35	 cmp	 eax, 53			; 00000035H
  001b5	89 5c 24 2c	 mov	 DWORD PTR _sign$[esp+152], ebx
  001b9	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH
  001be	bd 00 00 00 00	 mov	 ebp, OFFSET _alphabet_A
  001c3	89 54 24 38	 mov	 DWORD PTR _upcase$[esp+152], edx
  001c7	0f 87 f9 06 00
	00		 ja	 $LN150@nvsprintf
  001cd	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN261@nvsprintf[eax]
  001d4	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN333@nvsprintf[eax*4]
$LN174@nvsprintf:

; 163  :         {
; 164  :         case 'i':
; 165  :         case 'd':
; 166  :             sign = 1;

  001db	bb 01 00 00 00	 mov	 ebx, 1
  001e0	89 5c 24 2c	 mov	 DWORD PTR _sign$[esp+152], ebx

; 167  :             goto num_handle;

  001e4	e9 f1 01 00 00	 jmp	 $num_handle$912
$LN172@nvsprintf:

; 168  :         case 'u':
; 169  :             goto num_handle;
; 170  :         case 'S':
; 171  :             upcase = 1;

  001e9	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR _upcase$[esp+152], 1
$string_handle$916:

; 298  : string_handle:
; 299  :         {
; 300  :             char        *   str = va_arg(al,char *);

  001f1	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR _al$[esp+148]
  001f8	8b 28		 mov	 ebp, DWORD PTR [eax]
  001fa	83 c0 04	 add	 eax, 4

; 301  :             int             len = _strlen(str);

  001fd	55		 push	 ebp
  001fe	89 84 24 a8 00
	00 00		 mov	 DWORD PTR _al$[esp+152], eax
  00205	e8 00 00 00 00	 call	 __strlen

; 302  :             char            c   = 0;
; 303  : 
; 304  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 305  :             {
; 306  :                 while( len < field_width-- && bufsize > 0 )

  0020a	8b bc 24 ac 00
	00 00		 mov	 edi, DWORD PTR _bufsize$[esp+152]
  00211	83 c4 04	 add	 esp, 4
  00214	f6 44 24 30 02	 test	 BYTE PTR _flag$[esp+152], 2
  00219	89 44 24 2c	 mov	 DWORD PTR _len$1099[esp+152], eax
  0021d	c6 44 24 34 00	 mov	 BYTE PTR _c$1100[esp+152], 0
  00222	0f 85 7d 00 00
	00		 jne	 $LN42@nvsprintf
  00228	8b 5c 24 20	 mov	 ebx, DWORD PTR _field_width$[esp+152]
  0022c	3b c3		 cmp	 eax, ebx
  0022e	7d 61		 jge	 SHORT $LN232@nvsprintf
$LL291@nvsprintf:
  00230	b9 01 00 00 00	 mov	 ecx, 1
  00235	2b d9		 sub	 ebx, ecx
  00237	85 ff		 test	 edi, edi
  00239	7e 5b		 jle	 SHORT $LN310@nvsprintf

; 307  :                     OUTPUT_CHAR(buf,pad_space,bufsize);

  0023b	85 f6		 test	 esi, esi
  0023d	75 24		 jne	 SHORT $LN38@nvsprintf
  0023f	80 7c 24 13 08	 cmp	 BYTE PTR _pad_space$[esp+152], 8
  00244	75 06		 jne	 SHORT $LN37@nvsprintf
  00246	29 4c 24 14	 sub	 DWORD PTR _count$[esp+152], ecx
  0024a	eb 04		 jmp	 SHORT $LN36@nvsprintf
$LN37@nvsprintf:
  0024c	01 4c 24 14	 add	 DWORD PTR _count$[esp+152], ecx
$LN36@nvsprintf:
  00250	6a 01		 push	 1
  00252	8d 4c 24 17	 lea	 ecx, DWORD PTR _pad_space$[esp+156]
  00256	51		 push	 ecx
  00257	6a 00		 push	 0
  00259	e8 00 00 00 00	 call	 _Tty_write
  0025e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00261	eb 1d		 jmp	 SHORT $LN40@nvsprintf
$LN38@nvsprintf:
  00263	8a 44 24 13	 mov	 al, BYTE PTR _pad_space$[esp+152]
  00267	3c 08		 cmp	 al, 8
  00269	75 0f		 jne	 SHORT $LN33@nvsprintf
  0026b	3b b4 24 9c 00
	00 00		 cmp	 esi, DWORD PTR _buffer$[esp+148]
  00272	76 06		 jbe	 SHORT $LN33@nvsprintf
  00274	2b f1		 sub	 esi, ecx
  00276	03 f9		 add	 edi, ecx
  00278	eb 06		 jmp	 SHORT $LN40@nvsprintf
$LN33@nvsprintf:
  0027a	88 06		 mov	 BYTE PTR [esi], al
  0027c	03 f1		 add	 esi, ecx
  0027e	2b f9		 sub	 edi, ecx
$LN40@nvsprintf:

; 302  :             char            c   = 0;
; 303  : 
; 304  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 305  :             {
; 306  :                 while( len < field_width-- && bufsize > 0 )

  00280	39 5c 24 2c	 cmp	 DWORD PTR _len$1099[esp+152], ebx
  00284	7c aa		 jl	 SHORT $LL291@nvsprintf

; 307  :                     OUTPUT_CHAR(buf,pad_space,bufsize);

  00286	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], edi
  0028d	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
$LN232@nvsprintf:

; 302  :             char            c   = 0;
; 303  : 
; 304  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 305  :             {
; 306  :                 while( len < field_width-- && bufsize > 0 )

  00291	83 eb 01	 sub	 ebx, 1
  00294	eb 0b		 jmp	 SHORT $LN322@nvsprintf
$LN310@nvsprintf:

; 307  :                     OUTPUT_CHAR(buf,pad_space,bufsize);

  00296	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], edi
  0029d	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
$LN322@nvsprintf:

; 302  :             char            c   = 0;
; 303  : 
; 304  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 305  :             {
; 306  :                 while( len < field_width-- && bufsize > 0 )

  002a1	89 5c 24 20	 mov	 DWORD PTR _field_width$[esp+152], ebx
$LN42@nvsprintf:

; 308  :             }
; 309  : 
; 310  :             for( ; *str && bufsize > 0  ; str++ )

  002a5	8a 45 00	 mov	 al, BYTE PTR [ebp]
  002a8	84 c0		 test	 al, al
  002aa	b9 01 00 00 00	 mov	 ecx, 1
  002af	0f 84 85 00 00
	00		 je	 $LN220@nvsprintf
  002b5	8b 5c 24 38	 mov	 ebx, DWORD PTR _upcase$[esp+152]
  002b9	8d a4 24 00 00
	00 00		 npad	 7
$LL31@nvsprintf:
  002c0	85 ff		 test	 edi, edi
  002c2	7e 76		 jle	 SHORT $LN220@nvsprintf

; 311  :             {
; 312  :                 c = *str;
; 313  :                 if( upcase )

  002c4	85 db		 test	 ebx, ebx
  002c6	88 44 24 34	 mov	 BYTE PTR _c$1100[esp+152], al
  002ca	74 16		 je	 SHORT $LN27@nvsprintf

; 314  :                     c = _up_case(c);

  002cc	8b 54 24 34	 mov	 edx, DWORD PTR _c$1100[esp+152]
  002d0	52		 push	 edx
  002d1	e8 00 00 00 00	 call	 __up_case
  002d6	83 c4 04	 add	 esp, 4
  002d9	88 44 24 34	 mov	 BYTE PTR _c$1100[esp+152], al
  002dd	b9 01 00 00 00	 mov	 ecx, 1
$LN27@nvsprintf:

; 315  : 
; 316  :                 OUTPUT_CHAR(buf,c,bufsize);

  002e2	85 f6		 test	 esi, esi
  002e4	75 26		 jne	 SHORT $LN24@nvsprintf
  002e6	3c 08		 cmp	 al, 8
  002e8	75 06		 jne	 SHORT $LN23@nvsprintf
  002ea	29 4c 24 14	 sub	 DWORD PTR _count$[esp+152], ecx
  002ee	eb 04		 jmp	 SHORT $LN22@nvsprintf
$LN23@nvsprintf:
  002f0	01 4c 24 14	 add	 DWORD PTR _count$[esp+152], ecx
$LN22@nvsprintf:
  002f4	6a 01		 push	 1
  002f6	8d 44 24 38	 lea	 eax, DWORD PTR _c$1100[esp+156]
  002fa	50		 push	 eax
  002fb	6a 00		 push	 0
  002fd	e8 00 00 00 00	 call	 _Tty_write
  00302	83 c4 0c	 add	 esp, 12			; 0000000cH
  00305	b9 01 00 00 00	 mov	 ecx, 1
  0030a	eb 24		 jmp	 SHORT $LN26@nvsprintf
$LN24@nvsprintf:
  0030c	3c 08		 cmp	 al, 8
  0030e	75 0f		 jne	 SHORT $LN19@nvsprintf
  00310	3b b4 24 9c 00
	00 00		 cmp	 esi, DWORD PTR _buffer$[esp+148]
  00317	76 06		 jbe	 SHORT $LN19@nvsprintf
  00319	2b f1		 sub	 esi, ecx
  0031b	03 f9		 add	 edi, ecx
  0031d	eb 06		 jmp	 SHORT $LN323@nvsprintf
$LN19@nvsprintf:
  0031f	88 06		 mov	 BYTE PTR [esi], al
  00321	03 f1		 add	 esi, ecx
  00323	2b f9		 sub	 edi, ecx
$LN323@nvsprintf:
  00325	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], edi
  0032c	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
$LN26@nvsprintf:
  00330	8a 44 0d 00	 mov	 al, BYTE PTR [ebp+ecx]
  00334	03 e9		 add	 ebp, ecx
  00336	84 c0		 test	 al, al
  00338	75 86		 jne	 SHORT $LL31@nvsprintf
$LN220@nvsprintf:

; 317  :             }
; 318  : 
; 319  :             while( len < field_width-- && bufsize > 0 )

  0033a	8b 54 24 2c	 mov	 edx, DWORD PTR _len$1099[esp+152]
  0033e	3b 54 24 20	 cmp	 edx, DWORD PTR _field_width$[esp+152]
  00342	0f 8d d7 05 00
	00		 jge	 $LN149@nvsprintf
$LL17@nvsprintf:
  00348	29 4c 24 20	 sub	 DWORD PTR _field_width$[esp+152], ecx
  0034c	85 ff		 test	 edi, edi
  0034e	7e 54		 jle	 SHORT $LN312@nvsprintf

; 320  :                 OUTPUT_CHAR(buf,pad_space,bufsize);

  00350	85 f6		 test	 esi, esi
  00352	75 29		 jne	 SHORT $LN12@nvsprintf
  00354	80 7c 24 13 08	 cmp	 BYTE PTR _pad_space$[esp+152], 8
  00359	75 06		 jne	 SHORT $LN11@nvsprintf
  0035b	29 4c 24 14	 sub	 DWORD PTR _count$[esp+152], ecx
  0035f	eb 04		 jmp	 SHORT $LN10@nvsprintf
$LN11@nvsprintf:
  00361	01 4c 24 14	 add	 DWORD PTR _count$[esp+152], ecx
$LN10@nvsprintf:
  00365	6a 01		 push	 1
  00367	8d 44 24 17	 lea	 eax, DWORD PTR _pad_space$[esp+156]
  0036b	50		 push	 eax
  0036c	6a 00		 push	 0
  0036e	e8 00 00 00 00	 call	 _Tty_write
  00373	83 c4 0c	 add	 esp, 12			; 0000000cH
  00376	b9 01 00 00 00	 mov	 ecx, 1
  0037b	eb 1d		 jmp	 SHORT $LN14@nvsprintf
$LN12@nvsprintf:
  0037d	8a 44 24 13	 mov	 al, BYTE PTR _pad_space$[esp+152]
  00381	3c 08		 cmp	 al, 8
  00383	75 0f		 jne	 SHORT $LN7@nvsprintf
  00385	3b b4 24 9c 00
	00 00		 cmp	 esi, DWORD PTR _buffer$[esp+148]
  0038c	76 06		 jbe	 SHORT $LN7@nvsprintf
  0038e	2b f1		 sub	 esi, ecx
  00390	03 f9		 add	 edi, ecx
  00392	eb 06		 jmp	 SHORT $LN14@nvsprintf
$LN7@nvsprintf:
  00394	88 06		 mov	 BYTE PTR [esi], al
  00396	03 f1		 add	 esi, ecx
  00398	2b f9		 sub	 edi, ecx
$LN14@nvsprintf:
  0039a	8b 54 24 2c	 mov	 edx, DWORD PTR _len$1099[esp+152]
  0039e	3b 54 24 20	 cmp	 edx, DWORD PTR _field_width$[esp+152]
  003a2	7c a4		 jl	 SHORT $LL17@nvsprintf
$LN312@nvsprintf:
  003a4	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], edi

; 321  : 
; 322  :         }
; 323  :         status = 0;
; 324  :         continue;

  003ab	e9 6b 05 00 00	 jmp	 $LN324@nvsprintf
$LN170@nvsprintf:

; 172  :         case 's':
; 173  :             goto string_handle;
; 174  :         case 'p':
; 175  :             alphabet    = alphabet_a;

  003b0	bd 00 00 00 00	 mov	 ebp, OFFSET _alphabet_a
$LN169@nvsprintf:

; 176  :         case 'P':
; 177  :             base        = 16;

  003b5	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 178  :             pad         = '0';

  003ba	c6 44 24 1b 30	 mov	 BYTE PTR _pad$[esp+152], 48 ; 00000030H

; 179  :             field_width = sizeof(int) * 2;

  003bf	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR _field_width$[esp+152], 8

; 180  :             goto num_handle;

  003c7	eb 11		 jmp	 SHORT $num_handle$912
$LN168@nvsprintf:

; 181  :         case 'x':
; 182  :             alphabet    = alphabet_a;

  003c9	bd 00 00 00 00	 mov	 ebp, OFFSET _alphabet_a
$LN167@nvsprintf:

; 183  :         case 'X':
; 184  :             base        = 16;

  003ce	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 185  :             goto num_handle;

  003d3	eb 05		 jmp	 SHORT $num_handle$912
$LN166@nvsprintf:

; 186  :         case 'o':
; 187  :             base        = 8;

  003d5	bf 08 00 00 00	 mov	 edi, 8
$num_handle$912:

; 207  :         continue;
; 208  : 
; 209  : num_handle:
; 210  :         switch(qualifier)

  003da	80 f9 4c	 cmp	 cl, 76			; 0000004cH
  003dd	0f 84 3c 02 00
	00		 je	 $LN138@nvsprintf
  003e3	80 f9 68	 cmp	 cl, 104			; 00000068H
  003e6	0f 84 33 02 00
	00		 je	 $LN138@nvsprintf
  003ec	80 f9 6c	 cmp	 cl, 108			; 0000006cH
  003ef	0f 84 2a 02 00
	00		 je	 $LN138@nvsprintf

; 254  :         }
; 255  :             break;
; 256  :         default:
; 257  :         {
; 258  :             uint_t          num     = va_arg(al,uint_t);

  003f5	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR _al$[esp+148]
  003fc	83 c0 04	 add	 eax, 4

; 259  :             int             len     = 0;
; 260  : 
; 261  :             i = MAX_NUM_BUF - 1;
; 262  : 
; 263  :             if( sign && (int)num < 0 )

  003ff	85 db		 test	 ebx, ebx
  00401	89 84 24 a4 00
	00 00		 mov	 DWORD PTR _al$[esp+148], eax
  00408	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  0040b	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  00410	74 0b		 je	 SHORT $LN90@nvsprintf
  00412	85 c0		 test	 eax, eax
  00414	7d 07		 jge	 SHORT $LN90@nvsprintf

; 264  :                 num = ~num + 1;

  00416	f7 d0		 not	 eax
  00418	83 c0 01	 add	 eax, 1

; 265  :             else

  0041b	eb 03		 jmp	 SHORT $LL88@nvsprintf
$LN90@nvsprintf:

; 266  :                 sign = 0;

  0041d	33 db		 xor	 ebx, ebx
  0041f	90		 npad	 1
$LL88@nvsprintf:

; 267  : 
; 268  :             do
; 269  :             {
; 270  :                 num_buf[i--] = alphabet[num % base];

  00420	33 d2		 xor	 edx, edx
  00422	f7 f7		 div	 edi
  00424	83 e9 01	 sub	 ecx, 1

; 271  :                 num /= base;
; 272  :             }while( num );

  00427	85 c0		 test	 eax, eax
  00429	8a 14 2a	 mov	 dl, BYTE PTR [edx+ebp]
  0042c	88 54 0c 49	 mov	 BYTE PTR _num_buf$[esp+ecx+153], dl
  00430	75 ee		 jne	 SHORT $LL88@nvsprintf

; 273  : 
; 274  :             if( sign )

  00432	85 db		 test	 ebx, ebx
  00434	89 4c 24 24	 mov	 DWORD PTR _i$[esp+152], ecx
  00438	74 07		 je	 SHORT $LN243@nvsprintf

; 275  :                 num_buf[i--] = '-';

  0043a	c6 44 0c 48 2d	 mov	 BYTE PTR _num_buf$[esp+ecx+152], 45 ; 0000002dH
  0043f	eb 0c		 jmp	 SHORT $LN325@nvsprintf
$LN243@nvsprintf:

; 276  :             else if( 0 == sign && (flag & FLAG_PLUS) )

  00441	f6 44 24 30 08	 test	 BYTE PTR _flag$[esp+152], 8
  00446	74 0c		 je	 SHORT $LN286@nvsprintf

; 277  :                 num_buf[i--] = '+';

  00448	c6 44 0c 48 2b	 mov	 BYTE PTR _num_buf$[esp+ecx+152], 43 ; 0000002bH
$LN325@nvsprintf:
  0044d	83 e9 01	 sub	 ecx, 1
  00450	89 4c 24 24	 mov	 DWORD PTR _i$[esp+152], ecx
$LN286@nvsprintf:

; 278  :             len = MAX_NUM_BUF - i - 1;
; 279  :             /*
; 280  :              *  处理右对齐
; 281  :              */
; 282  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 283  :             {
; 284  :                 while( len < field_width-- && bufsize > 0 )

  00454	8b 5c 24 20	 mov	 ebx, DWORD PTR _field_width$[esp+152]
  00458	8b ac 24 9c 00
	00 00		 mov	 ebp, DWORD PTR _buffer$[esp+148]
  0045f	8b bc 24 a8 00
	00 00		 mov	 edi, DWORD PTR _bufsize$[esp+148]
  00466	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  0046b	2b d1		 sub	 edx, ecx
  0046d	f6 44 24 30 02	 test	 BYTE PTR _flag$[esp+152], 2
  00472	89 54 24 2c	 mov	 DWORD PTR _len$1038[esp+152], edx
  00476	0f 85 84 00 00
	00		 jne	 $LN80@nvsprintf
  0047c	3b d3		 cmp	 edx, ebx
  0047e	7d 73		 jge	 SHORT $LN235@nvsprintf
  00480	8a 44 24 1b	 mov	 al, BYTE PTR _pad$[esp+152]
  00484	b9 01 00 00 00	 mov	 ecx, 1
  00489	8d a4 24 00 00
	00 00		 npad	 7
$LL81@nvsprintf:
  00490	2b d9		 sub	 ebx, ecx
  00492	85 ff		 test	 edi, edi
  00494	89 5c 24 20	 mov	 DWORD PTR _field_width$[esp+152], ebx
  00498	7e 62		 jle	 SHORT $LN274@nvsprintf

; 285  :                     OUTPUT_CHAR(buf,pad,bufsize);

  0049a	85 f6		 test	 esi, esi
  0049c	75 2e		 jne	 SHORT $LN76@nvsprintf
  0049e	3c 08		 cmp	 al, 8
  004a0	75 06		 jne	 SHORT $LN75@nvsprintf
  004a2	29 4c 24 14	 sub	 DWORD PTR _count$[esp+152], ecx
  004a6	eb 04		 jmp	 SHORT $LN74@nvsprintf
$LN75@nvsprintf:
  004a8	01 4c 24 14	 add	 DWORD PTR _count$[esp+152], ecx
$LN74@nvsprintf:
  004ac	6a 01		 push	 1
  004ae	8d 44 24 1f	 lea	 eax, DWORD PTR _pad$[esp+156]
  004b2	50		 push	 eax
  004b3	6a 00		 push	 0
  004b5	e8 00 00 00 00	 call	 _Tty_write
  004ba	8a 44 24 27	 mov	 al, BYTE PTR _pad$[esp+164]
  004be	8b 54 24 38	 mov	 edx, DWORD PTR _len$1038[esp+164]
  004c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  004c5	b9 01 00 00 00	 mov	 ecx, 1
  004ca	eb 1f		 jmp	 SHORT $LN78@nvsprintf
$LN76@nvsprintf:
  004cc	3c 08		 cmp	 al, 8
  004ce	75 0a		 jne	 SHORT $LN71@nvsprintf
  004d0	3b f5		 cmp	 esi, ebp
  004d2	76 06		 jbe	 SHORT $LN71@nvsprintf
  004d4	2b f1		 sub	 esi, ecx
  004d6	03 f9		 add	 edi, ecx
  004d8	eb 06		 jmp	 SHORT $LN326@nvsprintf
$LN71@nvsprintf:
  004da	88 06		 mov	 BYTE PTR [esi], al
  004dc	03 f1		 add	 esi, ecx
  004de	2b f9		 sub	 edi, ecx
$LN326@nvsprintf:
  004e0	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], edi
  004e7	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
$LN78@nvsprintf:

; 278  :             len = MAX_NUM_BUF - i - 1;
; 279  :             /*
; 280  :              *  处理右对齐
; 281  :              */
; 282  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 283  :             {
; 284  :                 while( len < field_width-- && bufsize > 0 )

  004eb	3b d3		 cmp	 edx, ebx
  004ed	7c a1		 jl	 SHORT $LL81@nvsprintf
  004ef	8b 4c 24 24	 mov	 ecx, DWORD PTR _i$[esp+152]
$LN235@nvsprintf:
  004f3	83 eb 01	 sub	 ebx, 1
  004f6	89 5c 24 20	 mov	 DWORD PTR _field_width$[esp+152], ebx
  004fa	eb 04		 jmp	 SHORT $LN80@nvsprintf
$LN274@nvsprintf:
  004fc	8b 4c 24 24	 mov	 ecx, DWORD PTR _i$[esp+152]
$LN80@nvsprintf:

; 286  :             }
; 287  : 
; 288  :             for( i++ ; i < MAX_NUM_BUF && bufsize > 0 ; i++)

  00500	83 c1 01	 add	 ecx, 1
  00503	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00506	89 4c 24 24	 mov	 DWORD PTR _i$[esp+152], ecx
  0050a	7d 6d		 jge	 SHORT $LN275@nvsprintf
  0050c	8d 64 24 00	 npad	 4
$LL292@nvsprintf:
  00510	85 ff		 test	 edi, edi
  00512	7e 65		 jle	 SHORT $LN275@nvsprintf

; 289  :                 OUTPUT_CHAR(buf,num_buf[i],bufsize);

  00514	85 f6		 test	 esi, esi
  00516	75 2e		 jne	 SHORT $LN63@nvsprintf
  00518	80 7c 0c 48 08	 cmp	 BYTE PTR _num_buf$[esp+ecx+152], 8
  0051d	8d 4c 0c 48	 lea	 ecx, DWORD PTR _num_buf$[esp+ecx+152]
  00521	75 07		 jne	 SHORT $LN62@nvsprintf
  00523	83 6c 24 14 01	 sub	 DWORD PTR _count$[esp+152], 1
  00528	eb 05		 jmp	 SHORT $LN61@nvsprintf
$LN62@nvsprintf:
  0052a	83 44 24 14 01	 add	 DWORD PTR _count$[esp+152], 1
$LN61@nvsprintf:
  0052f	6a 01		 push	 1
  00531	51		 push	 ecx
  00532	6a 00		 push	 0
  00534	e8 00 00 00 00	 call	 _Tty_write
  00539	8b 4c 24 30	 mov	 ecx, DWORD PTR _i$[esp+164]
  0053d	8b 54 24 38	 mov	 edx, DWORD PTR _len$1038[esp+164]
  00541	83 c4 0c	 add	 esp, 12			; 0000000cH
  00544	eb 27		 jmp	 SHORT $LN65@nvsprintf
$LN63@nvsprintf:
  00546	8a 44 0c 48	 mov	 al, BYTE PTR _num_buf$[esp+ecx+152]
  0054a	3c 08		 cmp	 al, 8
  0054c	75 0c		 jne	 SHORT $LN58@nvsprintf
  0054e	3b f5		 cmp	 esi, ebp
  00550	76 08		 jbe	 SHORT $LN58@nvsprintf
  00552	83 ee 01	 sub	 esi, 1
  00555	83 c7 01	 add	 edi, 1
  00558	eb 08		 jmp	 SHORT $LN327@nvsprintf
$LN58@nvsprintf:
  0055a	88 06		 mov	 BYTE PTR [esi], al
  0055c	83 c6 01	 add	 esi, 1
  0055f	83 ef 01	 sub	 edi, 1
$LN327@nvsprintf:
  00562	89 bc 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], edi
  00569	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
$LN65@nvsprintf:
  0056d	83 c1 01	 add	 ecx, 1
  00570	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00573	89 4c 24 24	 mov	 DWORD PTR _i$[esp+152], ecx
  00577	7c 97		 jl	 SHORT $LL292@nvsprintf
$LN275@nvsprintf:

; 290  :                 
; 291  :             while( len < field_width-- && bufsize > 0 )

  00579	3b d3		 cmp	 edx, ebx
  0057b	0f 8d b2 02 00
	00		 jge	 $LN282@nvsprintf
  00581	be 01 00 00 00	 mov	 esi, 1
  00586	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL56@nvsprintf:
  00590	29 74 24 20	 sub	 DWORD PTR _field_width$[esp+152], esi
  00594	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR _bufsize$[esp+148], 0
  0059c	0f 8e 91 02 00
	00		 jle	 $LN282@nvsprintf

; 292  :                 OUTPUT_CHAR(buf,pad_space,bufsize);

  005a2	8b 44 24 1c	 mov	 eax, DWORD PTR _buf$[esp+152]
  005a6	85 c0		 test	 eax, eax
  005a8	75 2c		 jne	 SHORT $LN51@nvsprintf
  005aa	80 7c 24 13 08	 cmp	 BYTE PTR _pad_space$[esp+152], 8
  005af	be 01 00 00 00	 mov	 esi, 1
  005b4	75 06		 jne	 SHORT $LN50@nvsprintf
  005b6	29 74 24 14	 sub	 DWORD PTR _count$[esp+152], esi
  005ba	eb 04		 jmp	 SHORT $LN49@nvsprintf
$LN50@nvsprintf:
  005bc	01 74 24 14	 add	 DWORD PTR _count$[esp+152], esi
$LN49@nvsprintf:
  005c0	56		 push	 esi
  005c1	8d 4c 24 17	 lea	 ecx, DWORD PTR _pad_space$[esp+156]
  005c5	51		 push	 ecx
  005c6	6a 00		 push	 0
  005c8	e8 00 00 00 00	 call	 _Tty_write
  005cd	8b 54 24 38	 mov	 edx, DWORD PTR _len$1038[esp+164]
  005d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  005d4	eb 36		 jmp	 SHORT $LN53@nvsprintf
$LN51@nvsprintf:
  005d6	8a 4c 24 13	 mov	 cl, BYTE PTR _pad_space$[esp+152]
  005da	80 f9 08	 cmp	 cl, 8
  005dd	75 19		 jne	 SHORT $LN46@nvsprintf
  005df	3b 84 24 9c 00
	00 00		 cmp	 eax, DWORD PTR _buffer$[esp+148]
  005e6	76 10		 jbe	 SHORT $LN46@nvsprintf
  005e8	be 01 00 00 00	 mov	 esi, 1
  005ed	2b c6		 sub	 eax, esi
  005ef	01 b4 24 a8 00
	00 00		 add	 DWORD PTR _bufsize$[esp+148], esi
  005f6	eb 10		 jmp	 SHORT $LN328@nvsprintf
$LN46@nvsprintf:
  005f8	be 01 00 00 00	 mov	 esi, 1
  005fd	88 08		 mov	 BYTE PTR [eax], cl
  005ff	03 c6		 add	 eax, esi
  00601	29 b4 24 a8 00
	00 00		 sub	 DWORD PTR _bufsize$[esp+148], esi
$LN328@nvsprintf:
  00608	89 44 24 1c	 mov	 DWORD PTR _buf$[esp+152], eax
$LN53@nvsprintf:

; 290  :                 
; 291  :             while( len < field_width-- && bufsize > 0 )

  0060c	3b 54 24 20	 cmp	 edx, DWORD PTR _field_width$[esp+152]
  00610	0f 8c 7a ff ff
	ff		 jl	 $LL56@nvsprintf

; 293  :         }
; 294  :             break;
; 295  :         }
; 296  :         status = 0;
; 297  :         continue;

  00616	8b 74 24 1c	 mov	 esi, DWORD PTR _buf$[esp+152]
  0061a	e9 00 03 00 00	 jmp	 $LN149@nvsprintf
$LN138@nvsprintf:

; 211  :         {
; 212  :         case 'h':
; 213  :         case 'l':
; 214  :         case 'L':
; 215  :         {
; 216  :             /*
; 217  :              *  处理长格式数字
; 218  :              */
; 219  :             ularge_t        num     = va_arg(al,ularge_t);

  0061f	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR _al$[esp+148]
  00626	8b 01		 mov	 eax, DWORD PTR [ecx]
  00628	83 c1 08	 add	 ecx, 8

; 220  :             int             len     = 0;
; 221  :             
; 222  :             i = MAX_NUM_BUF - 1;
; 223  :             if( sign && (large_t)num < 0 )

  0062b	33 d2		 xor	 edx, edx
  0062d	3b da		 cmp	 ebx, edx
  0062f	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR _al$[esp+148], ecx
  00636	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]
  00639	be 4f 00 00 00	 mov	 esi, 79			; 0000004fH
  0063e	74 15		 je	 SHORT $LN137@nvsprintf
  00640	3b ca		 cmp	 ecx, edx
  00642	7f 11		 jg	 SHORT $LN137@nvsprintf
  00644	7c 04		 jl	 SHORT $LN262@nvsprintf
  00646	3b c2		 cmp	 eax, edx
  00648	73 0b		 jae	 SHORT $LN137@nvsprintf
$LN262@nvsprintf:

; 224  :                 num = ~num + 1;

  0064a	f7 d0		 not	 eax
  0064c	f7 d1		 not	 ecx
  0064e	83 c0 01	 add	 eax, 1
  00651	13 ca		 adc	 ecx, edx

; 225  :             else

  00653	eb 04		 jmp	 SHORT $LN256@nvsprintf
$LN137@nvsprintf:

; 226  :                 sign = 0;

  00655	89 54 24 2c	 mov	 DWORD PTR _sign$[esp+152], edx
$LN256@nvsprintf:

; 233  : 
; 234  :             if( sign )

  00659	89 54 24 44	 mov	 DWORD PTR tv673[esp+156], edx
  0065d	8d 49 00	 npad	 3
$LL135@nvsprintf:

; 227  : 
; 228  :             do
; 229  :             {
; 230  :                 num_buf[i--] = alphabet[num % base];

  00660	8b 54 24 44	 mov	 edx, DWORD PTR tv673[esp+156]
  00664	52		 push	 edx
  00665	57		 push	 edi
  00666	51		 push	 ecx
  00667	50		 push	 eax
  00668	e8 00 00 00 00	 call	 __aulldvrm
  0066d	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  00670	88 4c 34 48	 mov	 BYTE PTR _num_buf$[esp+esi+152], cl

; 231  :                 num /= base;

  00674	8b ca		 mov	 ecx, edx

; 232  :             }while( num );

  00676	8b d0		 mov	 edx, eax
  00678	83 ee 01	 sub	 esi, 1
  0067b	0b d1		 or	 edx, ecx
  0067d	89 5c 24 3c	 mov	 DWORD PTR tv943[esp+156], ebx
  00681	75 dd		 jne	 SHORT $LL135@nvsprintf

; 233  : 
; 234  :             if( sign )

  00683	83 7c 24 2c 00	 cmp	 DWORD PTR _sign$[esp+152], 0
  00688	89 74 24 24	 mov	 DWORD PTR _i$[esp+152], esi
  0068c	74 07		 je	 SHORT $LN242@nvsprintf

; 235  :                 num_buf[i--] = '-';

  0068e	c6 44 34 48 2d	 mov	 BYTE PTR _num_buf$[esp+esi+152], 45 ; 0000002dH
  00693	eb 0c		 jmp	 SHORT $LN329@nvsprintf
$LN242@nvsprintf:

; 236  :             else if( 0 == sign && (flag & FLAG_PLUS) )

  00695	f6 44 24 30 08	 test	 BYTE PTR _flag$[esp+152], 8
  0069a	74 0c		 je	 SHORT $LN283@nvsprintf

; 237  :                 num_buf[i--] = '+';

  0069c	c6 44 34 48 2b	 mov	 BYTE PTR _num_buf$[esp+esi+152], 43 ; 0000002bH
$LN329@nvsprintf:
  006a1	83 ee 01	 sub	 esi, 1
  006a4	89 74 24 24	 mov	 DWORD PTR _i$[esp+152], esi
$LN283@nvsprintf:

; 238  : 
; 239  :             len = MAX_NUM_BUF - i - 1;
; 240  :             /*
; 241  :              *  处理右对齐
; 242  :              */
; 243  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 244  :             {
; 245  :                 while( len < field_width-- && bufsize > 0 )

  006a8	8b 6c 24 20	 mov	 ebp, DWORD PTR _field_width$[esp+152]
  006ac	8b 9c 24 a8 00
	00 00		 mov	 ebx, DWORD PTR _bufsize$[esp+148]
  006b3	8b 7c 24 1c	 mov	 edi, DWORD PTR _buf$[esp+152]
  006b7	b9 4f 00 00 00	 mov	 ecx, 79			; 0000004fH
  006bc	2b ce		 sub	 ecx, esi
  006be	f6 44 24 30 02	 test	 BYTE PTR _flag$[esp+152], 2
  006c3	89 4c 24 2c	 mov	 DWORD PTR _len$976[esp+152], ecx
  006c7	75 7d		 jne	 SHORT $LN285@nvsprintf
  006c9	3b cd		 cmp	 ecx, ebp
  006cb	7d 6a		 jge	 SHORT $LN238@nvsprintf
  006cd	8d 49 00	 npad	 3
$LL128@nvsprintf:
  006d0	ba 01 00 00 00	 mov	 edx, 1
  006d5	2b ea		 sub	 ebp, edx
  006d7	85 db		 test	 ebx, ebx
  006d9	7e 65		 jle	 SHORT $LN276@nvsprintf

; 246  :                     OUTPUT_CHAR(buf,pad,bufsize);

  006db	85 ff		 test	 edi, edi
  006dd	75 28		 jne	 SHORT $LN123@nvsprintf
  006df	80 7c 24 1b 08	 cmp	 BYTE PTR _pad$[esp+152], 8
  006e4	75 06		 jne	 SHORT $LN122@nvsprintf
  006e6	29 54 24 14	 sub	 DWORD PTR _count$[esp+152], edx
  006ea	eb 04		 jmp	 SHORT $LN121@nvsprintf
$LN122@nvsprintf:
  006ec	01 54 24 14	 add	 DWORD PTR _count$[esp+152], edx
$LN121@nvsprintf:
  006f0	6a 01		 push	 1
  006f2	8d 44 24 1f	 lea	 eax, DWORD PTR _pad$[esp+156]
  006f6	50		 push	 eax
  006f7	6a 00		 push	 0
  006f9	e8 00 00 00 00	 call	 _Tty_write
  006fe	8b 4c 24 38	 mov	 ecx, DWORD PTR _len$976[esp+164]
  00702	83 c4 0c	 add	 esp, 12			; 0000000cH
  00705	eb 28		 jmp	 SHORT $LN125@nvsprintf
$LN123@nvsprintf:
  00707	8a 44 24 1b	 mov	 al, BYTE PTR _pad$[esp+152]
  0070b	3c 08		 cmp	 al, 8
  0070d	75 0f		 jne	 SHORT $LN118@nvsprintf
  0070f	3b bc 24 9c 00
	00 00		 cmp	 edi, DWORD PTR _buffer$[esp+148]
  00716	76 06		 jbe	 SHORT $LN118@nvsprintf
  00718	2b fa		 sub	 edi, edx
  0071a	03 da		 add	 ebx, edx
  0071c	eb 06		 jmp	 SHORT $LN330@nvsprintf
$LN118@nvsprintf:
  0071e	88 07		 mov	 BYTE PTR [edi], al
  00720	03 fa		 add	 edi, edx
  00722	2b da		 sub	 ebx, edx
$LN330@nvsprintf:
  00724	89 9c 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], ebx
  0072b	89 7c 24 1c	 mov	 DWORD PTR _buf$[esp+152], edi
$LN125@nvsprintf:

; 238  : 
; 239  :             len = MAX_NUM_BUF - i - 1;
; 240  :             /*
; 241  :              *  处理右对齐
; 242  :              */
; 243  :             if( !(flag & FLAG_LEFT_ALIGN) )
; 244  :             {
; 245  :                 while( len < field_width-- && bufsize > 0 )

  0072f	3b cd		 cmp	 ecx, ebp
  00731	7c 9d		 jl	 SHORT $LL128@nvsprintf
  00733	8b 74 24 24	 mov	 esi, DWORD PTR _i$[esp+152]
$LN238@nvsprintf:
  00737	ba 01 00 00 00	 mov	 edx, 1
  0073c	2b ea		 sub	 ebp, edx
  0073e	eb 0b		 jmp	 SHORT $LN127@nvsprintf
$LN276@nvsprintf:
  00740	8b 74 24 24	 mov	 esi, DWORD PTR _i$[esp+152]
  00744	eb 05		 jmp	 SHORT $LN127@nvsprintf
$LN285@nvsprintf:
  00746	ba 01 00 00 00	 mov	 edx, 1
$LN127@nvsprintf:

; 247  :             }
; 248  : 
; 249  :             for( i++ ; i < MAX_NUM_BUF && bufsize > 0 ; i++)

  0074b	03 f2		 add	 esi, edx
  0074d	83 fe 50	 cmp	 esi, 80			; 00000050H
  00750	89 74 24 24	 mov	 DWORD PTR _i$[esp+152], esi
  00754	7d 70		 jge	 SHORT $LN277@nvsprintf
$LL299@nvsprintf:
  00756	85 db		 test	 ebx, ebx
  00758	7e 6c		 jle	 SHORT $LN277@nvsprintf

; 250  :                 OUTPUT_CHAR(buf,num_buf[i],bufsize);

  0075a	85 ff		 test	 edi, edi
  0075c	75 2c		 jne	 SHORT $LN110@nvsprintf
  0075e	80 7c 34 48 08	 cmp	 BYTE PTR _num_buf$[esp+esi+152], 8
  00763	8d 74 34 48	 lea	 esi, DWORD PTR _num_buf$[esp+esi+152]
  00767	75 06		 jne	 SHORT $LN109@nvsprintf
  00769	29 54 24 14	 sub	 DWORD PTR _count$[esp+152], edx
  0076d	eb 04		 jmp	 SHORT $LN108@nvsprintf
$LN109@nvsprintf:
  0076f	01 54 24 14	 add	 DWORD PTR _count$[esp+152], edx
$LN108@nvsprintf:
  00773	6a 01		 push	 1
  00775	56		 push	 esi
  00776	6a 00		 push	 0
  00778	e8 00 00 00 00	 call	 _Tty_write
  0077d	8b 74 24 30	 mov	 esi, DWORD PTR _i$[esp+164]
  00781	8b 4c 24 38	 mov	 ecx, DWORD PTR _len$976[esp+164]
  00785	83 c4 0c	 add	 esp, 12			; 0000000cH
  00788	eb 2c		 jmp	 SHORT $LN112@nvsprintf
$LN110@nvsprintf:
  0078a	8a 44 34 48	 mov	 al, BYTE PTR _num_buf$[esp+esi+152]
  0078e	3c 08		 cmp	 al, 8
  00790	75 11		 jne	 SHORT $LN293@nvsprintf
  00792	3b bc 24 9c 00
	00 00		 cmp	 edi, DWORD PTR _buffer$[esp+148]
  00799	76 08		 jbe	 SHORT $LN293@nvsprintf
  0079b	83 ef 01	 sub	 edi, 1
  0079e	83 c3 01	 add	 ebx, 1
  007a1	eb 08		 jmp	 SHORT $LN331@nvsprintf
$LN293@nvsprintf:
  007a3	88 07		 mov	 BYTE PTR [edi], al
  007a5	83 c7 01	 add	 edi, 1
  007a8	83 eb 01	 sub	 ebx, 1
$LN331@nvsprintf:
  007ab	89 9c 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], ebx
  007b2	89 7c 24 1c	 mov	 DWORD PTR _buf$[esp+152], edi
$LN112@nvsprintf:
  007b6	ba 01 00 00 00	 mov	 edx, 1
  007bb	03 f2		 add	 esi, edx
  007bd	83 fe 50	 cmp	 esi, 80			; 00000050H
  007c0	89 74 24 24	 mov	 DWORD PTR _i$[esp+152], esi
  007c4	7c 90		 jl	 SHORT $LL299@nvsprintf
$LN277@nvsprintf:

; 251  :                 
; 252  :             while( len < field_width-- && bufsize > 0 )

  007c6	3b cd		 cmp	 ecx, ebp
  007c8	7d 69		 jge	 SHORT $LN282@nvsprintf
  007ca	eb 09		 jmp	 SHORT $LN103@nvsprintf
  007cc	8d 64 24 00	 npad	 4
$LL300@nvsprintf:
  007d0	ba 01 00 00 00	 mov	 edx, 1
$LN103@nvsprintf:
  007d5	2b ea		 sub	 ebp, edx
  007d7	85 db		 test	 ebx, ebx
  007d9	7e 4d		 jle	 SHORT $LN314@nvsprintf

; 253  :                 OUTPUT_CHAR(buf,pad_space,bufsize);

  007db	85 ff		 test	 edi, edi
  007dd	75 28		 jne	 SHORT $LN98@nvsprintf
  007df	80 7c 24 13 08	 cmp	 BYTE PTR _pad_space$[esp+152], 8
  007e4	75 06		 jne	 SHORT $LN97@nvsprintf
  007e6	29 54 24 14	 sub	 DWORD PTR _count$[esp+152], edx
  007ea	eb 04		 jmp	 SHORT $LN96@nvsprintf
$LN97@nvsprintf:
  007ec	01 54 24 14	 add	 DWORD PTR _count$[esp+152], edx
$LN96@nvsprintf:
  007f0	6a 01		 push	 1
  007f2	8d 4c 24 17	 lea	 ecx, DWORD PTR _pad_space$[esp+156]
  007f6	51		 push	 ecx
  007f7	6a 00		 push	 0
  007f9	e8 00 00 00 00	 call	 _Tty_write
  007fe	8b 4c 24 38	 mov	 ecx, DWORD PTR _len$976[esp+164]
  00802	83 c4 0c	 add	 esp, 12			; 0000000cH
  00805	eb 1d		 jmp	 SHORT $LN100@nvsprintf
$LN98@nvsprintf:
  00807	8a 44 24 13	 mov	 al, BYTE PTR _pad_space$[esp+152]
  0080b	3c 08		 cmp	 al, 8
  0080d	75 0f		 jne	 SHORT $LN93@nvsprintf
  0080f	3b bc 24 9c 00
	00 00		 cmp	 edi, DWORD PTR _buffer$[esp+148]
  00816	76 06		 jbe	 SHORT $LN93@nvsprintf
  00818	2b fa		 sub	 edi, edx
  0081a	03 da		 add	 ebx, edx
  0081c	eb 06		 jmp	 SHORT $LN100@nvsprintf
$LN93@nvsprintf:
  0081e	88 07		 mov	 BYTE PTR [edi], al
  00820	03 fa		 add	 edi, edx
  00822	2b da		 sub	 ebx, edx
$LN100@nvsprintf:

; 251  :                 
; 252  :             while( len < field_width-- && bufsize > 0 )

  00824	3b cd		 cmp	 ecx, ebp
  00826	7c a8		 jl	 SHORT $LL300@nvsprintf
$LN314@nvsprintf:

; 253  :                 OUTPUT_CHAR(buf,pad_space,bufsize);

  00828	89 7c 24 1c	 mov	 DWORD PTR _buf$[esp+152], edi
  0082c	89 9c 24 a8 00
	00 00		 mov	 DWORD PTR _bufsize$[esp+148], ebx
$LN282@nvsprintf:

; 293  :         }
; 294  :             break;
; 295  :         }
; 296  :         status = 0;
; 297  :         continue;

  00833	8b 74 24 1c	 mov	 esi, DWORD PTR _buf$[esp+152]
  00837	e9 e3 00 00 00	 jmp	 $LN149@nvsprintf
$LN164@nvsprintf:

; 188  :             goto num_handle;
; 189  :             
; 190  :         case 'f':
; 191  :             goto float_handle;
; 192  : 
; 193  :         case 'C':
; 194  :             upcase = 1;

  0083c	b9 01 00 00 00	 mov	 ecx, 1
  00841	8b d1		 mov	 edx, ecx
  00843	eb 05		 jmp	 SHORT $LN163@nvsprintf
$LN289@nvsprintf:
  00845	b9 01 00 00 00	 mov	 ecx, 1
$LN163@nvsprintf:

; 195  :         case 'c':
; 196  :             i = va_arg(al,char);

  0084a	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR _al$[esp+148]
  00851	83 c0 04	 add	 eax, 4

; 197  :             if( upcase )

  00854	85 d2		 test	 edx, edx
  00856	89 84 24 a4 00
	00 00		 mov	 DWORD PTR _al$[esp+148], eax
  0085d	0f be 40 fc	 movsx	 eax, BYTE PTR [eax-4]
  00861	89 44 24 24	 mov	 DWORD PTR _i$[esp+152], eax
  00865	74 15		 je	 SHORT $LN161@nvsprintf

; 198  :                 i = _up_case((char)i);

  00867	50		 push	 eax
  00868	e8 00 00 00 00	 call	 __up_case
  0086d	0f be c0	 movsx	 eax, al
  00870	83 c4 04	 add	 esp, 4
  00873	89 44 24 24	 mov	 DWORD PTR _i$[esp+152], eax
  00877	b9 01 00 00 00	 mov	 ecx, 1
$LN161@nvsprintf:

; 199  :             OUTPUT_CHAR(buf,(char)i,bufsize);

  0087c	85 f6		 test	 esi, esi
  0087e	75 21		 jne	 SHORT $LN158@nvsprintf
  00880	3c 08		 cmp	 al, 8
  00882	75 06		 jne	 SHORT $LN157@nvsprintf
  00884	29 4c 24 14	 sub	 DWORD PTR _count$[esp+152], ecx
  00888	eb 04		 jmp	 SHORT $LN156@nvsprintf
$LN157@nvsprintf:
  0088a	01 4c 24 14	 add	 DWORD PTR _count$[esp+152], ecx
$LN156@nvsprintf:
  0088e	6a 01		 push	 1
  00890	8d 54 24 28	 lea	 edx, DWORD PTR _i$[esp+156]
  00894	52		 push	 edx
  00895	6a 00		 push	 0
  00897	e8 00 00 00 00	 call	 _Tty_write
  0089c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0089f	eb 7e		 jmp	 SHORT $LN149@nvsprintf
$LN158@nvsprintf:
  008a1	3c 08		 cmp	 al, 8
  008a3	75 14		 jne	 SHORT $LN153@nvsprintf
  008a5	3b b4 24 9c 00
	00 00		 cmp	 esi, DWORD PTR _buffer$[esp+148]
  008ac	76 0b		 jbe	 SHORT $LN153@nvsprintf
  008ae	2b f1		 sub	 esi, ecx
  008b0	01 8c 24 a8 00
	00 00		 add	 DWORD PTR _bufsize$[esp+148], ecx
  008b7	eb 62		 jmp	 SHORT $LN324@nvsprintf
$LN153@nvsprintf:
  008b9	88 06		 mov	 BYTE PTR [esi], al
  008bb	03 f1		 add	 esi, ecx
  008bd	29 8c 24 a8 00
	00 00		 sub	 DWORD PTR _bufsize$[esp+148], ecx

; 200  :             break;

  008c4	eb 55		 jmp	 SHORT $LN324@nvsprintf
$LN150@nvsprintf:

; 201  :         default:
; 202  :             OUTPUT_CHAR(buf,c,bufsize);

  008c6	85 f6		 test	 esi, esi
  008c8	75 26		 jne	 SHORT $LN147@nvsprintf
  008ca	80 7c 24 2b 08	 cmp	 BYTE PTR _c$870[esp+152], 8
  008cf	75 07		 jne	 SHORT $LN146@nvsprintf
  008d1	83 6c 24 14 01	 sub	 DWORD PTR _count$[esp+152], 1
  008d6	eb 05		 jmp	 SHORT $LN145@nvsprintf
$LN146@nvsprintf:
  008d8	83 44 24 14 01	 add	 DWORD PTR _count$[esp+152], 1
$LN145@nvsprintf:
  008dd	6a 01		 push	 1
  008df	8d 44 24 2f	 lea	 eax, DWORD PTR _c$870[esp+156]
  008e3	50		 push	 eax
  008e4	6a 00		 push	 0
  008e6	e8 00 00 00 00	 call	 _Tty_write
  008eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  008ee	eb 2f		 jmp	 SHORT $LN149@nvsprintf
$LN147@nvsprintf:
  008f0	8a 44 24 2b	 mov	 al, BYTE PTR _c$870[esp+152]
  008f4	3c 08		 cmp	 al, 8
  008f6	75 16		 jne	 SHORT $LN142@nvsprintf
  008f8	3b b4 24 9c 00
	00 00		 cmp	 esi, DWORD PTR _buffer$[esp+148]
  008ff	76 0d		 jbe	 SHORT $LN142@nvsprintf
  00901	83 ee 01	 sub	 esi, 1
  00904	83 84 24 a8 00
	00 00 01	 add	 DWORD PTR _bufsize$[esp+148], 1
  0090c	eb 0d		 jmp	 SHORT $LN324@nvsprintf
$LN142@nvsprintf:
  0090e	88 06		 mov	 BYTE PTR [esi], al
  00910	83 c6 01	 add	 esi, 1
  00913	83 ac 24 a8 00
	00 00 01	 sub	 DWORD PTR _bufsize$[esp+148], 1
$LN324@nvsprintf:
  0091b	89 74 24 1c	 mov	 DWORD PTR _buf$[esp+152], esi
$LN149@nvsprintf:

; 203  :             break;
; 204  :         }
; 205  : 
; 206  :         status = 0;

  0091f	8b 9c 24 a0 00
	00 00		 mov	 ebx, DWORD PTR _fmt$[esp+148]
$float_handle$924:
  00926	33 ff		 xor	 edi, edi
$LN210@nvsprintf:
  00928	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  0092b	8b ac 24 9c 00
	00 00		 mov	 ebp, DWORD PTR _buffer$[esp+148]
  00932	83 c3 01	 add	 ebx, 1
  00935	84 c0		 test	 al, al
  00937	89 9c 24 a0 00
	00 00		 mov	 DWORD PTR _fmt$[esp+148], ebx
  0093e	0f 85 0d f7 ff
	ff		 jne	 $LL211@nvsprintf
$LN295@nvsprintf:

; 325  : float_handle:
; 326  :         switch(qualifier)
; 327  :         {
; 328  :         case 'h':
; 329  :         case 'l':
; 330  :         case 'L':
; 331  :         {
; 332  :             /*
; 333  :              *  处理双精度
; 334  :              */
; 335  :         }
; 336  :         break;
; 337  :         default:
; 338  :         {
; 339  :             /*
; 340  :              *  处理单精度
; 341  :              */
; 342  :         }
; 343  :             break;
; 344  :         }
; 345  :         status = 0;
; 346  :         continue;
; 347  :     }
; 348  : 
; 349  :     if( buffer ) 

  00944	85 ed		 test	 ebp, ebp
  00946	74 12		 je	 SHORT $LN1@nvsprintf
  00948	5f		 pop	 edi

; 350  :     {
; 351  :         *buf = 0;
; 352  :         return buf - buffer;

  00949	8b c6		 mov	 eax, esi
  0094b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0094e	5e		 pop	 esi
  0094f	2b c5		 sub	 eax, ebp
  00951	5d		 pop	 ebp
  00952	5b		 pop	 ebx

; 355  : }

  00953	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00959	c3		 ret	 0
$LN1@nvsprintf:

; 353  :     }
; 354  :     return count;

  0095a	8b 44 24 14	 mov	 eax, DWORD PTR _count$[esp+152]
  0095e	5f		 pop	 edi
  0095f	5e		 pop	 esi
  00960	5d		 pop	 ebp
  00961	5b		 pop	 ebx

; 355  : }

  00962	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00968	c3		 ret	 0
  00969	8d 49 00	 npad	 3
$LN332@nvsprintf:
  0096c	00 00 00 00	 DD	 $LN188@nvsprintf
  00970	00 00 00 00	 DD	 $LN187@nvsprintf
  00974	00 00 00 00	 DD	 $LN189@nvsprintf
  00978	00 00 00 00	 DD	 $LN190@nvsprintf
  0097c	00 00 00 00	 DD	 $LN304@nvsprintf
$LN260@nvsprintf:
  00980	00		 DB	 0
  00981	04		 DB	 4
  00982	04		 DB	 4
  00983	04		 DB	 4
  00984	04		 DB	 4
  00985	04		 DB	 4
  00986	04		 DB	 4
  00987	04		 DB	 4
  00988	04		 DB	 4
  00989	04		 DB	 4
  0098a	04		 DB	 4
  0098b	01		 DB	 1
  0098c	04		 DB	 4
  0098d	02		 DB	 2
  0098e	04		 DB	 4
  0098f	04		 DB	 4
  00990	03		 DB	 3
  00991	8d 49 00	 npad	 3
$LN333@nvsprintf:
  00994	00 00 00 00	 DD	 $LN164@nvsprintf
  00998	00 00 00 00	 DD	 $LN169@nvsprintf
  0099c	00 00 00 00	 DD	 $LN172@nvsprintf
  009a0	00 00 00 00	 DD	 $LN167@nvsprintf
  009a4	00 00 00 00	 DD	 $LN289@nvsprintf
  009a8	00 00 00 00	 DD	 $LN174@nvsprintf
  009ac	00 00 00 00	 DD	 $LN149@nvsprintf
  009b0	00 00 00 00	 DD	 $LN166@nvsprintf
  009b4	00 00 00 00	 DD	 $LN170@nvsprintf
  009b8	00 00 00 00	 DD	 $string_handle$916
  009bc	00 00 00 00	 DD	 $num_handle$912
  009c0	00 00 00 00	 DD	 $LN168@nvsprintf
  009c4	00 00 00 00	 DD	 $LN150@nvsprintf
$LN261@nvsprintf:
  009c8	00		 DB	 0
  009c9	0c		 DB	 12			; 0000000cH
  009ca	0c		 DB	 12			; 0000000cH
  009cb	0c		 DB	 12			; 0000000cH
  009cc	0c		 DB	 12			; 0000000cH
  009cd	0c		 DB	 12			; 0000000cH
  009ce	0c		 DB	 12			; 0000000cH
  009cf	0c		 DB	 12			; 0000000cH
  009d0	0c		 DB	 12			; 0000000cH
  009d1	0c		 DB	 12			; 0000000cH
  009d2	0c		 DB	 12			; 0000000cH
  009d3	0c		 DB	 12			; 0000000cH
  009d4	0c		 DB	 12			; 0000000cH
  009d5	01		 DB	 1
  009d6	0c		 DB	 12			; 0000000cH
  009d7	0c		 DB	 12			; 0000000cH
  009d8	02		 DB	 2
  009d9	0c		 DB	 12			; 0000000cH
  009da	0c		 DB	 12			; 0000000cH
  009db	0c		 DB	 12			; 0000000cH
  009dc	0c		 DB	 12			; 0000000cH
  009dd	03		 DB	 3
  009de	0c		 DB	 12			; 0000000cH
  009df	0c		 DB	 12			; 0000000cH
  009e0	0c		 DB	 12			; 0000000cH
  009e1	0c		 DB	 12			; 0000000cH
  009e2	0c		 DB	 12			; 0000000cH
  009e3	0c		 DB	 12			; 0000000cH
  009e4	0c		 DB	 12			; 0000000cH
  009e5	0c		 DB	 12			; 0000000cH
  009e6	0c		 DB	 12			; 0000000cH
  009e7	0c		 DB	 12			; 0000000cH
  009e8	04		 DB	 4
  009e9	05		 DB	 5
  009ea	0c		 DB	 12			; 0000000cH
  009eb	06		 DB	 6
  009ec	0c		 DB	 12			; 0000000cH
  009ed	0c		 DB	 12			; 0000000cH
  009ee	05		 DB	 5
  009ef	0c		 DB	 12			; 0000000cH
  009f0	0c		 DB	 12			; 0000000cH
  009f1	0c		 DB	 12			; 0000000cH
  009f2	0c		 DB	 12			; 0000000cH
  009f3	0c		 DB	 12			; 0000000cH
  009f4	07		 DB	 7
  009f5	08		 DB	 8
  009f6	0c		 DB	 12			; 0000000cH
  009f7	0c		 DB	 12			; 0000000cH
  009f8	09		 DB	 9
  009f9	0c		 DB	 12			; 0000000cH
  009fa	0a		 DB	 10			; 0000000aH
  009fb	0c		 DB	 12			; 0000000cH
  009fc	0c		 DB	 12			; 0000000cH
  009fd	0b		 DB	 11			; 0000000bH
__nvsprintf ENDP
_TEXT	ENDS
PUBLIC	__sprintf
; Function compile flags: /Ogtpy
;	COMDAT __sprintf
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_fmt$ = 12						; size = 4
__sprintf PROC						; COMDAT

; 359  :     va_list                 vl      = (va_list)0;
; 360  :     int                     len     = 0;;
; 361  :     va_start(vl,fmt);
; 362  : 
; 363  :     len = _nvsprintf(buffer,fmt,vl,INT_MAX);

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _fmt$[esp-4]
  00004	8b 54 24 04	 mov	 edx, DWORD PTR _buffer$[esp-4]
  00008	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  0000d	8d 44 24 10	 lea	 eax, DWORD PTR _fmt$[esp+4]
  00011	50		 push	 eax
  00012	51		 push	 ecx
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 __nvsprintf
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 364  : 
; 365  :     va_end(vl);
; 366  : 
; 367  :     return len;
; 368  : }

  0001c	c3		 ret	 0
__sprintf ENDP
_TEXT	ENDS
PUBLIC	__printf
; Function compile flags: /Ogtpy
;	COMDAT __printf
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
__printf PROC						; COMDAT

; 372  :     va_list                 vl      = (va_list)0;
; 373  :     int                     len     = 0;;
; 374  : 
; 375  :     va_start(vl,fmt);
; 376  : 
; 377  :     len = _nvsprintf(NULL,fmt,vl,INT_MAX);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _fmt$[esp-4]
  00004	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  00009	8d 44 24 0c	 lea	 eax, DWORD PTR _fmt$[esp+4]
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	6a 00		 push	 0
  00011	e8 00 00 00 00	 call	 __nvsprintf
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 378  : 
; 379  :     va_end(vl);
; 380  : 
; 381  :     return len;
; 382  : }

  00019	c3		 ret	 0
__printf ENDP
_TEXT	ENDS
PUBLIC	__printk
EXTRN	_Con_print_string:PROC
_BSS	SEGMENT
?buf@?1??_printk@@9@9 DB 0400H DUP (?)			; `_printk'::`2'::buf
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT __printk
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
__printk PROC						; COMDAT

; 400  :     static char             buf[1024];
; 401  :     va_list                 vl      = (va_list)0;
; 402  :     int                     len     = 0;;
; 403  : 
; 404  :     va_start(vl,fmt);
; 405  :     len = _nvsprintf(buf,fmt,vl,1024);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _fmt$[esp-4]
  00004	56		 push	 esi
  00005	68 00 04 00 00	 push	 1024			; 00000400H
  0000a	8d 44 24 10	 lea	 eax, DWORD PTR _fmt$[esp+8]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	68 00 00 00 00	 push	 OFFSET ?buf@?1??_printk@@9@9
  00015	e8 00 00 00 00	 call	 __nvsprintf

; 406  :     va_end(vl);
; 407  :     Con_print_string(buf);

  0001a	68 00 00 00 00	 push	 OFFSET ?buf@?1??_printk@@9@9
  0001f	8b f0		 mov	 esi, eax
  00021	e8 00 00 00 00	 call	 _Con_print_string
  00026	83 c4 14	 add	 esp, 20			; 00000014H

; 408  : 
; 409  :     return len;

  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi

; 410  : }

  0002c	c3		 ret	 0
__printk ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_03NDEAONJP@?5?5?5?$AA@			; `string'
PUBLIC	??_C@_05BFHEBJNP@?$CF02X?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_02KFKPNHPM@?9?5?$AA@			; `string'
PUBLIC	??_C@_04EHIJODNA@?$CFP?3?5?$AA@			; `string'
PUBLIC	__mprintf
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDEAONJP@?5?5?5?$AA@
CONST	SEGMENT
??_C@_03NDEAONJP@?5?5?5?$AA@ DB '   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BFHEBJNP@?$CF02X?5?$AA@
CONST	SEGMENT
??_C@_05BFHEBJNP@?$CF02X?5?$AA@ DB '%02X ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFKPNHPM@?9?5?$AA@
CONST	SEGMENT
??_C@_02KFKPNHPM@?9?5?$AA@ DB '- ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHIJODNA@?$CFP?3?5?$AA@
CONST	SEGMENT
??_C@_04EHIJODNA@?$CFP?3?5?$AA@ DB '%P: ', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT __mprintf
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
__mprintf PROC						; COMDAT

; 414  : {

  00000	53		 push	 ebx

; 415  :     const char          *   m   = (void *)((int)mem & ~0xF);
; 416  :     int                     i   = 0;
; 417  :     int                     n   = 0;
; 418  :     size += (int)mem & 0xF;

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _size$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR _mem$[esp+4]
  0000a	57		 push	 edi
  0000b	8b c5		 mov	 eax, ebp
  0000d	8b fd		 mov	 edi, ebp
  0000f	83 e0 0f	 and	 eax, 15			; 0000000fH
  00012	83 e7 f0	 and	 edi, -16		; fffffff0H
  00015	03 d8		 add	 ebx, eax
  00017	89 5c 24 14	 mov	 DWORD PTR _size$[esp+8], ebx

; 419  :     while( size  )

  0001b	0f 84 e8 00 00
	00		 je	 $LN17@mprintf
  00021	56		 push	 esi
  00022	eb 04		 jmp	 SHORT $LN18@mprintf
$LL27@mprintf:
  00024	8b 5c 24 18	 mov	 ebx, DWORD PTR _size$[esp+12]
$LN18@mprintf:

; 420  :     {
; 421  :         n = size;
; 422  :         if( n > 16 )

  00028	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0002b	7e 05		 jle	 SHORT $LN16@mprintf

; 423  :             n = 16;

  0002d	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
$LN16@mprintf:

; 424  : 
; 425  :         _printf("%P: ",m);

  00032	57		 push	 edi
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_04EHIJODNA@?$CFP?3?5?$AA@
  00038	e8 00 00 00 00	 call	 __printf
  0003d	83 c4 08	 add	 esp, 8

; 426  :         /*
; 427  :          *  显示16进制数
; 428  :          */
; 429  :         for( i = 0 ; i < 16 ; i++)

  00040	33 f6		 xor	 esi, esi
$LL28@mprintf:

; 430  :         {
; 431  :             if( i && 0 == (i % 8 ))

  00042	85 f6		 test	 esi, esi
  00044	74 28		 je	 SHORT $LN10@mprintf
  00046	f7 c6 07 00 00
	00		 test	 esi, 7
  0004c	75 20		 jne	 SHORT $LN10@mprintf

; 432  :             {
; 433  :                 if( n > 8 && (m + i) >= (const char *)mem)

  0004e	83 fb 08	 cmp	 ebx, 8
  00051	7e 0e		 jle	 SHORT $LN11@mprintf
  00053	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00056	3b cd		 cmp	 ecx, ebp
  00058	72 07		 jb	 SHORT $LN11@mprintf

; 434  :                     _printf("- ");

  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_02KFKPNHPM@?9?5?$AA@

; 435  :                 else

  0005f	eb 05		 jmp	 SHORT $LN29@mprintf
$LN11@mprintf:

; 436  :                     _printf("  ");

  00061	68 00 00 00 00	 push	 OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
$LN29@mprintf:
  00066	e8 00 00 00 00	 call	 __printf
  0006b	83 c4 04	 add	 esp, 4
$LN10@mprintf:

; 437  :             }
; 438  :             
; 439  :             if( i < n && (m +i) >= (const char *)mem )

  0006e	3b f3		 cmp	 esi, ebx
  00070	7d 1a		 jge	 SHORT $LN9@mprintf
  00072	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00075	3b c5		 cmp	 eax, ebp
  00077	72 13		 jb	 SHORT $LN9@mprintf

; 440  :                 _printf("%02X ",0xFF & m[i]);

  00079	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0007c	52		 push	 edx
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_05BFHEBJNP@?$CF02X?5?$AA@
  00082	e8 00 00 00 00	 call	 __printf
  00087	83 c4 08	 add	 esp, 8

; 441  :             else

  0008a	eb 0d		 jmp	 SHORT $LN14@mprintf
$LN9@mprintf:

; 442  :                 _printf("   ");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_03NDEAONJP@?5?5?5?$AA@
  00091	e8 00 00 00 00	 call	 __printf
  00096	83 c4 04	 add	 esp, 4
$LN14@mprintf:
  00099	83 c6 01	 add	 esi, 1
  0009c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0009f	7c a1		 jl	 SHORT $LL28@mprintf

; 443  : 
; 444  :         }
; 445  : 
; 446  :         /*
; 447  :          *  显示相应字符
; 448  :          */
; 449  :         _printf(" ");

  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
  000a6	e8 00 00 00 00	 call	 __printf
  000ab	83 c4 04	 add	 esp, 4

; 450  :         for( i = 0 ; i < n ; i++,m++)

  000ae	85 db		 test	 ebx, ebx
  000b0	7e 3f		 jle	 SHORT $LN5@mprintf

; 443  : 
; 444  :         }
; 445  : 
; 446  :         /*
; 447  :          *  显示相应字符
; 448  :          */
; 449  :         _printf(" ");

  000b2	8b f3		 mov	 esi, ebx
$LL7@mprintf:

; 451  :         {
; 452  :             if( m >= (const char *)mem )

  000b4	3b fd		 cmp	 edi, ebp
  000b6	72 24		 jb	 SHORT $LN4@mprintf

; 453  :             {
; 454  :                 if( *m > 12 && *m < 127 )

  000b8	8a 07		 mov	 al, BYTE PTR [edi]
  000ba	3c 0c		 cmp	 al, 12			; 0000000cH
  000bc	7e 17		 jle	 SHORT $LN3@mprintf
  000be	3c 7f		 cmp	 al, 127			; 0000007fH
  000c0	7d 13		 jge	 SHORT $LN3@mprintf

; 455  :                     _printf("%c",*m);

  000c2	0f be c0	 movsx	 eax, al
  000c5	50		 push	 eax
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  000cb	e8 00 00 00 00	 call	 __printf
  000d0	83 c4 08	 add	 esp, 8

; 456  :                 else

  000d3	eb 14		 jmp	 SHORT $LN6@mprintf
$LN3@mprintf:

; 457  :                     _printf(".");

  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@

; 458  :             }
; 459  :             else

  000da	eb 05		 jmp	 SHORT $LN30@mprintf
$LN4@mprintf:

; 460  :                 _printf(" ");

  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5?$AA@
$LN30@mprintf:
  000e1	e8 00 00 00 00	 call	 __printf
  000e6	83 c4 04	 add	 esp, 4
$LN6@mprintf:
  000e9	83 c7 01	 add	 edi, 1
  000ec	83 ee 01	 sub	 esi, 1
  000ef	75 c3		 jne	 SHORT $LL7@mprintf
$LN5@mprintf:

; 461  :         }
; 462  :         _printf("\n");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6?$AA@
  000f6	e8 00 00 00 00	 call	 __printf
  000fb	83 c4 04	 add	 esp, 4

; 463  :         size    -= n;

  000fe	29 5c 24 18	 sub	 DWORD PTR _size$[esp+12], ebx
  00102	0f 85 1c ff ff
	ff		 jne	 $LL27@mprintf
  00108	5e		 pop	 esi
$LN17@mprintf:

; 464  :     }
; 465  : 
; 466  :     return m - (const char *)mem;

  00109	8b c7		 mov	 eax, edi
  0010b	5f		 pop	 edi
  0010c	2b c5		 sub	 eax, ebp
  0010e	5d		 pop	 ebp
  0010f	5b		 pop	 ebx

; 467  : }

  00110	c3		 ret	 0
__mprintf ENDP
_TEXT	ENDS
END
