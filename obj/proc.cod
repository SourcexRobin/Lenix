; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\proc.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_proc_cpu_time:DWORD
COMM	_proc_need_sched:DWORD
COMM	_proc_current:DWORD
_DATA	ENDS
_BSS	SEGMENT
?pid@?1??Proc_create@@9@9 DD 01H DUP (?)		; `Proc_create'::`2'::pid
_BSS	ENDS
CONST	SEGMENT
_proc_priority_number DB 03H
	DB	03H
	DB	07H
	DB	0fH
	DB	01fH
	DB	03fH
CONST	ENDS
PUBLIC	_Proc_pool
_BSS	SEGMENT
_proc_pool DB	0a80H DUP (?)
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\kernel\proc.c
_BSS	ENDS
;	COMDAT _Proc_pool
_TEXT	SEGMENT
_Proc_pool PROC						; COMDAT

; 96   :     return proc_pool;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _proc_pool

; 97   : }

  00005	c3		 ret	 0
_Proc_pool ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Proc_prio_num
_TEXT	SEGMENT
_Proc_prio_num PROC					; COMDAT
; _prionum$ = ecx

; 109  :     int                     i       = 1;

  00000	b8 01 00 00 00	 mov	 eax, 1
$LL4@Proc_prio_:

; 110  : 
; 111  :     for( ; i < 6 ; i++)
; 112  :         if( prionum == proc_priority_number[i] )

  00005	3a 88 00 00 00
	00		 cmp	 cl, BYTE PTR _proc_priority_number[eax]
  0000b	74 0a		 je	 SHORT $LN5@Proc_prio_
  0000d	83 c0 01	 add	 eax, 1
  00010	83 f8 06	 cmp	 eax, 6
  00013	7c f0		 jl	 SHORT $LL4@Proc_prio_

; 113  :             return i;
; 114  : 
; 115  :     return PROC_INVALID_PRIONUM;

  00015	0c ff		 or	 al, 255			; 000000ffH
$LN5@Proc_prio_:

; 116  : }

  00017	c3		 ret	 0
_Proc_prio_num ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Proc_list_add
_TEXT	SEGMENT
_Proc_list_add PROC					; COMDAT
; _pl$ = ecx
; _proc$ = eax

; 121  :     if( NULL == pl->pl_list )

  00000	33 d2		 xor	 edx, edx
  00002	39 11		 cmp	 DWORD PTR [ecx], edx

; 122  :     { 
; 123  :         proc->proc_sched_prev           = NULL;

  00004	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00007	75 09		 jne	 SHORT $LN2@Proc_list_

; 124  :         proc->proc_sched_next           = NULL;

  00009	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 132  :         pl->pl_list                     = proc;

  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 133  :     }
; 134  :     proc->proc_wait     = pl ;

  0000e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 135  : }

  00011	c3		 ret	 0
$LN2@Proc_list_:

; 125  :         pl->pl_list                     = proc ;
; 126  :     }
; 127  :     else
; 128  :     { 
; 129  :         proc->proc_sched_prev           = NULL; 
; 130  :         proc->proc_sched_next           = pl->pl_list;

  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 131  :         pl->pl_list->proc_sched_prev    = proc;

  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 132  :         pl->pl_list                     = proc;

  0001c	89 01		 mov	 DWORD PTR [ecx], eax

; 133  :     }
; 134  :     proc->proc_wait     = pl ;

  0001e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 135  : }

  00021	c3		 ret	 0
_Proc_list_add ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@GNOLGLLG@assert?5failed?$AA@		; `string'
PUBLIC	??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_02JNAHGKBG@pl?$AA@			; `string'
PUBLIC	??_C@_06IGODLHJP@proc?4c?$AA@			; `string'
EXTRN	_Sys_halt:PROC
EXTRN	__printf:PROC
;	COMDAT ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
CONST	SEGMENT
??_C@_0O@GNOLGLLG@assert?5failed?$AA@ DB 'assert failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@ DB 'a'
	DB	'ssert: %s ', 0aH, 'file: %s', 0aH, 'line : %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNAHGKBG@pl?$AA@
CONST	SEGMENT
??_C@_02JNAHGKBG@pl?$AA@ DB 'pl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGODLHJP@proc?4c?$AA@
CONST	SEGMENT
??_C@_06IGODLHJP@proc?4c?$AA@ DB 'proc.c', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_list_del
_TEXT	SEGMENT
_Proc_list_del PROC					; COMDAT
; _pl$ = edi
; _proc$ = esi

; 140  : {

  00000	53		 push	 ebx

; 141  :     ASSERT(pl);

  00001	33 db		 xor	 ebx, ebx
  00003	3b fb		 cmp	 edi, ebx
  00005	75 26		 jne	 SHORT $LN7@Proc_list_@2
  00007	68 8d 00 00 00	 push	 141			; 0000008dH
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_02JNAHGKBG@pl?$AA@
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001b	e8 00 00 00 00	 call	 __printf
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00025	e8 00 00 00 00	 call	 _Sys_halt
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@Proc_list_@2:

; 142  :     
; 143  :     /*
; 144  :      *  等于链表的头节点，删除头节点即可
; 145  :      */
; 146  :     if( proc == pl->pl_list )

  0002d	3b 37		 cmp	 esi, DWORD PTR [edi]

; 147  :     {
; 148  :         pl->pl_list = proc->proc_sched_next;

  0002f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00032	75 14		 jne	 SHORT $LN4@Proc_list_@2

; 149  :         if( pl->pl_list )

  00034	3b c3		 cmp	 eax, ebx
  00036	89 07		 mov	 DWORD PTR [edi], eax
  00038	74 1b		 je	 SHORT $LN1@Proc_list_@2

; 150  :             pl->pl_list->proc_sched_prev = NULL;

  0003a	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 163  :     }
; 164  :     proc->proc_sched_prev   = NULL;

  0003d	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 165  :     proc->proc_sched_next   = NULL;

  00040	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 166  :     proc->proc_wait         = NULL;

  00043	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00046	5b		 pop	 ebx

; 167  : }

  00047	c3		 ret	 0
$LN4@Proc_list_@2:

; 151  :     }
; 152  :     else
; 153  :     {
; 154  :         /*
; 155  :          *  必定存在前导节点。
; 156  :          */
; 157  :         proc_t      *   prev    = proc->proc_sched_prev,
; 158  :                     *   next    = proc->proc_sched_next;
; 159  :         
; 160  :         prev->proc_sched_next = next;
; 161  :         if( next )

  00048	3b c3		 cmp	 eax, ebx
  0004a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00050	74 03		 je	 SHORT $LN1@Proc_list_@2

; 162  :             next->proc_sched_prev = prev;

  00052	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN1@Proc_list_@2:

; 163  :     }
; 164  :     proc->proc_sched_prev   = NULL;

  00055	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 165  :     proc->proc_sched_next   = NULL;

  00058	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 166  :     proc->proc_wait         = NULL;

  0005b	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0005e	5b		 pop	 ebx

; 167  : }

  0005f	c3		 ret	 0
_Proc_list_del ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Proc_get
_TEXT	SEGMENT
_Proc_get PROC						; COMDAT
; _pid$ = ecx

; 187  :     register proc_t     *   proc        = NULL;
; 188  : 
; 189  :     /*
; 190  :      *  遍历进程池
; 191  :      */
; 192  :     for( proc = proc_pool ; proc < &proc_pool[PROC_MAX] ; proc++)           

  00000	b8 00 00 00 00	 mov	 eax, OFFSET _proc_pool
$LL4@Proc_get:

; 193  :     {
; 194  :         if( proc->proc_entry && pid == proc->proc_pid )                      

  00005	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00009	74 05		 je	 SHORT $LN3@Proc_get
  0000b	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  0000e	74 0c		 je	 SHORT $LN5@Proc_get
$LN3@Proc_get:

; 187  :     register proc_t     *   proc        = NULL;
; 188  : 
; 189  :     /*
; 190  :      *  遍历进程池
; 191  :      */
; 192  :     for( proc = proc_pool ; proc < &proc_pool[PROC_MAX] ; proc++)           

  00010	83 c0 54	 add	 eax, 84			; 00000054H
  00013	3d 80 0a 00 00	 cmp	 eax, OFFSET _proc_pool+2688
  00018	72 eb		 jb	 SHORT $LL4@Proc_get

; 195  :             return proc;
; 196  :     }
; 197  : 
; 198  :     return NULL;

  0001a	33 c0		 xor	 eax, eax
$LN5@Proc_get:

; 199  : }

  0001c	c3		 ret	 0
_Proc_get ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Proc_release
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_Proc_release PROC					; COMDAT

; 246  :     return RESULT_SUCCEED;

  00000	33 c0		 xor	 eax, eax

; 247  : }

  00002	c3		 ret	 0
_Proc_release ENDP
_TEXT	ENDS
PUBLIC	_Sched_add
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Cpu_disable_interrupt:PROC
_BSS	SEGMENT
_proc_prio_map DW 04H DUP (?)
_proc_rspl DD	041H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Sched_add
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_Sched_add PROC						; COMDAT

; 273  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 274  :     int             prio        = proc->proc_priority;

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _proc$[esp+4]
  00006	57		 push	 edi
  00007	0f b6 7e 4d	 movzx	 edi, BYTE PTR [esi+77]

; 275  :     CRITICAL_DECLARE(proc_rspl_lock);
; 276  : 
; 277  :     CRITICAL_BEGIN();

  0000b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00010	8b d8		 mov	 ebx, eax

; 278  :                                         
; 279  :     if( NULL == proc_rspl[prio] ) 

  00012	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR _proc_rspl[edi*4]
  00019	33 c9		 xor	 ecx, ecx
  0001b	3b c1		 cmp	 eax, ecx
  0001d	75 0f		 jne	 SHORT $LN2@Sched_add

; 280  :     {   
; 281  :         proc_rspl[prio]         = proc;

  0001f	89 34 bd 00 00
	00 00		 mov	 DWORD PTR _proc_rspl[edi*4], esi

; 282  :         proc->proc_sched_prev   = NULL;

  00026	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 283  :         proc->proc_sched_next   = NULL;

  00029	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx

; 284  :     } 
; 285  :     else

  0002c	eb 17		 jmp	 SHORT $LN1@Sched_add
$LN2@Sched_add:

; 286  :     { 
; 287  :         proc->proc_sched_next   = proc_rspl[prio]; 

  0002e	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 288  :         proc->proc_sched_prev   = NULL; 

  00031	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 289  :         proc_rspl[prio]->proc_sched_prev  = proc; 

  00034	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR _proc_rspl[edi*4]
  0003b	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 290  :         proc_rspl[prio]                   = proc;

  0003e	89 34 bd 00 00
	00 00		 mov	 DWORD PTR _proc_rspl[edi*4], esi
$LN1@Sched_add:

; 291  :     }
; 292  :     proc->proc_wait = NULL ;
; 293  :     proc->proc_stat = PROC_STAT_RUN;
; 294  :     
; 295  :     /*
; 296  :      *    引入优先级位图。将进程加入RSPL后，对应的优先级必然存在进程，因此可直
; 297  :      *  接将优先级位图的对应位置1，表示对应优先级已经存在进程。
; 298  :      */
; 299  :     proc_prio_map[prio / 16] |= 1 << (prio & 0xF);

  00045	8b c7		 mov	 eax, edi
  00047	99		 cdq
  00048	89 4e 10	 mov	 DWORD PTR [esi+16], ecx
  0004b	83 e2 0f	 and	 edx, 15			; 0000000fH
  0004e	03 c2		 add	 eax, edx
  00050	8b cf		 mov	 ecx, edi
  00052	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00055	ba 01 00 00 00	 mov	 edx, 1
  0005a	d3 e2		 shl	 edx, cl
  0005c	c1 f8 04	 sar	 eax, 4
  0005f	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR _proc_prio_map[eax*2]
  00066	c6 46 4e 01	 mov	 BYTE PTR [esi+78], 1
  0006a	66 09 10	 or	 WORD PTR [eax], dx

; 300  : 
; 301  :     CRITICAL_END();

  0006d	53		 push	 ebx
  0006e	e8 00 00 00 00	 call	 _Cpu_psw_set
  00073	83 c4 04	 add	 esp, 4
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx

; 302  : }

  00079	c3		 ret	 0
_Sched_add ENDP
_TEXT	ENDS
PUBLIC	_Sched_del
; Function compile flags: /Ogtpy
;	COMDAT _Sched_del
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_Sched_del PROC						; COMDAT

; 323  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 324  :     int             prio        = proc->proc_priority;

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _proc$[esp+8]
  00007	57		 push	 edi
  00008	0f b6 7e 4d	 movzx	 edi, BYTE PTR [esi+77]

; 325  :     CRITICAL_DECLARE(proc_rspl_lock);
; 326  :     
; 327  :     CRITICAL_BEGIN();

  0000c	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 328  : 
; 329  :     if( proc_rspl[prio]  )

  00011	33 db		 xor	 ebx, ebx
  00013	39 1c bd 00 00
	00 00		 cmp	 DWORD PTR _proc_rspl[edi*4], ebx
  0001a	8b e8		 mov	 ebp, eax
  0001c	74 3b		 je	 SHORT $LN14@Sched_del

; 330  :     { 
; 331  :         /*  删除进程，维护进程列表    */
; 332  :         if( NULL == proc->proc_sched_prev ) 

  0001e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00021	3b c3		 cmp	 eax, ebx
  00023	75 13		 jne	 SHORT $LN6@Sched_del

; 333  :         {
; 334  :             proc_rspl[prio] = proc->proc_sched_next; 

  00025	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 335  :             if( proc_rspl[prio] ) 

  00028	3b c3		 cmp	 eax, ebx
  0002a	89 04 bd 00 00
	00 00		 mov	 DWORD PTR _proc_rspl[edi*4], eax
  00031	74 1d		 je	 SHORT $LN2@Sched_del

; 336  :                 proc_rspl[prio]->proc_sched_prev = NULL; 

  00033	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 337  :         }
; 338  :         else if( NULL == proc->proc_sched_next ) 

  00036	eb 18		 jmp	 SHORT $LN2@Sched_del
$LN6@Sched_del:
  00038	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0003b	3b cb		 cmp	 ecx, ebx
  0003d	75 05		 jne	 SHORT $LN3@Sched_del

; 339  :         {
; 340  :             proc->proc_sched_prev->proc_sched_next = NULL; 

  0003f	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 341  :         }
; 342  :         else 

  00042	eb 0c		 jmp	 SHORT $LN2@Sched_del
$LN3@Sched_del:

; 343  :         { 
; 344  :             proc->proc_sched_prev->proc_sched_next = proc->proc_sched_next; 

  00044	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 345  :             proc->proc_sched_next->proc_sched_prev = proc->proc_sched_prev; 

  00047	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0004a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN2@Sched_del:

; 346  :         }
; 347  :     }
; 348  : 
; 349  :     /*
; 350  :      *    将进程从进程列表中删除时，并不代表列表中没有进程。只有在优先级中没有
; 351  :      *  进程时，才需要将优先级位图中对应的位清0 。
; 352  :      */
; 353  :     if( proc_rspl[prio] == NULL )

  00050	39 1c bd 00 00
	00 00		 cmp	 DWORD PTR _proc_rspl[edi*4], ebx
  00057	75 28		 jne	 SHORT $LN1@Sched_del
$LN14@Sched_del:

; 354  :         proc_prio_map[prio / 16] &= !( 1 << ( prio & 0xF ));

  00059	8b c7		 mov	 eax, edi
  0005b	99		 cdq
  0005c	83 e2 0f	 and	 edx, 15			; 0000000fH
  0005f	03 c2		 add	 eax, edx
  00061	8b cf		 mov	 ecx, edi
  00063	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	d3 e2		 shl	 edx, cl
  0006d	c1 f8 04	 sar	 eax, 4
  00070	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR _proc_prio_map[eax*2]
  00077	f7 da		 neg	 edx
  00079	1b d2		 sbb	 edx, edx
  0007b	83 c2 01	 add	 edx, 1
  0007e	66 21 10	 and	 WORD PTR [eax], dx
$LN1@Sched_del:

; 355  : 
; 356  :     CRITICAL_END();

  00081	55		 push	 ebp
  00082	e8 00 00 00 00	 call	 _Cpu_psw_set
  00087	83 c4 04	 add	 esp, 4
  0008a	5f		 pop	 edi

; 357  : 
; 358  :     proc->proc_sched_prev = NULL;

  0008b	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 359  :     proc->proc_sched_next = NULL;

  0008e	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx

; 360  :     proc->proc_wait       = NULL;

  00091	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 361  :     proc->proc_stat       = -1;

  00094	c6 46 4e ff	 mov	 BYTE PTR [esi+78], 255	; 000000ffH
  00098	5e		 pop	 esi
  00099	5d		 pop	 ebp
  0009a	5b		 pop	 ebx

; 362  : }

  0009b	c3		 ret	 0
_Sched_del ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@LIJHKGMO@Lenix?5try?5to?5sleep?4?$AA@	; `string'
PUBLIC	??_C@_08PDLGLHKP@proclist?$AA@			; `string'
PUBLIC	_Proc_wait_on
_BSS	SEGMENT
_proc_idle DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@LIJHKGMO@Lenix?5try?5to?5sleep?4?$AA@
CONST	SEGMENT
??_C@_0BE@LIJHKGMO@Lenix?5try?5to?5sleep?4?$AA@ DB 'Lenix try to sleep.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PDLGLHKP@proclist?$AA@
CONST	SEGMENT
??_C@_08PDLGLHKP@proclist?$AA@ DB 'proclist', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_wait_on
_TEXT	SEGMENT
_proclist$ = 8						; size = 4
_Proc_wait_on PROC					; COMDAT

; 430  : {

  00000	56		 push	 esi

; 431  :     ASSERT(  proclist );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _proclist$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 26		 jne	 SHORT $LN4@Proc_wait_
  00009	68 af 01 00 00	 push	 431			; 000001afH
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_08PDLGLHKP@proclist?$AA@
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001d	e8 00 00 00 00	 call	 __printf
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00027	e8 00 00 00 00	 call	 _Sys_halt
  0002c	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@Proc_wait_:

; 432  :     /*
; 433  :      * 系统进程进入睡眠状态，说明有错，死机
; 434  :      */
; 435  :     if( proc_current == proc_idle )

  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00034	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _proc_idle
  0003a	75 0d		 jne	 SHORT $LN1@Proc_wait_

; 436  :         Sys_halt("Lenix try to sleep.");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@LIJHKGMO@Lenix?5try?5to?5sleep?4?$AA@
  00041	e8 00 00 00 00	 call	 _Sys_halt
  00046	83 c4 04	 add	 esp, 4
$LN1@Proc_wait_:

; 437  :     Sched_del(proc_current);

  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 _Sched_del

; 438  :     proc_current->proc_wait = proclist;

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0005b	89 72 10	 mov	 DWORD PTR [edx+16], esi

; 439  :     proc_current->proc_stat = PROC_STAT_WAIT;

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00063	c6 40 4e 02	 mov	 BYTE PTR [eax+78], 2

; 440  :     Proc_list_add(proclist,proc_current); 

  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0006c	83 c4 04	 add	 esp, 4
  0006f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00072	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00079	75 0e		 jne	 SHORT $LN9@Proc_wait_
  0007b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00082	89 06		 mov	 DWORD PTR [esi], eax
  00084	89 70 10	 mov	 DWORD PTR [eax+16], esi
  00087	5e		 pop	 esi

; 441  : }

  00088	c3		 ret	 0

; 440  :     Proc_list_add(proclist,proc_current); 

$LN9@Proc_wait_:
  00089	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0008e	8b 16		 mov	 edx, DWORD PTR [esi]
  00090	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00093	89 06		 mov	 DWORD PTR [esi], eax
  00095	89 70 10	 mov	 DWORD PTR [eax+16], esi
  00098	5e		 pop	 esi

; 441  : }

  00099	c3		 ret	 0
_Proc_wait_on ENDP
_TEXT	ENDS
PUBLIC	_Proc_resume_on
; Function compile flags: /Ogtpy
;	COMDAT _Proc_resume_on
_TEXT	SEGMENT
_proclist$ = 8						; size = 4
_Proc_resume_on PROC					; COMDAT

; 461  :     proc_t        * proc    = NULL,
; 462  :                   * wakeup  = NULL;
; 463  :     
; 464  :     ASSERT(proclist );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _proclist$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	75 29		 jne	 SHORT $LN15@Proc_resum
  00008	68 d0 01 00 00	 push	 464			; 000001d0H
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_08PDLGLHKP@proclist?$AA@
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001c	e8 00 00 00 00	 call	 __printf
  00021	83 c4 10	 add	 esp, 16			; 00000010H
  00024	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _proclist$[esp-4], OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0002c	e9 00 00 00 00	 jmp	 _Sys_halt
$LN15@Proc_resum:
  00031	57		 push	 edi

; 465  : 
; 466  : #ifdef _CFG_RUN_TIME_CHECK_
; 467  :     /*  运行时校验  */
; 468  :     if( NULL == proclist )
; 469  :         return ;
; 470  : #endif  /*  _CFG_RUN_TIME_CHECK_ */
; 471  :     proc = proclist->pl_list;

  00032	8b 38		 mov	 edi, DWORD PTR [eax]

; 472  :     while( proc )                /*  唤醒列表中所有的进程                */

  00034	85 ff		 test	 edi, edi
  00036	74 46		 je	 SHORT $LN5@Proc_resum
  00038	53		 push	 ebx
  00039	56		 push	 esi
  0003a	bb 01 00 00 00	 mov	 ebx, 1
  0003f	90		 npad	 1
$LL6@Proc_resum:

; 473  :     {
; 474  :         wakeup  = proc;

  00040	8b f7		 mov	 esi, edi

; 475  :         proc    = proc->proc_sched_next;

  00042	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
  00045	8b 38		 mov	 edi, DWORD PTR [eax]

; 476  :         wakeup->proc_sched_next     = NULL;
; 477  :         wakeup->proc_wait           = NULL;
; 478  :         wakeup->proc_stat           = PROC_STAT_RUN;
; 479  :         Sched_add(wakeup);

  00047	56		 push	 esi
  00048	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00055	88 5e 4e	 mov	 BYTE PTR [esi+78], bl
  00058	e8 00 00 00 00	 call	 _Sched_add

; 480  :         if( wakeup->proc_priority <= proc_current->proc_priority )

  0005d	8a 46 4d	 mov	 al, BYTE PTR [esi+77]
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00066	83 c4 04	 add	 esp, 4
  00069	3a 41 4d	 cmp	 al, BYTE PTR [ecx+77]
  0006c	77 06		 ja	 SHORT $LN1@Proc_resum

; 481  :             PROC_NEED_SCHED();

  0006e	89 1d 00 00 00
	00		 mov	 DWORD PTR _proc_need_sched, ebx
$LN1@Proc_resum:

; 472  :     while( proc )                /*  唤醒列表中所有的进程                */

  00074	85 ff		 test	 edi, edi
  00076	75 c8		 jne	 SHORT $LL6@Proc_resum
  00078	8b 44 24 10	 mov	 eax, DWORD PTR _proclist$[esp+8]
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
$LN5@Proc_resum:

; 482  :     }
; 483  :     proclist->pl_list = NULL;

  0007e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00084	5f		 pop	 edi

; 484  : }

  00085	c3		 ret	 0
_Proc_resume_on ENDP
_TEXT	ENDS
PUBLIC	_Proc_resume_max_on
; Function compile flags: /Ogtpy
;	COMDAT _Proc_resume_max_on
_TEXT	SEGMENT
_proclist$ = 8						; size = 4
_Proc_resume_max_on PROC				; COMDAT

; 505  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 506  :     proc_t       *  proc    = NULL,     /*  需要唤醒的进程      */
; 507  :                  *  next    = NULL;     /*  循环算子            */
; 508  : 
; 509  :     ASSERT(proclist);

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _proclist$[esp+4]
  00006	85 ff		 test	 edi, edi
  00008	75 26		 jne	 SHORT $LN15@Proc_resum@2
  0000a	68 fd 01 00 00	 push	 509			; 000001fdH
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_08PDLGLHKP@proclist?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0001e	e8 00 00 00 00	 call	 __printf
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00028	e8 00 00 00 00	 call	 _Sys_halt
  0002d	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@Proc_resum@2:

; 510  : 
; 511  :     proc = proclist->pl_list;

  00030	8b 37		 mov	 esi, DWORD PTR [edi]

; 512  : 
; 513  : #ifdef _CFG_RUN_TIME_CHECK_
; 514  :     /*  运行时校验  */
; 515  :     if( NULL == proclist )
; 516  :         return ;
; 517  : #endif  /*  _CFG_RUN_TIME_CHECK_ */
; 518  :     if( NULL == proc )

  00032	85 f6		 test	 esi, esi
  00034	74 4c		 je	 SHORT $LN1@Proc_resum@2

; 519  :         return ;
; 520  :     /*
; 521  :      *  查找列表中优先级最高且调度因子最大的进程
; 522  :      */
; 523  :     for( next = proc->proc_sched_next; next ; next = next->proc_sched_next)

  00036	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00039	85 c0		 test	 eax, eax
  0003b	74 20		 je	 SHORT $LN8@Proc_resum@2
  0003d	8d 49 00	 npad	 3
$LL10@Proc_resum@2:

; 524  :     {
; 525  :         /*
; 526  :          *  跳过优先级低的进程
; 527  :          */
; 528  :         if( next->proc_priority > proc->proc_priority )

  00040	8a 48 4d	 mov	 cl, BYTE PTR [eax+77]
  00043	8a 56 4d	 mov	 dl, BYTE PTR [esi+77]
  00046	3a ca		 cmp	 cl, dl
  00048	77 0c		 ja	 SHORT $LN9@Proc_resum@2

; 529  :             continue;
; 530  : 
; 531  :         /*
; 532  :          *  发现优先级更高的进程
; 533  :          */
; 534  :         if( next->proc_priority < proc->proc_priority )
; 535  :         {
; 536  :             proc = next;
; 537  :             continue;

  0004a	72 08		 jb	 SHORT $LN21@Proc_resum@2

; 538  :         }
; 539  : 
; 540  :         /*
; 541  :          *  到达这里，说明进程优先级相同，则挑选调度因子高的进程
; 542  :          */
; 543  :         if( next->proc_sched_factor > proc->proc_sched_factor)

  0004c	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0004f	3b 4e 44	 cmp	 ecx, DWORD PTR [esi+68]
  00052	76 02		 jbe	 SHORT $LN9@Proc_resum@2
$LN21@Proc_resum@2:

; 544  :             proc = next;

  00054	8b f0		 mov	 esi, eax
$LN9@Proc_resum@2:

; 519  :         return ;
; 520  :     /*
; 521  :      *  查找列表中优先级最高且调度因子最大的进程
; 522  :      */
; 523  :     for( next = proc->proc_sched_next; next ; next = next->proc_sched_next)

  00056	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00059	85 c0		 test	 eax, eax
  0005b	75 e3		 jne	 SHORT $LL10@Proc_resum@2
$LN8@Proc_resum@2:

; 545  :     }
; 546  :     Proc_list_del(proclist,proc);

  0005d	e8 00 00 00 00	 call	 _Proc_list_del

; 547  : #ifdef d_CFG_DEBUG_
; 548  :     _printk("resume proc name : %s \n",proc->proc_name);
; 549  : #endif
; 550  :     Sched_add(proc);

  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 _Sched_add

; 551  :     if( proc->proc_priority < proc_current->proc_priority)

  00068	8a 56 4d	 mov	 dl, BYTE PTR [esi+77]
  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00070	83 c4 04	 add	 esp, 4
  00073	3a 50 4d	 cmp	 dl, BYTE PTR [eax+77]
  00076	73 0a		 jae	 SHORT $LN1@Proc_resum@2

; 552  :         PROC_NEED_SCHED();

  00078	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN1@Proc_resum@2:
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi

; 553  : }

  00084	c3		 ret	 0
_Proc_resume_max_on ENDP
_TEXT	ENDS
PUBLIC	_Proc_ticks
_BSS	SEGMENT
_proc_delay DD	01H DUP (?)
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT _Proc_ticks
_TEXT	SEGMENT
___psw$ = -4						; size = 4
_Proc_ticks PROC					; COMDAT

; 644  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi

; 645  :     proc_t       * proc = NULL,
; 646  :                  * next = NULL;
; 647  :     CRITICAL_DECLARE(proc_delay_lock);
; 648  : 
; 649  :     proc = proc_delay.pl_list;

  00003	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _proc_delay

; 650  : 
; 651  :     CRITICAL_BEGIN();

  00009	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 652  :     while(proc)

  0000e	33 db		 xor	 ebx, ebx
  00010	3b f3		 cmp	 esi, ebx
  00012	89 44 24 08	 mov	 DWORD PTR ___psw$[esp+12], eax
  00016	74 6c		 je	 SHORT $LN7@Proc_ticks
  00018	57		 push	 edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL8@Proc_ticks:

; 653  :     {
; 654  :         next = proc->proc_sched_next;
; 655  :         /*
; 656  :          *  进程收到信号或者延时时间到，都将被唤醒 
; 657  :          */
; 658  :         if( proc->proc_signal_map || --proc->proc_alarm <= 0 )              

  00020	39 5e 3c	 cmp	 DWORD PTR [esi+60], ebx
  00023	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]
  00026	75 06		 jne	 SHORT $LN21@Proc_ticks
  00028	83 46 40 ff	 add	 DWORD PTR [esi+64], -1
  0002c	75 4f		 jne	 SHORT $LN1@Proc_ticks

; 659  :         {
; 660  :             Proc_list_del(&proc_delay,proc);

$LN21@Proc_ticks:
  0002e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _proc_delay
  00034	75 10		 jne	 SHORT $LN17@Proc_ticks
  00036	8b c7		 mov	 eax, edi
  00038	3b c3		 cmp	 eax, ebx
  0003a	a3 00 00 00 00	 mov	 DWORD PTR _proc_delay, eax
  0003f	74 12		 je	 SHORT $LN14@Proc_ticks
  00041	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00044	eb 0d		 jmp	 SHORT $LN14@Proc_ticks
$LN17@Proc_ticks:
  00046	3b fb		 cmp	 edi, ebx
  00048	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0004b	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  0004e	74 03		 je	 SHORT $LN14@Proc_ticks
  00050	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN14@Proc_ticks:

; 661  :             /*
; 662  :              *    将proc加入RSPL后，原proc的链表数据就会被新数据代替。因此需要
; 663  :              *  增加一个next变量来保存原有的链表指针。
; 664  :              */
; 665  :             Sched_add(proc);

  00053	56		 push	 esi
  00054	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00057	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  0005a	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  0005d	e8 00 00 00 00	 call	 _Sched_add

; 666  :             /*
; 667  :              * 有进程进入运行态，且优先级高于当前进程，需要发出调度请求
; 668  :              */
; 669  :             if( proc->proc_priority < proc_current->proc_priority )

  00062	8a 46 4d	 mov	 al, BYTE PTR [esi+77]
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0006b	83 c4 04	 add	 esp, 4
  0006e	3a 41 4d	 cmp	 al, BYTE PTR [ecx+77]
  00071	73 0a		 jae	 SHORT $LN1@Proc_ticks

; 670  :                 PROC_NEED_SCHED();              

  00073	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN1@Proc_ticks:

; 652  :     while(proc)

  0007d	3b fb		 cmp	 edi, ebx

; 671  :         }
; 672  :         proc = next;

  0007f	8b f7		 mov	 esi, edi
  00081	75 9d		 jne	 SHORT $LL8@Proc_ticks
  00083	5f		 pop	 edi
$LN7@Proc_ticks:

; 673  :     }
; 674  :     CRITICAL_END();

  00084	8b 54 24 08	 mov	 edx, DWORD PTR ___psw$[esp+12]
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 _Cpu_psw_set
  0008e	83 c4 04	 add	 esp, 4
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 675  : }

  00093	59		 pop	 ecx
  00094	c3		 ret	 0
_Proc_ticks ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@PHCMJNFH@proc?3?$CFs?5stack?5overflow?$CB?5sp?3?$CFp?5bo@ ; `string'
PUBLIC	_Proc_switch_prepare
EXTRN	__sprintf:PROC
;	COMDAT ??_C@_0CJ@PHCMJNFH@proc?3?$CFs?5stack?5overflow?$CB?5sp?3?$CFp?5bo@
CONST	SEGMENT
??_C@_0CJ@PHCMJNFH@proc?3?$CFs?5stack?5overflow?$CB?5sp?3?$CFp?5bo@ DB 'p'
	DB	'roc:%s stack overflow! sp:%p bottom:%p', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_switch_prepare
_TEXT	SEGMENT
_str$1865 = -64						; size = 64
_sp$ = 8						; size = 4
_next$ = 12						; size = 4
_Proc_switch_prepare PROC				; COMDAT

; 697  : 
; 698  : #ifdef _CFG_SWITCH_PREPARE_HOOK_
; 699  :     Proc_switch_prepare_hook(proc_current,next);
; 700  : #endif  /*  _CFG_SWITCH_PREPARE_HOOK_   */
; 701  : 
; 702  :     /*
; 703  :      *    在进行进程切换时，当前进程有可能已经无效。在进程退出后，就会出现这样
; 704  :      *  的情况如果此时还要保存指针，将会已经释放的对象的数据
; 705  :      */
; 706  :     if( proc_current->proc_entry)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	83 ec 40	 sub	 esp, 64			; 00000040H
  00008	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0000c	74 3f		 je	 SHORT $LN9@Proc_switc

; 707  :         proc_current->proc_sp = sp;

  0000e	8b 4c 24 44	 mov	 ecx, DWORD PTR _sp$[esp+60]
  00012	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current

; 708  : 
; 709  : #ifdef _CFG_CHECK_STACK_
; 710  :     do
; 711  :     {
; 712  :         char    str[64];
; 713  : 
; 714  :         /*  检查是否存在栈越界                  */
; 715  :         if( proc_current->proc_entry && !STACK_CHECK(proc_current) )

  0001a	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0001e	74 2d		 je	 SHORT $LN9@Proc_switc
  00020	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  00023	3b 50 20	 cmp	 edx, DWORD PTR [eax+32]
  00026	77 25		 ja	 SHORT $LN9@Proc_switc

; 716  :         {
; 717  :             _sprintf(str,"proc:%s stack overflow! sp:%p bottom:%p\n",
; 718  :                 proc_current->proc_name,proc_current->proc_sp,
; 719  :                 proc_current->proc_stack_bottom);

  00028	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0002b	51		 push	 ecx
  0002c	52		 push	 edx
  0002d	83 c0 14	 add	 eax, 20			; 00000014H
  00030	50		 push	 eax
  00031	8d 44 24 0c	 lea	 eax, DWORD PTR _str$1865[esp+76]
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@PHCMJNFH@proc?3?$CFs?5stack?5overflow?$CB?5sp?3?$CFp?5bo@
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 __sprintf

; 720  :             Sys_halt(str);

  00040	8d 4c 24 14	 lea	 ecx, DWORD PTR _str$1865[esp+84]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 _Sys_halt
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@Proc_switc:

; 721  :         }
; 722  :     }while(0);
; 723  : #endif  /*  _CFG_CHECK_STACK_   */
; 724  : 
; 725  :     proc_current = next;

  0004d	8b 44 24 48	 mov	 eax, DWORD PTR _next$[esp+60]
  00051	a3 00 00 00 00	 mov	 DWORD PTR _proc_current, eax

; 726  :     //printf("current proc; %s\n",proc_current->proc_name);
; 727  :     return proc_current->proc_sp;

  00056	8b 40 28	 mov	 eax, DWORD PTR [eax+40]

; 728  : }

  00059	83 c4 40	 add	 esp, 64			; 00000040H
  0005c	c3		 ret	 0
_Proc_switch_prepare ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Proc_refresh_sched_factor
_TEXT	SEGMENT
_Proc_refresh_sched_factor PROC				; COMDAT

; 747  :     int                     i       = 1;
; 748  :     proc_t              *   proc    = FIRST_PROC;

  00000	b8 98 00 00 00	 mov	 eax, OFFSET _proc_pool+152
  00005	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@Proc_refre:

; 749  : 
; 750  :     for( i = 1 ; i < PROC_MAX ; i++,proc++)
; 751  :     {
; 752  :         if( proc->proc_entry && proc->proc_sched_factor < 0xFFFFFF00 )

  00010	83 78 e8 00	 cmp	 DWORD PTR [eax-24], 0
  00014	74 12		 je	 SHORT $LN3@Proc_refre
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	81 f9 00 ff ff
	ff		 cmp	 ecx, -256		; ffffff00H
  0001e	73 08		 jae	 SHORT $LN3@Proc_refre

; 753  :             proc->proc_sched_factor += proc->proc_prio_num;

  00020	0f b6 70 08	 movzx	 esi, BYTE PTR [eax+8]
  00024	03 f1		 add	 esi, ecx
  00026	89 30		 mov	 DWORD PTR [eax], esi
$LN3@Proc_refre:
  00028	83 c0 54	 add	 eax, 84			; 00000054H
  0002b	83 ea 01	 sub	 edx, 1
  0002e	75 e0		 jne	 SHORT $LL4@Proc_refre
  00030	5e		 pop	 esi

; 754  :     }
; 755  : }

  00031	c3		 ret	 0
_Proc_refresh_sched_factor ENDP
_TEXT	ENDS
PUBLIC	??_C@_04GMALNMBL@OK?$CB?6?$AA@			; `string'
PUBLIC	??_C@_04EAPMNACM@idle?$AA@			; `string'
PUBLIC	??_C@_0BG@LMNCPDCG@process?5initial?4?4?4?5?5?5?$AA@ ; `string'
PUBLIC	_Proc_initial
EXTRN	_Koum_add:PROC
EXTRN	_main:PROC
EXTRN	__strcpy:PROC
EXTRN	__memzero:PROC
EXTRN	__printk:PROC
;	COMDAT ??_C@_04GMALNMBL@OK?$CB?6?$AA@
CONST	SEGMENT
??_C@_04GMALNMBL@OK?$CB?6?$AA@ DB 'OK!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EAPMNACM@idle?$AA@
CONST	SEGMENT
??_C@_04EAPMNACM@idle?$AA@ DB 'idle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LMNCPDCG@process?5initial?4?4?4?5?5?5?$AA@
CONST	SEGMENT
??_C@_0BG@LMNCPDCG@process?5initial?4?4?4?5?5?5?$AA@ DB 'process initial.'
	DB	'..   ', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_initial
_TEXT	SEGMENT
_Proc_initial PROC					; COMDAT

; 773  :     _printk("process initial...   ");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@LMNCPDCG@process?5initial?4?4?4?5?5?5?$AA@
  00005	e8 00 00 00 00	 call	 __printk

; 774  :     _memzero(proc_pool,PROC_MAX*sizeof(proc_t));

  0000a	68 80 0a 00 00	 push	 2688			; 00000a80H
  0000f	68 00 00 00 00	 push	 OFFSET _proc_pool
  00014	e8 00 00 00 00	 call	 __memzero

; 775  :     _memzero(proc_rspl,sizeof(proc_t *) * (PROC_PRIORITY_MAX + 1));

  00019	68 04 01 00 00	 push	 260			; 00000104H
  0001e	68 00 00 00 00	 push	 OFFSET _proc_rspl
  00023	e8 00 00 00 00	 call	 __memzero

; 776  : 
; 777  : #ifdef _CFG_SMP_
; 778  :     proc_rspl_lock      = 0;
; 779  :     proc_pool_lock      = 0;
; 780  :     proc_delay_lock     = 0;
; 781  : #endif      /*  _CFG_SMP_   */
; 782  :     proc_need_sched     = 0;
; 783  :     proc_current        = proc_pool;
; 784  :     proc_idle           = proc_pool;
; 785  :     _strcpy(proc_idle->proc_name,"idle");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_04EAPMNACM@idle?$AA@
  0002d	68 14 00 00 00	 push	 OFFSET _proc_pool+20
  00032	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _proc_need_sched, 0
  0003c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _proc_current, OFFSET _proc_pool
  00046	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _proc_idle, OFFSET _proc_pool
  00050	e8 00 00 00 00	 call	 __strcpy

; 786  :     proc_idle->proc_entry           = (proc_entry_t)main;

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_idle

; 787  :     proc_idle->proc_stat            = PROC_STAT_RUN;
; 788  :     proc_idle->proc_stack_bottom    = IDLE_DEFAULT_STACK_BOTTOM;
; 789  :     proc_idle->proc_stack_size      = IDLE_DEFAULT_STACK_SIZE;
; 790  :     proc_idle->proc_priority        = PROC_PRIORITY_MAX;   /*将优先级设为最低*/
; 791  :     proc_rspl[PROC_PRIORITY_MAX]    = proc_idle;
; 792  :     /*
; 793  :      *  系统中第一个内核对象
; 794  :      */
; 795  :     Koum_add(proc_idle,Proc_release,kot_proc,HANDLE_ATTR_RDWR);

  0005a	6a 03		 push	 3
  0005c	6a 01		 push	 1
  0005e	68 00 00 00 00	 push	 OFFSET _Proc_release
  00063	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], OFFSET _main
  0006a	c6 40 4e 01	 mov	 BYTE PTR [eax+78], 1
  0006e	c7 40 20 00 fc
	00 00		 mov	 DWORD PTR [eax+32], 64512 ; 0000fc00H
  00075	c7 40 24 fc 03
	00 00		 mov	 DWORD PTR [eax+36], 1020 ; 000003fcH
  0007c	c6 40 4d 40	 mov	 BYTE PTR [eax+77], 64	; 00000040H
  00080	50		 push	 eax
  00081	a3 00 01 00 00	 mov	 DWORD PTR _proc_rspl+256, eax
  00086	e8 00 00 00 00	 call	 _Koum_add

; 796  :     _printk("OK!\n");

  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_04GMALNMBL@OK?$CB?6?$AA@
  00090	e8 00 00 00 00	 call	 __printk
  00095	83 c4 30	 add	 esp, 48			; 00000030H

; 797  : }

  00098	c3		 ret	 0
_Proc_initial ENDP
_TEXT	ENDS
PUBLIC	_Signal_handle
; Function compile flags: /Ogtpy
;	COMDAT _Signal_handle
_TEXT	SEGMENT
_Signal_handle PROC					; COMDAT

; 805  :     int                     i           = 0;
; 806  :     uint_t                  signal      = 0;
; 807  : 
; 808  :     /*
; 809  :      *  没有信号就直接退出
; 810  :      */
; 811  :     if( 0 == proc_current->proc_signal_map )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00009	74 07		 je	 SHORT $LN2@Signal_han

; 812  :         return ;
; 813  : 
; 814  : #ifdef _CFG_SIGNAL_ENABLE_
; 815  :     for( i = 15 ; i >= 0 ; i-- )
; 816  :     {
; 817  :         signal = PROC_MAKE_SIGNAL(i);
; 818  :         if( proc_current->proc_signal_map & signal )
; 819  :         {
; 820  :             proc_current->proc_signal_map &= ~signal;   /*  清信号位 */
; 821  :             proc_current->proc_signal_handle[i]();
; 822  :             return ;                                    /*每次只处理一个信号*/
; 823  :         }
; 824  :     }
; 825  : #else
; 826  :     i       = i;
; 827  :     signal  = signal;
; 828  :     proc_current->proc_signal_map = 0;

  0000b	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN2@Signal_han:

; 829  : #endif
; 830  : }

  00012	c3		 ret	 0
_Signal_handle ENDP
_TEXT	ENDS
PUBLIC	_Spin_lock
EXTRN	_Cpu_tas_i:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Spin_lock
_TEXT	SEGMENT
_sl$ = 8						; size = 4
_Spin_lock PROC						; COMDAT

; 863  :     /*
; 864  :      *  多CPU时，保证进程一直可以占用CPU
; 865  :      */
; 866  :     PROC_SEIZE_DISABLE();

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00008	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0000e	83 c1 01	 add	 ecx, 1
  00011	56		 push	 esi
  00012	8b 74 24 08	 mov	 esi, DWORD PTR _sl$[esp]
  00016	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Spin_lock:

; 867  : 
; 868  :     while( Cpu_tas((int *)sl,LOCK_STATUS_FREE,LOCK_STATUS_LOCKED) ) 

  00020	6a 01		 push	 1
  00022	6a 00		 push	 0
  00024	56		 push	 esi
  00025	e8 00 00 00 00	 call	 _Cpu_tas_i
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	85 c0		 test	 eax, eax
  0002f	75 ef		 jne	 SHORT $LL2@Spin_lock
  00031	5e		 pop	 esi

; 869  :         ;
; 870  : }

  00032	c3		 ret	 0
_Spin_lock ENDP
_TEXT	ENDS
PUBLIC	_Spin_free
; Function compile flags: /Ogtpy
;	COMDAT _Spin_free
_TEXT	SEGMENT
_sl$ = 8						; size = 4
_Spin_free PROC						; COMDAT

; 874  :     *sl = LOCK_STATUS_FREE;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _sl$[esp-4]
  00004	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 875  : 
; 876  :     PROC_SEIZE_ENABLE();

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00010	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00018	83 ea 01	 sub	 edx, 1
  0001b	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 877  : }

  0001e	c3		 ret	 0
_Spin_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IGLAPKCI@0?5?$CB?$DN?5stacksize?$AA@	; `string'
PUBLIC	??_C@_0O@JMLMFFGB@NULL?5?$CB?$DN?5stack?$AA@	; `string'
PUBLIC	??_C@_0O@GBLECFPN@NULL?5?$CB?$DN?5entry?$AA@	; `string'
PUBLIC	??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@	; `string'
PUBLIC	_Proc_create
EXTRN	__nstrcpy:PROC
EXTRN	_Context_initial:PROC
EXTRN	_interrupt_nest:BYTE
;	COMDAT ??_C@_0P@IGLAPKCI@0?5?$CB?$DN?5stacksize?$AA@
CONST	SEGMENT
??_C@_0P@IGLAPKCI@0?5?$CB?$DN?5stacksize?$AA@ DB '0 != stacksize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMLMFFGB@NULL?5?$CB?$DN?5stack?$AA@
CONST	SEGMENT
??_C@_0O@JMLMFFGB@NULL?5?$CB?$DN?5stack?$AA@ DB 'NULL != stack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GBLECFPN@NULL?5?$CB?$DN?5entry?$AA@
CONST	SEGMENT
??_C@_0O@GBLECFPN@NULL?5?$CB?$DN?5entry?$AA@ DB 'NULL != entry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@
CONST	SEGMENT
??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@ DB 'NULL != name', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_create
_TEXT	SEGMENT
_name$ = 8						; size = 4
_priority$ = 12						; size = 1
_prionum$ = 16						; size = 1
_entry$ = 20						; size = 4
_param$ = 24						; size = 4
_stack$ = 28						; size = 4
_stacksize$ = 32					; size = 4
_Proc_create PROC					; COMDAT

; 920  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 921  :     static int      pid     = 0;
; 922  :     handle_t        hnd     = INVALID_HANDLE;

  00003	33 db		 xor	 ebx, ebx

; 923  :     proc_t        * proc    = FIRST_PROC;
; 924  :     uint_t        * sp      = NULL;
; 925  :     int             i       = 1;
; 926  :     CRITICAL_DECLARE(proc_pool_lock);
; 927  : 
; 928  :     ASSERT( NULL != name    );

  00005	39 5c 24 10	 cmp	 DWORD PTR _name$[esp+8], ebx
  00009	57		 push	 edi
  0000a	be 54 00 00 00	 mov	 esi, OFFSET _proc_pool+84
  0000f	bf 01 00 00 00	 mov	 edi, 1
  00014	75 26		 jne	 SHORT $LN40@Proc_creat
  00016	68 a0 03 00 00	 push	 928			; 000003a0H
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MPMENKGI@NULL?5?$CB?$DN?5name?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  0002a	e8 00 00 00 00	 call	 __printf
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00034	e8 00 00 00 00	 call	 _Sys_halt
  00039	83 c4 14	 add	 esp, 20			; 00000014H
$LN40@Proc_creat:

; 929  :     ASSERT( NULL != entry   );

  0003c	39 5c 24 20	 cmp	 DWORD PTR _entry$[esp+12], ebx
  00040	75 26		 jne	 SHORT $LN36@Proc_creat
  00042	68 a1 03 00 00	 push	 929			; 000003a1H
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GBLECFPN@NULL?5?$CB?$DN?5entry?$AA@
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00056	e8 00 00 00 00	 call	 __printf
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  00060	e8 00 00 00 00	 call	 _Sys_halt
  00065	83 c4 14	 add	 esp, 20			; 00000014H
$LN36@Proc_creat:

; 930  :     ASSERT( NULL != stack   );

  00068	8b 6c 24 28	 mov	 ebp, DWORD PTR _stack$[esp+12]
  0006c	3b eb		 cmp	 ebp, ebx
  0006e	75 26		 jne	 SHORT $LN32@Proc_creat
  00070	68 a2 03 00 00	 push	 930			; 000003a2H
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@JMLMFFGB@NULL?5?$CB?$DN?5stack?$AA@
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00084	e8 00 00 00 00	 call	 __printf
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0008e	e8 00 00 00 00	 call	 _Sys_halt
  00093	83 c4 14	 add	 esp, 20			; 00000014H
$LN32@Proc_creat:

; 931  :     ASSERT( 0 != stacksize  );

  00096	39 5c 24 2c	 cmp	 DWORD PTR _stacksize$[esp+12], ebx
  0009a	75 26		 jne	 SHORT $LN28@Proc_creat
  0009c	68 a3 03 00 00	 push	 931			; 000003a3H
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IGLAPKCI@0?5?$CB?$DN?5stacksize?$AA@
  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  000b0	e8 00 00 00 00	 call	 __printf
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  000ba	e8 00 00 00 00	 call	 _Sys_halt
  000bf	83 c4 14	 add	 esp, 20			; 00000014H
$LN28@Proc_creat:

; 932  : 
; 933  : #ifdef _CFG_RUN_TIME_CHECK_
; 934  :     /*  运行期间参数校验    */
; 935  :     if( NULL == name || NULL == entry || NULL == stack || 0 == stacksize )  

  000c2	39 5c 24 14	 cmp	 DWORD PTR _name$[esp+12], ebx
  000c6	74 52		 je	 SHORT $LN65@Proc_creat
  000c8	39 5c 24 20	 cmp	 DWORD PTR _entry$[esp+12], ebx
  000cc	74 4c		 je	 SHORT $LN65@Proc_creat
  000ce	3b eb		 cmp	 ebp, ebx
  000d0	74 48		 je	 SHORT $LN65@Proc_creat
  000d2	39 5c 24 2c	 cmp	 DWORD PTR _stacksize$[esp+12], ebx
  000d6	74 42		 je	 SHORT $LN65@Proc_creat

; 936  :         goto proc_create_end;
; 937  : #endif  /*  _CFG_RUN_TIME_CHECK_   */
; 938  :     if( interrupt_nest )    /*  中断服务处理期间，不能创建进程     */

  000d8	38 1d 00 00 00
	00		 cmp	 BYTE PTR _interrupt_nest, bl
  000de	75 3a		 jne	 SHORT $LN65@Proc_creat

; 939  :         goto proc_create_end;
; 940  :     /*
; 941  :      *    以下临界段涉及可用进程对象查找和可用进程编号查找，耗时可能较长。
; 942  :      *  因此不要在实时性要求高的程序中创建进程。
; 943  :      */
; 944  :     CRITICAL_BEGIN();

  000e0	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
$LL19@Proc_creat:

; 945  :     /*  遍历进程池，查找可用的进程对象 */
; 946  :     for( ; i < PROC_MAX ; i++,proc++)
; 947  :     {   
; 948  :         if( PROC_IS_FREE(proc) )

  000e5	39 5e 2c	 cmp	 DWORD PTR [esi+44], ebx
  000e8	74 1b		 je	 SHORT $LN48@Proc_creat
  000ea	83 c7 01	 add	 edi, 1
  000ed	83 c6 54	 add	 esi, 84			; 00000054H
  000f0	83 ff 20	 cmp	 edi, 32			; 00000020H
  000f3	7c f0		 jl	 SHORT $LL19@Proc_creat

; 955  :     {
; 956  :         /*
; 957  :          *  进程池已满，不能创建进程
; 958  :          */
; 959  :         CRITICAL_END();

  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 _Cpu_psw_set
  000fb	83 c4 04	 add	 esp, 4
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5d		 pop	 ebp

; 1013 :         PROC_NEED_SCHED();
; 1014 :     }
; 1015 : proc_create_end:
; 1016 :     return hnd;

  00101	33 c0		 xor	 eax, eax
  00103	5b		 pop	 ebx

; 1017 : }

  00104	c3		 ret	 0
$LN48@Proc_creat:

; 949  :         {
; 950  :             proc->proc_entry = entry;   /*  将进程对象置为已占用    */
; 951  :             break;
; 952  :         } 
; 953  :     }
; 954  :     if( i >= PROC_MAX )

  00105	83 ff 20	 cmp	 edi, 32			; 00000020H
  00108	8b 4c 24 20	 mov	 ecx, DWORD PTR _entry$[esp+12]
  0010c	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0010f	7c 10		 jl	 SHORT $LN58@Proc_creat

; 955  :     {
; 956  :         /*
; 957  :          *  进程池已满，不能创建进程
; 958  :          */
; 959  :         CRITICAL_END();

  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _Cpu_psw_set
  00117	83 c4 04	 add	 esp, 4
$LN65@Proc_creat:
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5d		 pop	 ebp

; 1013 :         PROC_NEED_SCHED();
; 1014 :     }
; 1015 : proc_create_end:
; 1016 :     return hnd;

  0011d	33 c0		 xor	 eax, eax
$proc_create_end$1959:
  0011f	5b		 pop	 ebx

; 1017 : }

  00120	c3		 ret	 0
$LN58@Proc_creat:

; 960  :         goto proc_create_end;

  00121	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pid@?1??Proc_create@@9@9
  00127	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$create_pid$1970:

; 961  :     }
; 962  : create_pid:
; 963  :     /*
; 964  :      *  给新进程分配唯一标识符
; 965  :      */
; 966  :     if( ++pid < 1 ) pid = 1;            /*  0是系统进程的PID    */

  00130	83 c2 01	 add	 edx, 1
  00133	83 fa 01	 cmp	 edx, 1
  00136	89 15 00 00 00
	00		 mov	 DWORD PTR ?pid@?1??Proc_create@@9@9, edx
  0013c	7d 0b		 jge	 SHORT $LN14@Proc_creat
  0013e	ba 01 00 00 00	 mov	 edx, 1
  00143	89 15 00 00 00
	00		 mov	 DWORD PTR ?pid@?1??Proc_create@@9@9, edx
$LN14@Proc_creat:

; 967  :     for( i = 1 ; i < PROC_MAX ; i++)    /*  检测PID是否存在重复 */

  00149	b9 84 00 00 00	 mov	 ecx, OFFSET _proc_pool+132
  0014e	8b ff		 npad	 2
$LL13@Proc_creat:
  00150	81 f9 b0 0a 00
	00		 cmp	 ecx, OFFSET _proc_pool+2736
  00156	7d 0e		 jge	 SHORT $LN11@Proc_creat

; 968  :     {
; 969  :         /*
; 970  :          *  跳过空闲的进程对象，由于自身的PID仍为0，而系统不会产生0的编号，
; 971  :          *  所以不用理会自身
; 972  :          */
; 973  :         if( PROC_IS_FREE(&proc_pool[i]) )

  00158	39 59 fc	 cmp	 DWORD PTR [ecx-4], ebx
  0015b	74 04		 je	 SHORT $LN12@Proc_creat

; 974  :             continue;
; 975  :         if( pid == proc_pool[i].proc_pid )  /*  出现重复的pid，则重新生成*/

  0015d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0015f	74 cf		 je	 SHORT $create_pid$1970
$LN12@Proc_creat:

; 967  :     for( i = 1 ; i < PROC_MAX ; i++)    /*  检测PID是否存在重复 */

  00161	83 c1 54	 add	 ecx, 84			; 00000054H
  00164	eb ea		 jmp	 SHORT $LL13@Proc_creat
$LN11@Proc_creat:

; 976  :             goto create_pid;
; 977  :     }
; 978  :     proc->proc_pid = pid;
; 979  :     CRITICAL_END();

  00166	50		 push	 eax
  00167	89 56 30	 mov	 DWORD PTR [esi+48], edx
  0016a	e8 00 00 00 00	 call	 _Cpu_psw_set

; 980  :     sp      = Context_initial(entry,param,stack);   /*  初始化进程运行环境  */

  0016f	8b 54 24 28	 mov	 edx, DWORD PTR _param$[esp+16]
  00173	8b 44 24 24	 mov	 eax, DWORD PTR _entry$[esp+16]
  00177	55		 push	 ebp
  00178	52		 push	 edx
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 _Context_initial

; 981  :     _nstrcpy(proc->proc_name,name,11);              /*  复制进程名称        */

  0017f	8b 4c 24 24	 mov	 ecx, DWORD PTR _name$[esp+28]
  00183	6a 0b		 push	 11			; 0000000bH
  00185	51		 push	 ecx
  00186	8d 56 14	 lea	 edx, DWORD PTR [esi+20]
  00189	52		 push	 edx
  0018a	8b f8		 mov	 edi, eax
  0018c	e8 00 00 00 00	 call	 __nstrcpy

; 982  :     proc->proc_sched_prev           = NULL;
; 983  :     proc->proc_sched_next           = NULL;
; 984  :     proc->proc_wait                 = NULL;
; 985  :     proc->proc_sp                   = sp;
; 986  :     proc->proc_stack_size           = stacksize;

  00191	8b 44 24 48	 mov	 eax, DWORD PTR _stacksize$[esp+40]

; 987  :     proc->proc_stack_bottom         = STACK_BOTTOM(stack,stacksize);
; 988  :     proc->proc_stat                 = PROC_STAT_RUN;
; 989  :     proc->proc_cpu_time             = proc_cpu_time;
; 990  :     proc->proc_priority             = PROC_SAFE_PRIORITY(priority) ;

  00195	8a 4c 24 34	 mov	 cl, BYTE PTR _priority$[esp+40]
  00199	2b e8		 sub	 ebp, eax
  0019b	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_cpu_time
  001a3	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 991  :     proc->proc_prio_num             = PROC_SAFE_PRIONUM(prionum);

  001a6	0f b6 44 24 38	 movzx	 eax, BYTE PTR _prionum$[esp+40]
  001ab	80 e1 3f	 and	 cl, 63			; 0000003fH
  001ae	88 4e 4d	 mov	 BYTE PTR [esi+77], cl
  001b1	99		 cdq
  001b2	b9 06 00 00 00	 mov	 ecx, 6
  001b7	f7 f9		 idiv	 ecx

; 992  :     proc->proc_sched_factor         = 0;
; 993  :     proc->proc_signal_map           = 0;
; 994  : #ifdef _CFG_SIGNAL_ENABLE_
; 995  :     Proc_signal_initial(proc);
; 996  : #endif  /*  _CFG_SIGNAL_ENABLE_ */
; 997  : #ifdef _CFG_PROC_USER_EXT_
; 998  :     Proc_create_ue_initial(&proc->proc_user_ext);
; 999  : #endif  /* _CFG_PROC_USER_EXT_  */
; 1000 :     hnd = Koum_add(proc,Proc_release,kot_proc,HANDLE_ATTR_RDWR);

  001b9	6a 03		 push	 3
  001bb	6a 01		 push	 1
  001bd	68 00 00 00 00	 push	 OFFSET _Proc_release
  001c2	56		 push	 esi
  001c3	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  001c6	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  001c9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  001cc	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  001cf	89 6e 20	 mov	 DWORD PTR [esi+32], ebp
  001d2	c6 46 4e 01	 mov	 BYTE PTR [esi+78], 1
  001d6	89 5e 44	 mov	 DWORD PTR [esi+68], ebx
  001d9	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  001dc	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _proc_priority_number[edx]
  001e2	88 56 4c	 mov	 BYTE PTR [esi+76], dl
  001e5	e8 00 00 00 00	 call	 _Koum_add
  001ea	8b f8		 mov	 edi, eax
  001ec	83 c4 2c	 add	 esp, 44			; 0000002cH

; 1001 :     /*
; 1002 :      *  加入KOUM不成功，则要释放已分配到的进程对象
; 1003 :      */
; 1004 :     if( INVALID_HANDLE == hnd )

  001ef	3b fb		 cmp	 edi, ebx
  001f1	75 1f		 jne	 SHORT $LN8@Proc_creat

; 1005 :     {
; 1006 :         CRITICAL_BEGIN();

  001f3	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 1007 :         _memzero(proc,sizeof(proc_t));

  001f8	6a 54		 push	 84			; 00000054H
  001fa	56		 push	 esi
  001fb	8b d8		 mov	 ebx, eax
  001fd	e8 00 00 00 00	 call	 __memzero

; 1008 :         CRITICAL_END();

  00202	53		 push	 ebx
  00203	e8 00 00 00 00	 call	 _Cpu_psw_set
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1013 :         PROC_NEED_SCHED();
; 1014 :     }
; 1015 : proc_create_end:
; 1016 :     return hnd;

  0020b	8b c7		 mov	 eax, edi
  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	5d		 pop	 ebp
  00210	5b		 pop	 ebx

; 1017 : }

  00211	c3		 ret	 0
$LN8@Proc_creat:

; 1009 :     }
; 1010 :     else
; 1011 :     {
; 1012 :         Sched_add(proc);

  00212	56		 push	 esi
  00213	e8 00 00 00 00	 call	 _Sched_add
  00218	83 c4 04	 add	 esp, 4

; 1013 :         PROC_NEED_SCHED();
; 1014 :     }
; 1015 : proc_create_end:
; 1016 :     return hnd;

  0021b	8b c7		 mov	 eax, edi
  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi
  0021f	5d		 pop	 ebp
  00220	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
  0022a	5b		 pop	 ebx

; 1017 : }

  0022b	c3		 ret	 0
_Proc_create ENDP
_TEXT	ENDS
PUBLIC	_Proc_sched
EXTRN	_Proc_switch_to:PROC
EXTRN	_Proc_sched_msg:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Proc_sched
_TEXT	SEGMENT
_next$ = -4						; size = 4
_refresh$ = 8						; size = 4
_Proc_sched PROC					; COMDAT

; 1137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1138 :     proc_t        * temp    = NULL,       /*  优先级列表循环算子     */
; 1139 :                   * next    = NULL;       /*  下一个需要运行的进程   */
; 1140 :     int             prio    = 0;
; 1141 :     CRITICAL_DECLARE(proc_rspl_lock);
; 1142 : 
; 1143 : #ifdef _CFG_DEBUG_
; 1144 :     Proc_sched_msg(NULL,NULL);

  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	e8 00 00 00 00	 call	 _Proc_sched_msg
  0000f	83 c4 08	 add	 esp, 8

; 1145 : #endif  /*  _CFG_DEBUG_ */
; 1146 : 
; 1147 :     /*
; 1148 :      *  不能在处理中断时调度，
; 1149 :      *  但确实需要调度，因此采用想系统发出调度请求的方式来处理。
; 1150 :      */
; 1151 :     if( interrupt_nest || proc_current->proc_seize )

  00012	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _interrupt_nest, 0
  00019	0f 85 e7 00 00
	00		 jne	 $LN24@Proc_sched
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00024	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00027	85 c9		 test	 ecx, ecx
  00029	0f 85 d7 00 00
	00		 jne	 $LN24@Proc_sched

; 1154 :         return ;
; 1155 :     }
; 1156 : 
; 1157 :     /*
; 1158 :      *    这里涉及进程查找，如果是采用了关中断的CSPF，需要注意其关中断的时间
; 1159 :      */
; 1160 :     CRITICAL_BEGIN();

  0002f	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 1161 :     /*
; 1162 :      *  调度前，首先刷新进程调度因子，已经遍历了一次进程池
; 1163 :      *  在实时性要求高的情况下，不应该刷新调度因子。而应该直接进入调度，
; 1164 :      */
; 1165 :     if( PROC_REFRESH_SCHED_FACTOR == refresh )

  00034	83 7d 08 01	 cmp	 DWORD PTR _refresh$[ebp], 1
  00038	8b f8		 mov	 edi, eax
  0003a	75 05		 jne	 SHORT $LN18@Proc_sched

; 1166 :         Proc_refresh_sched_factor();

  0003c	e8 00 00 00 00	 call	 _Proc_refresh_sched_factor
$LN18@Proc_sched:

; 1167 : 
; 1168 :     /*
; 1169 :      *  注意: 
; 1170 :      *      采用折半查找的方法来查找存在进程的最高优先级。这里引入了优先级位
; 1171 :      *  图，对应位为1，就表示这个优先级存在进程。
; 1172 :      *      首先比较前32个优先级，方法是对表示前32个优先级的两个16位位图进行或
; 1173 :      *  运算，如果结果不为零，就表示前32个优先级中存在进程。然后再最前的16个优
; 1174 :      *  先级进行检测，方法是检测其位图是否不为0，如果不为0，则优先级从0开始查
; 1175 :      *  找。其余情况类似。
; 1176 :      */
; 1177 : 	if( proc_prio_map[0] | proc_prio_map[1] )

  00041	66 8b 15 02 00
	00 00		 mov	 dx, WORD PTR _proc_prio_map+2
  00048	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _proc_prio_map
  0004f	66 0b d1	 or	 dx, cx
  00052	74 0d		 je	 SHORT $LN17@Proc_sched

; 1178 :     {
; 1179 :         if( proc_prio_map[0] )  prio =  0;

  00054	66 f7 d9	 neg	 cx
  00057	1b c9		 sbb	 ecx, ecx
  00059	83 e1 f0	 and	 ecx, -16		; fffffff0H
  0005c	83 c1 10	 add	 ecx, 16			; 00000010H

; 1180 :         else	                prio = 16;
; 1181 :     }
; 1182 :     else

  0005f	eb 12		 jmp	 SHORT $LN13@Proc_sched
$LN17@Proc_sched:

; 1183 :     {
; 1184 :         if( proc_prio_map[2] )	prio = 32;

  00061	66 8b 0d 04 00
	00 00		 mov	 cx, WORD PTR _proc_prio_map+4
  00068	66 f7 d9	 neg	 cx
  0006b	1b c9		 sbb	 ecx, ecx
  0006d	83 e1 f0	 and	 ecx, -16		; fffffff0H
  00070	83 c1 30	 add	 ecx, 48			; 00000030H
$LN13@Proc_sched:

; 1185 :         else                    prio = 48;
; 1186 :     }
; 1187 : 
; 1188 :     /*
; 1189 :      *    到达这里，说明位图不为0。进一步检测位图的低8位，如果低8位为0，表示高8
; 1190 :      *  位不为0，可以进一步缩小优先级的查找范围
; 1191 :      */
; 1192 :     if( !(proc_prio_map[ prio / 16 ] & 0x00FF ) ) 

  00073	8b c1		 mov	 eax, ecx
  00075	99		 cdq
  00076	83 e2 0f	 and	 edx, 15			; 0000000fH
  00079	03 c2		 add	 eax, edx
  0007b	c1 f8 04	 sar	 eax, 4
  0007e	80 3c 45 00 00
	00 00 00	 cmp	 BYTE PTR _proc_prio_map[eax*2], 0
  00086	75 03		 jne	 SHORT $LN29@Proc_sched

; 1193 :         prio += 8;

  00088	83 c1 08	 add	 ecx, 8
$LN29@Proc_sched:

; 1194 : 
; 1195 :     /*
; 1196 :      *    通过之前的查找，可以将扫描数量控制在8个以内。通过查看生成的汇编代码，
; 1197 :      *  查找到存在进程优先级，总共大约需要执行90条指令。
; 1198 :      */
; 1199 :     while( prio <= 64 )

  0008b	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0008e	7f 12		 jg	 SHORT $LN31@Proc_sched
$LL10@Proc_sched:

; 1200 :     {
; 1201 :         if( proc_rspl[prio] )

  00090	83 3c 8d 00 00
	00 00 00	 cmp	 DWORD PTR _proc_rspl[ecx*4], 0
  00098	75 08		 jne	 SHORT $LN31@Proc_sched

; 1202 :             break;
; 1203 :         prio++;

  0009a	83 c1 01	 add	 ecx, 1
  0009d	83 f9 40	 cmp	 ecx, 64			; 00000040H
  000a0	7e ee		 jle	 SHORT $LL10@Proc_sched
$LN31@Proc_sched:

; 1204 :     }
; 1205 : 
; 1206 :     next = proc_rspl[prio];

  000a2	8b 34 8d 00 00
	00 00		 mov	 esi, DWORD PTR _proc_rspl[ecx*4]

; 1207 :     temp = next->proc_sched_next;

  000a9	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 1208 : 
; 1209 :     /*
; 1210 :      *  挑选出调度因子最高的进程
; 1211 :      *    由于调度因子可变，因此这里只能采用顺序遍历的方式来查找。如果要保证
; 1212 :      *  实时性，那应控制每个优先级中的进程数量。建议最好不要超过8个。
; 1213 :      *    如果按每个优先级有8个进程，查找进程总共需要执行90条指令。与前面超找
; 1214 :      *  优先级的90条指令相加，找到下一个运行的进程总共需要执行180条指令。对于
; 1215 :      *  50MHz的CPU，按每条指令需要3个始终周期计算，假设没有流水线技术，则总共
; 1216 :      *  耗时：
; 1217 :      *          180 * 3 / 50M = 0.0000108 (秒) = 10.8 (微秒)
; 1218 :      *    如果做适当的优化，比如把重要任务的优先级安排在8的整数倍上，每个优先
; 1219 :      *  级只安排1-3个进程，这样总共需要执行的指令大约为50条，则总共耗时：
; 1220 :      *          50 * 3 / 50M = 0.000003 (秒) = 3 (微秒)
; 1221 :      *    已经足够快了，因此没有在研究更快的算法。
; 1222 :      */
; 1223 :     while(temp)

  000ac	85 c0		 test	 eax, eax
  000ae	89 75 fc	 mov	 DWORD PTR _next$[ebp], esi
  000b1	74 14		 je	 SHORT $LN6@Proc_sched
$LL7@Proc_sched:

; 1224 :     {
; 1225 :         if( temp->proc_sched_factor > next->proc_sched_factor )

  000b3	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000b6	3b 4e 44	 cmp	 ecx, DWORD PTR [esi+68]
  000b9	76 02		 jbe	 SHORT $LN5@Proc_sched

; 1226 :             next = temp;

  000bb	8b f0		 mov	 esi, eax
$LN5@Proc_sched:

; 1227 :         temp = temp->proc_sched_next;

  000bd	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000c0	85 c0		 test	 eax, eax
  000c2	75 ef		 jne	 SHORT $LL7@Proc_sched

; 1226 :             next = temp;

  000c4	89 75 fc	 mov	 DWORD PTR _next$[ebp], esi
$LN6@Proc_sched:

; 1228 :     }
; 1229 : 
; 1230 :     proc_need_sched             = 0;    /*  每次调度后，都将该标志清0   */

  000c7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _proc_need_sched, 0

; 1231 :     next->proc_sched_factor     = 0;    /*  获得CPU后，调度因子清零     */

  000d1	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 1232 :     next->proc_cpu_time         = proc_cpu_time;

  000d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_cpu_time

; 1233 : 
; 1234 :     CRITICAL_END();

  000de	57		 push	 edi
  000df	89 56 50	 mov	 DWORD PTR [esi+80], edx
  000e2	e8 00 00 00 00	 call	 _Cpu_psw_set
  000e7	83 c4 04	 add	 esp, 4

; 1235 :         
; 1236 :     /*  
; 1237 :      *  挑选出的不是当前进程，则执行切换    
; 1238 :      */
; 1239 :     if( next != proc_current )                      

  000ea	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _proc_current
  000f0	74 1e		 je	 SHORT $LN1@Proc_sched

; 1240 :         PROC_SWITCH_TO(next);   

  000f2	ff 75 fc	 push	 DWORD PTR _next$[ebp]
  000f5	9c		 pushfd
  000f6	0e		 push	 cs
  000f7	e8 00 00 00 00	 call	 _Proc_switch_to
  000fc	66 83 c4 04	 add	 sp, 4

; 1241 : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c3		 ret	 0
$LN24@Proc_sched:

; 1152 :     {
; 1153 :         PROC_NEED_SCHED();

  00106	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN1@Proc_sched:

; 1241 : }

  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
_Proc_sched ENDP
_TEXT	ENDS
PUBLIC	_Proc_need_schedule
; Function compile flags: /Ogtpy
;	COMDAT _Proc_need_schedule
_TEXT	SEGMENT
_Proc_need_schedule PROC				; COMDAT

; 1259 :     PROC_NEED_SCHED();

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1

; 1260 : }

  0000a	c3		 ret	 0
_Proc_need_schedule ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@GCALCMHC@idle?5try?5to?5sleep?4?$AA@	; `string'
PUBLIC	_Proc_sleep
;	COMDAT ??_C@_0BD@GCALCMHC@idle?5try?5to?5sleep?4?$AA@
CONST	SEGMENT
??_C@_0BD@GCALCMHC@idle?5try?5to?5sleep?4?$AA@ DB 'idle try to sleep.', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_sleep
_TEXT	SEGMENT
_Proc_sleep PROC					; COMDAT

; 1278 :     /*
; 1279 :      * 系统进程进入睡眠状态，说明有错，死机
; 1280 :      */
; 1281 :     if( proc_current == proc_idle )     

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _proc_idle
  0000b	75 0d		 jne	 SHORT $LN6@Proc_sleep

; 1282 :         Sys_halt("idle try to sleep.");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GCALCMHC@idle?5try?5to?5sleep?4?$AA@
  00012	e8 00 00 00 00	 call	 _Sys_halt
  00017	83 c4 04	 add	 esp, 4
$LN6@Proc_sleep:

; 1283 :     PROC_SEIZE_DISABLE();

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00020	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00028	83 c2 01	 add	 edx, 1
  0002b	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1284 :     Sched_del(proc_current);

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 _Sched_del

; 1285 :     proc_current->proc_stat = PROC_STAT_SLEEP;

  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00040	c6 42 4e 03	 mov	 BYTE PTR [edx+78], 3

; 1286 :     PROC_SEIZE_ENABLE();

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00049	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00052	83 e9 01	 sub	 ecx, 1

; 1287 :     Proc_sched(0);

  00055	6a 00		 push	 0
  00057	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  0005a	e8 00 00 00 00	 call	 _Proc_sched
  0005f	83 c4 08	 add	 esp, 8

; 1288 : }

  00062	c3		 ret	 0
_Proc_sleep ENDP
_TEXT	ENDS
PUBLIC	_Proc_wakeup
; Function compile flags: /Ogtpy
;	COMDAT _Proc_wakeup
_TEXT	SEGMENT
_Proc_wakeup PROC					; COMDAT

; 1307 : {

  00000	55		 push	 ebp
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1308 :     proc_t        * proc        = FIRST_PROC;
; 1309 :     int             i           = 1;
; 1310 :     CRITICAL_DECLARE(proc_pool_lock);
; 1311 : 
; 1312 :     CRITICAL_BEGIN();

  00003	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00008	8b e8		 mov	 ebp, eax
  0000a	be a2 00 00 00	 mov	 esi, OFFSET _proc_pool+162
  0000f	bf 1f 00 00 00	 mov	 edi, 31			; 0000001fH
$LL12@Proc_wakeu:

; 1314 :     {
; 1315 :         if( proc->proc_entry && PROC_STAT_SLEEP == proc->proc_stat )

  00014	83 7e de 00	 cmp	 DWORD PTR [esi-34], 0
  00018	74 2c		 je	 SHORT $LN5@Proc_wakeu
  0001a	80 3e 03	 cmp	 BYTE PTR [esi], 3
  0001d	75 27		 jne	 SHORT $LN5@Proc_wakeu

; 1316 :         {
; 1317 :             proc->proc_stat = PROC_STAT_RUN ;
; 1318 :             Sched_add(proc);

  0001f	8d 46 b2	 lea	 eax, DWORD PTR [esi-78]
  00022	50		 push	 eax
  00023	c6 06 01	 mov	 BYTE PTR [esi], 1
  00026	e8 00 00 00 00	 call	 _Sched_add

; 1319 :             /*
; 1320 :              *  有更高优先级的进程，则通知系统需要进行调度
; 1321 :              */
; 1322 :             if( proc->proc_priority < proc_current->proc_priority )

  0002b	8a 4e ff	 mov	 cl, BYTE PTR [esi-1]
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00034	83 c4 04	 add	 esp, 4
  00037	3a 4a 4d	 cmp	 cl, BYTE PTR [edx+77]
  0003a	73 0a		 jae	 SHORT $LN5@Proc_wakeu

; 1323 :                 PROC_NEED_SCHED();

  0003c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN5@Proc_wakeu:

; 1313 :     for( ; i < PROC_MAX ; i++,proc++)

  00046	83 c6 54	 add	 esi, 84			; 00000054H
  00049	83 ef 01	 sub	 edi, 1
  0004c	75 c6		 jne	 SHORT $LL12@Proc_wakeu

; 1324 :         }
; 1325 :     }
; 1326 :     CRITICAL_END();

  0004e	55		 push	 ebp
  0004f	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1327 :     SCHED(0);        

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_need_sched
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c0		 test	 eax, eax
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5d		 pop	 ebp
  00061	74 08		 je	 SHORT $LN3@Proc_wakeu
  00063	6a 00		 push	 0
  00065	e8 00 00 00 00	 call	 _Proc_sched
  0006a	59		 pop	 ecx
$LN3@Proc_wakeu:

; 1328 : }

  0006b	c3		 ret	 0
_Proc_wakeup ENDP
_TEXT	ENDS
PUBLIC	_Proc_delay
EXTRN	_Machine_clock_frequency_get:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Proc_delay
_TEXT	SEGMENT
_millisecond$ = 8					; size = 4
_Proc_delay PROC					; COMDAT

; 1353 :     CRITICAL_DECLARE(proc_delay_lock);
; 1354 :     /*
; 1355 :      *  将时间转换为时钟中断次数
; 1356 :      */
; 1357 :     proc_current->proc_alarm = MILIONSECOND_TO_TICKS(millisecond);          

  00000	e8 00 00 00 00	 call	 _Machine_clock_frequency_get
  00005	0f b7 c8	 movzx	 ecx, ax
  00008	0f af 4c 24 04	 imul	 ecx, DWORD PTR _millisecond$[esp-4]
  0000d	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00012	f7 e1		 mul	 ecx
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00019	c1 ea 06	 shr	 edx, 6
  0001c	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 1358 : 
; 1359 :     if( proc_current->proc_alarm )  /*  确实需要延迟的时候，才放弃CPU   */

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	0f 84 9e 00 00
	00		 je	 $LN10@Proc_delay

; 1360 :     {
; 1361 :         /*
; 1362 :          *  只能使用禁止抢占，这里并不是保护某个公共变量，而是要求一连串的操作
; 1363 :          *  必须连续，不能切换到其他进程，但是可以处理中断。
; 1364 :          */
; 1365 :         PROC_SEIZE_DISABLE();

  0002e	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00031	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00037	83 c1 01	 add	 ecx, 1
  0003a	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 1366 :         Sched_del(proc_current);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _Sched_del
  00048	83 c4 04	 add	 esp, 4

; 1367 :         CRITICAL_BEGIN();

  0004b	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 1368 :         Proc_list_add(&proc_delay,proc_current);

  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _proc_delay, 0
  0005d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00064	75 09		 jne	 SHORT $LN14@Proc_delay
  00066	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0006d	eb 12		 jmp	 SHORT $LN18@Proc_delay
$LN14@Proc_delay:
  0006f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_delay
  00075	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_delay
  0007e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN18@Proc_delay:
  00081	89 0d 00 00 00
	00		 mov	 DWORD PTR _proc_delay, ecx
  00087	ba 00 00 00 00	 mov	 edx, OFFSET _proc_delay
  0008c	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 1369 :         proc_current->proc_wait = &proc_delay;

  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00095	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 1370 :         proc_current->proc_stat = PROC_STAT_WAIT;

  00098	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current

; 1371 :         CRITICAL_END();

  0009e	50		 push	 eax
  0009f	c6 42 4e 02	 mov	 BYTE PTR [edx+78], 2
  000a3	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1372 :         PROC_SEIZE_ENABLE();

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  000ad	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  000b6	83 c4 04	 add	 esp, 4
  000b9	83 e9 01	 sub	 ecx, 1
  000bc	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 1373 :         Proc_sched(0);

  000bf	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _millisecond$[esp-4], 0
  000c7	e9 00 00 00 00	 jmp	 _Proc_sched
$LN10@Proc_delay:

; 1374 :     }
; 1375 : }

  000cc	c3		 ret	 0
_Proc_delay ENDP
_TEXT	ENDS
PUBLIC	_Proc_signal_pid
; Function compile flags: /Ogtpy
;	COMDAT _Proc_signal_pid
_TEXT	SEGMENT
_pid$ = 8						; size = 4
_signal$ = 12						; size = 4
_Proc_signal_pid PROC					; COMDAT

; 1396 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1397 :     register proc_t     *   proc        = NULL;
; 1398 :     CRITICAL_DECLARE(proc_pool_lock);
; 1399 : 
; 1400 :     CRITICAL_BEGIN();

  00002	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00007	8b f8		 mov	 edi, eax

; 1401 : 
; 1402 :     if( NULL == (proc = Proc_get(pid)))

  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _pid$[esp+4]
  0000d	be 00 00 00 00	 mov	 esi, OFFSET _proc_pool
$LL19@Proc_signa:
  00012	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00016	74 05		 je	 SHORT $LN18@Proc_signa
  00018	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0001b	74 1a		 je	 SHORT $LN10@Proc_signa
$LN18@Proc_signa:
  0001d	83 c6 54	 add	 esi, 84			; 00000054H
  00020	81 fe 80 0a 00
	00		 cmp	 esi, OFFSET _proc_pool+2688
  00026	72 ea		 jb	 SHORT $LL19@Proc_signa

; 1403 :     {
; 1404 :         CRITICAL_END();

  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 _Cpu_psw_set
  0002e	83 c4 04	 add	 esp, 4
  00031	5f		 pop	 edi

; 1405 :         return RESULT_FAILED;

  00032	83 c8 ff	 or	 eax, -1
  00035	5e		 pop	 esi

; 1427 : }

  00036	c3		 ret	 0
$LN10@Proc_signa:

; 1406 :     }
; 1407 : 
; 1408 :     /*  置信号位图                            */
; 1409 :     proc->proc_signal_map |= PROC_MAKE_SIGNAL(signal);

  00037	8b 4c 24 10	 mov	 ecx, DWORD PTR _signal$[esp+4]
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	d3 e0		 shl	 eax, cl
  00042	09 46 3c	 or	 DWORD PTR [esi+60], eax

; 1410 : 
; 1411 :     /*
; 1412 :      *  进程处于睡眠状态，则唤醒进程
; 1413 :      */
; 1414 :     if( PROC_STAT_IS_SLEEP(proc) )

  00045	80 7e 4e 03	 cmp	 BYTE PTR [esi+78], 3
  00049	75 25		 jne	 SHORT $LN5@Proc_signa

; 1415 :     {
; 1416 :         Sched_add(proc);

  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 _Sched_add

; 1417 :         proc->proc_stat = PROC_STAT_RUN;
; 1418 :         if( proc->proc_priority < proc_current->proc_priority )

  00051	8a 4e 4d	 mov	 cl, BYTE PTR [esi+77]
  00054	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0005a	83 c4 04	 add	 esp, 4
  0005d	c6 46 4e 01	 mov	 BYTE PTR [esi+78], 1
  00061	3a 4a 4d	 cmp	 cl, BYTE PTR [edx+77]
  00064	73 0a		 jae	 SHORT $LN5@Proc_signa

; 1419 :             PROC_NEED_SCHED();    /*  有高优先级的进程进入运行态，需要切换  */

  00066	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN5@Proc_signa:

; 1420 :     }
; 1421 : 
; 1422 :     CRITICAL_END();

  00070	57		 push	 edi
  00071	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1423 : 
; 1424 :     SCHED(0);

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_need_sched
  0007b	83 c4 04	 add	 esp, 4
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN3@Proc_signa
  00082	6a 00		 push	 0
  00084	e8 00 00 00 00	 call	 _Proc_sched
  00089	83 c4 04	 add	 esp, 4
$LN3@Proc_signa:
  0008c	5f		 pop	 edi

; 1425 : 
; 1426 :     return RESULT_SUCCEED;

  0008d	33 c0		 xor	 eax, eax
  0008f	5e		 pop	 esi

; 1427 : }

  00090	c3		 ret	 0
_Proc_signal_pid ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_name
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_name
_TEXT	SEGMENT
_name$ = 8						; size = 4
_Proc_get_name PROC					; COMDAT

; 1458 : {

  00000	56		 push	 esi

; 1459 :     if( NULL == name )

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _name$[esp]
  00005	85 f6		 test	 esi, esi
  00007	75 04		 jne	 SHORT $LN6@Proc_get_n

; 1460 :         return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	5e		 pop	 esi

; 1469 : }

  0000c	c3		 ret	 0
$LN6@Proc_get_n:

; 1461 :     
; 1462 :     PROC_SEIZE_DISABLE();

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00012	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0001b	83 c1 01	 add	 ecx, 1
  0001e	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 1463 : 
; 1464 :     _strcpy(name,proc_current->proc_name);

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00026	83 c0 14	 add	 eax, 20			; 00000014H
  00029	50		 push	 eax
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 __strcpy

; 1465 : 
; 1466 :     PROC_SEIZE_ENABLE();

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00036	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0003e	83 ea 01	 sub	 edx, 1
  00041	83 c4 08	 add	 esp, 8
  00044	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 1467 : 
; 1468 :     return name;

  00047	8b c6		 mov	 eax, esi
  00049	5e		 pop	 esi

; 1469 : }

  0004a	c3		 ret	 0
_Proc_get_name ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_run_time
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_run_time
_TEXT	SEGMENT
_Proc_get_run_time PROC					; COMDAT

; 1487 :     return proc_current->proc_run_time;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	8b 40 34	 mov	 eax, DWORD PTR [eax+52]

; 1488 : }

  00008	c3		 ret	 0
_Proc_get_run_time ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_stack_size
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_stack_size
_TEXT	SEGMENT
_Proc_get_stack_size PROC				; COMDAT

; 1506 :     return proc_current->proc_stack_size;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	8b 40 24	 mov	 eax, DWORD PTR [eax+36]

; 1507 : }

  00008	c3		 ret	 0
_Proc_get_stack_size ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_pid
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_pid
_TEXT	SEGMENT
_Proc_get_pid PROC					; COMDAT

; 1525 :     return proc_current->proc_pid;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	8b 40 30	 mov	 eax, DWORD PTR [eax+48]

; 1526 : }

  00008	c3		 ret	 0
_Proc_get_pid ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_priority
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_priority
_TEXT	SEGMENT
_pid$ = 8						; size = 4
_Proc_get_priority PROC					; COMDAT

; 1545 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1546 :     byte_t                  ret     = PROC_INVALID_PRIORITY;

  00003	80 cb ff	 or	 bl, 255			; 000000ffH

; 1547 :     proc_t              *   proc    = FIRST_PROC;

  00006	be 54 00 00 00	 mov	 esi, OFFSET _proc_pool+84

; 1548 :     int                     i       = 1;

  0000b	bf 01 00 00 00	 mov	 edi, 1

; 1549 :     CRITICAL_DECLARE(proc_pool_lock);
; 1550 : 
; 1551 :     CRITICAL_BEGIN();

  00010	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00015	8b 4c 24 10	 mov	 ecx, DWORD PTR _pid$[esp+8]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL4@Proc_get_p:

; 1554 :     {
; 1555 :         if( proc->proc_entry && pid == proc->proc_pid )

  00020	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00024	74 05		 je	 SHORT $LN3@Proc_get_p
  00026	3b 4e 30	 cmp	 ecx, DWORD PTR [esi+48]
  00029	74 1a		 je	 SHORT $LN11@Proc_get_p
$LN3@Proc_get_p:

; 1552 :     
; 1553 :     for( ; i < PROC_MAX ; i++,proc++)

  0002b	83 c7 01	 add	 edi, 1
  0002e	83 c6 54	 add	 esi, 84			; 00000054H
  00031	83 ff 20	 cmp	 edi, 32			; 00000020H
  00034	7c ea		 jl	 SHORT $LL4@Proc_get_p

; 1558 :             break;
; 1559 :         }
; 1560 :     }
; 1561 :     
; 1562 :     CRITICAL_END();

  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003c	83 c4 04	 add	 esp, 4
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 1563 : 
; 1564 :     return ret;

  00041	8a c3		 mov	 al, bl
  00043	5b		 pop	 ebx

; 1565 : }

  00044	c3		 ret	 0
$LN11@Proc_get_p:

; 1556 :         {
; 1557 :             ret = proc->proc_priority;

  00045	8a 5e 4d	 mov	 bl, BYTE PTR [esi+77]

; 1558 :             break;
; 1559 :         }
; 1560 :     }
; 1561 :     
; 1562 :     CRITICAL_END();

  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _Cpu_psw_set
  0004e	83 c4 04	 add	 esp, 4
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi

; 1563 : 
; 1564 :     return ret;

  00053	8a c3		 mov	 al, bl
  00055	5b		 pop	 ebx

; 1565 : }

  00056	c3		 ret	 0
_Proc_get_priority ENDP
_TEXT	ENDS
PUBLIC	_Proc_set_priority
; Function compile flags: /Ogtpy
;	COMDAT _Proc_set_priority
_TEXT	SEGMENT
_pprio$ = -1						; size = 1
_pid$ = 8						; size = 4
_priority$ = 12						; size = 1
_Proc_set_priority PROC					; COMDAT

; 1587 : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 1588 :     byte_t          pprio       = PROC_INVALID_PRIORITY;    /*  原优先级 */

  00004	c6 44 24 0f ff	 mov	 BYTE PTR _pprio$[esp+16], 255 ; 000000ffH

; 1589 :     proc_t        * proc        = FIRST_PROC;

  00009	be 54 00 00 00	 mov	 esi, OFFSET _proc_pool+84

; 1590 :     int             i           = 1;

  0000e	bf 01 00 00 00	 mov	 edi, 1

; 1591 :     CRITICAL_DECLARE(proc_pool_lock);
; 1592 : 
; 1593 :     CRITICAL_BEGIN();

  00013	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00018	8b e8		 mov	 ebp, eax
  0001a	8b 44 24 14	 mov	 eax, DWORD PTR _pid$[esp+12]
  0001e	8b ff		 npad	 2
$LL18@Proc_set_p:

; 1596 :     {
; 1597 :         if( proc->proc_entry && pid == proc->proc_pid )

  00020	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00024	74 05		 je	 SHORT $LN17@Proc_set_p
  00026	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  00029	74 0d		 je	 SHORT $LN25@Proc_set_p
$LN17@Proc_set_p:

; 1594 : 
; 1595 :     for( ; i < PROC_MAX ;i++,proc++)

  0002b	83 c7 01	 add	 edi, 1
  0002e	83 c6 54	 add	 esi, 84			; 00000054H
  00031	83 ff 20	 cmp	 edi, 32			; 00000020H
  00034	7c ea		 jl	 SHORT $LL18@Proc_set_p

; 1598 :             break;
; 1599 :     }
; 1600 : 
; 1601 :     if( i >= PROC_MAX )

  00036	eb 54		 jmp	 SHORT $set_priority_end$2190
$LN25@Proc_set_p:
  00038	83 ff 20	 cmp	 edi, 32			; 00000020H
  0003b	7d 4f		 jge	 SHORT $set_priority_end$2190

; 1602 :         goto set_priority_end;
; 1603 : 
; 1604 :     pprio     = proc->proc_priority;

  0003d	8a 46 4d	 mov	 al, BYTE PTR [esi+77]
  00040	53		 push	 ebx

; 1605 : 
; 1606 :     /*
; 1607 :      *  优先级相同，不用调整
; 1608 :      */
; 1609 :     if( pprio == priority)

  00041	8a 5c 24 1c	 mov	 bl, BYTE PTR _priority$[esp+16]
  00045	3a c3		 cmp	 al, bl
  00047	88 44 24 13	 mov	 BYTE PTR _pprio$[esp+20], al
  0004b	74 3e		 je	 SHORT $LN29@Proc_set_p

; 1610 :         goto set_priority_end;
; 1611 : 
; 1612 :     /*
; 1613 :      *  调整优先级的步骤分为3步
; 1614 :      *  1.从原优先级列表中删除
; 1615 :      *  2.调整优先级
; 1616 :      *  3.插入新优先级列表
; 1617 :      */
; 1618 :     switch( proc->proc_stat)

  0004d	0f b6 46 4e	 movzx	 eax, BYTE PTR [esi+78]
  00051	83 e8 01	 sub	 eax, 1
  00054	74 08		 je	 SHORT $LN10@Proc_set_p

; 1629 :         break;
; 1630 :     default:
; 1631 :         proc->proc_priority = PROC_SAFE_PRIORITY(priority);

  00056	80 e3 3f	 and	 bl, 63			; 0000003fH
  00059	88 5e 4d	 mov	 BYTE PTR [esi+77], bl
  0005c	eb 2d		 jmp	 SHORT $LN29@Proc_set_p
$LN10@Proc_set_p:

; 1619 :     {
; 1620 :     case PROC_STAT_RUN:
; 1621 :         Sched_del(proc);                   

  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 _Sched_del

; 1622 : 
; 1623 :         proc->proc_priority = PROC_SAFE_PRIORITY(priority);

  00064	80 e3 3f	 and	 bl, 63			; 0000003fH

; 1624 : 
; 1625 :         Sched_add(proc);

  00067	56		 push	 esi
  00068	88 5e 4d	 mov	 BYTE PTR [esi+77], bl
  0006b	e8 00 00 00 00	 call	 _Sched_add

; 1626 : 
; 1627 :         if( proc->proc_priority < proc_current->proc_priority ) 

  00070	8a 46 4d	 mov	 al, BYTE PTR [esi+77]
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00079	83 c4 08	 add	 esp, 8
  0007c	3a 41 4d	 cmp	 al, BYTE PTR [ecx+77]
  0007f	73 0a		 jae	 SHORT $LN29@Proc_set_p

; 1628 :             PROC_NEED_SCHED();

  00081	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN29@Proc_set_p:
  0008b	5b		 pop	 ebx
$set_priority_end$2190:

; 1632 :     }
; 1633 : set_priority_end:
; 1634 : 
; 1635 :     CRITICAL_END();

  0008c	55		 push	 ebp
  0008d	e8 00 00 00 00	 call	 _Cpu_psw_set

; 1636 : 
; 1637 :     SCHED(0);

  00092	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_need_sched
  00098	83 c4 04	 add	 esp, 4
  0009b	85 d2		 test	 edx, edx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5d		 pop	 ebp
  000a0	74 0a		 je	 SHORT $LN27@Proc_set_p
  000a2	6a 00		 push	 0
  000a4	e8 00 00 00 00	 call	 _Proc_sched
  000a9	83 c4 04	 add	 esp, 4
$LN27@Proc_set_p:

; 1638 : 
; 1639 :     return pprio;

  000ac	8a 44 24 03	 mov	 al, BYTE PTR _pprio$[esp+4]

; 1640 : }

  000b0	59		 pop	 ecx
  000b1	c3		 ret	 0
_Proc_set_priority ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_prio_num
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_prio_num
_TEXT	SEGMENT
_pid$ = 8						; size = 4
_Proc_get_prio_num PROC					; COMDAT

; 1658 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 1659 :     byte_t          ret     = PROC_INVALID_PRIONUM;

  00003	80 cb ff	 or	 bl, 255			; 000000ffH

; 1660 :     proc_t        * proc    = FIRST_PROC;

  00006	be 54 00 00 00	 mov	 esi, OFFSET _proc_pool+84

; 1661 :     int             i       = 1;

  0000b	bf 01 00 00 00	 mov	 edi, 1

; 1662 :     CRITICAL_DECLARE(proc_pool_lock);
; 1663 : 
; 1664 :     CRITICAL_BEGIN();

  00010	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00015	8b 4c 24 10	 mov	 ecx, DWORD PTR _pid$[esp+8]
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL4@Proc_get_p@2:

; 1666 :     {
; 1667 :         if( proc->proc_entry && pid == proc->proc_pid )

  00020	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00024	74 05		 je	 SHORT $LN3@Proc_get_p@2
  00026	3b 4e 30	 cmp	 ecx, DWORD PTR [esi+48]
  00029	74 1a		 je	 SHORT $LN18@Proc_get_p@2
$LN3@Proc_get_p@2:

; 1665 :     for( ; i < PROC_MAX ; i++,proc++)

  0002b	83 c7 01	 add	 edi, 1
  0002e	83 c6 54	 add	 esi, 84			; 00000054H
  00031	83 ff 20	 cmp	 edi, 32			; 00000020H
  00034	7c ea		 jl	 SHORT $LL4@Proc_get_p@2

; 1670 :             break;
; 1671 :         }
; 1672 :     }
; 1673 :     CRITICAL_END();

  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003c	83 c4 04	 add	 esp, 4
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 1674 : 
; 1675 :     return ret;

  00041	8a c3		 mov	 al, bl
  00043	5b		 pop	 ebx

; 1676 : }

  00044	c3		 ret	 0
$LN18@Proc_get_p@2:
  00045	8a 56 4c	 mov	 dl, BYTE PTR [esi+76]

; 1668 :         {
; 1669 :             ret = Proc_prio_num(proc->proc_prio_num);

  00048	b9 01 00 00 00	 mov	 ecx, 1
  0004d	8d 49 00	 npad	 3
$LL13@Proc_get_p@2:
  00050	3a 91 00 00 00
	00		 cmp	 dl, BYTE PTR _proc_priority_number[ecx]
  00056	74 1a		 je	 SHORT $LN19@Proc_get_p@2
  00058	83 c1 01	 add	 ecx, 1
  0005b	83 f9 06	 cmp	 ecx, 6
  0005e	7c f0		 jl	 SHORT $LL13@Proc_get_p@2

; 1670 :             break;
; 1671 :         }
; 1672 :     }
; 1673 :     CRITICAL_END();

  00060	50		 push	 eax
  00061	80 cb ff	 or	 bl, 255			; 000000ffH
  00064	e8 00 00 00 00	 call	 _Cpu_psw_set
  00069	83 c4 04	 add	 esp, 4
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 1674 : 
; 1675 :     return ret;

  0006e	8a c3		 mov	 al, bl
  00070	5b		 pop	 ebx

; 1676 : }

  00071	c3		 ret	 0
$LN19@Proc_get_p@2:

; 1670 :             break;
; 1671 :         }
; 1672 :     }
; 1673 :     CRITICAL_END();

  00072	50		 push	 eax
  00073	8a d9		 mov	 bl, cl
  00075	e8 00 00 00 00	 call	 _Cpu_psw_set
  0007a	83 c4 04	 add	 esp, 4
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi

; 1674 : 
; 1675 :     return ret;

  0007f	8a c3		 mov	 al, bl
  00081	5b		 pop	 ebx

; 1676 : }

  00082	c3		 ret	 0
_Proc_get_prio_num ENDP
_TEXT	ENDS
PUBLIC	_Proc_set_prio_num
; Function compile flags: /Ogtpy
;	COMDAT _Proc_set_prio_num
_TEXT	SEGMENT
_pid$ = 8						; size = 4
_prionum$ = 12						; size = 1
_Proc_set_prio_num PROC					; COMDAT

; 1696 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 1697 :     byte_t                  ret     = PROC_INVALID_PRIONUM;

  00004	80 cb ff	 or	 bl, 255			; 000000ffH

; 1698 :     proc_t              *   proc    = FIRST_PROC;

  00007	be 54 00 00 00	 mov	 esi, OFFSET _proc_pool+84

; 1699 :     int                     i       = 1;

  0000c	bf 01 00 00 00	 mov	 edi, 1

; 1700 :     CRITICAL_DECLARE(proc_pool_lock);
; 1701 : 
; 1702 :     CRITICAL_BEGIN();

  00011	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00016	8b e8		 mov	 ebp, eax
  00018	8b 44 24 14	 mov	 eax, DWORD PTR _pid$[esp+12]
  0001c	8d 64 24 00	 npad	 4
$LL4@Proc_set_p@2:

; 1704 :     {
; 1705 :         if( proc->proc_entry && pid == proc->proc_pid )

  00020	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00024	74 05		 je	 SHORT $LN3@Proc_set_p@2
  00026	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  00029	74 1b		 je	 SHORT $LN18@Proc_set_p@2
$LN3@Proc_set_p@2:

; 1703 :     for( ; i < PROC_MAX ; i++,proc++)

  0002b	83 c7 01	 add	 edi, 1
  0002e	83 c6 54	 add	 esi, 84			; 00000054H
  00031	83 ff 20	 cmp	 edi, 32			; 00000020H
  00034	7c ea		 jl	 SHORT $LL4@Proc_set_p@2

; 1709 :             break;
; 1710 :         }
; 1711 :     }
; 1712 :     CRITICAL_END();

  00036	55		 push	 ebp
  00037	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003c	83 c4 04	 add	 esp, 4
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5d		 pop	 ebp

; 1713 : 
; 1714 :     return ret;

  00042	8a c3		 mov	 al, bl
  00044	5b		 pop	 ebx

; 1715 : }

  00045	c3		 ret	 0
$LN18@Proc_set_p@2:
  00046	8a 4e 4c	 mov	 cl, BYTE PTR [esi+76]

; 1706 :         {
; 1707 :             ret = Proc_prio_num(proc->proc_prio_num);

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	8b ff		 npad	 2
$LL13@Proc_set_p@2:
  00050	3a 88 00 00 00
	00		 cmp	 cl, BYTE PTR _proc_priority_number[eax]
  00056	74 31		 je	 SHORT $LN19@Proc_set_p@2
  00058	83 c0 01	 add	 eax, 1
  0005b	83 f8 06	 cmp	 eax, 6
  0005e	7c f0		 jl	 SHORT $LL13@Proc_set_p@2
  00060	80 cb ff	 or	 bl, 255			; 000000ffH
$LN14@Proc_set_p@2:

; 1708 :             proc->proc_prio_num = PROC_SAFE_PRIONUM(prionum);

  00063	0f b6 44 24 18	 movzx	 eax, BYTE PTR _prionum$[esp+12]
  00068	99		 cdq
  00069	b9 06 00 00 00	 mov	 ecx, 6
  0006e	f7 f9		 idiv	 ecx

; 1709 :             break;
; 1710 :         }
; 1711 :     }
; 1712 :     CRITICAL_END();

  00070	55		 push	 ebp
  00071	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _proc_priority_number[edx]
  00077	88 56 4c	 mov	 BYTE PTR [esi+76], dl
  0007a	e8 00 00 00 00	 call	 _Cpu_psw_set
  0007f	83 c4 04	 add	 esp, 4
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5d		 pop	 ebp

; 1713 : 
; 1714 :     return ret;

  00085	8a c3		 mov	 al, bl
  00087	5b		 pop	 ebx

; 1715 : }

  00088	c3		 ret	 0
$LN19@Proc_set_p@2:

; 1706 :         {
; 1707 :             ret = Proc_prio_num(proc->proc_prio_num);

  00089	8a d8		 mov	 bl, al
  0008b	eb d6		 jmp	 SHORT $LN14@Proc_set_p@2
_Proc_set_prio_num ENDP
_TEXT	ENDS
PUBLIC	_Proc_set_last_err
; Function compile flags: /Ogtpy
;	COMDAT _Proc_set_last_err
_TEXT	SEGMENT
_err$ = 8						; size = 4
_Proc_set_last_err PROC					; COMDAT

; 1719 :     proc_current->proc_last_err = err;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _err$[esp-4]
  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0000a	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1720 : }

  0000d	c3		 ret	 0
_Proc_set_last_err ENDP
_TEXT	ENDS
PUBLIC	_Proc_get_last_err
; Function compile flags: /Ogtpy
;	COMDAT _Proc_get_last_err
_TEXT	SEGMENT
_Proc_get_last_err PROC					; COMDAT

; 1724 :     return proc_current->proc_last_err;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00005	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 1725 : }

  00008	c3		 ret	 0
_Proc_get_last_err ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OLFPNBH@try?5to?5wakeup?5invalid?5process?6?$AA@ ; `string'
PUBLIC	_Proc_wakeup_proc
;	COMDAT ??_C@_0BP@OLFPNBH@try?5to?5wakeup?5invalid?5process?6?$AA@
CONST	SEGMENT
??_C@_0BP@OLFPNBH@try?5to?5wakeup?5invalid?5process?6?$AA@ DB 'try to wak'
	DB	'eup invalid process', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_wakeup_proc
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_Proc_wakeup_proc PROC					; COMDAT

; 382  : {

  00000	56		 push	 esi

; 383  :     /*
; 384  :      *  不能唤醒无效或者空闲对象，目前死机处理
; 385  :      */
; 386  :     if( PROC_IS_INVALID(proc) || PROC_IS_FREE(proc) )                  

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _proc$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 06		 je	 SHORT $LN11@Proc_wakeu@2
  00009	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  0000d	75 0d		 jne	 SHORT $LN12@Proc_wakeu@2
$LN11@Proc_wakeu@2:

; 387  :         Sys_halt("try to wakeup invalid process\n");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLFPNBH@try?5to?5wakeup?5invalid?5process?6?$AA@
  00014	e8 00 00 00 00	 call	 _Sys_halt
  00019	83 c4 04	 add	 esp, 4
$LN12@Proc_wakeu@2:

; 388  :         
; 389  :     if( proc->proc_stat == PROC_STAT_RUN )

  0001c	80 7e 4e 01	 cmp	 BYTE PTR [esi+78], 1
  00020	74 52		 je	 SHORT $LN2@Proc_wakeu@2
  00022	57		 push	 edi

; 390  :         return ;
; 391  : 
; 392  :     proc->proc_stat = PROC_STAT_RUN;
; 393  :     
; 394  :     if( proc->proc_wait )

  00023	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  00026	85 ff		 test	 edi, edi
  00028	c6 46 4e 01	 mov	 BYTE PTR [esi+78], 1
  0002c	74 0c		 je	 SHORT $LN9@Proc_wakeu@2

; 395  :     {
; 396  :         /*
; 397  :          *  存在隐患
; 398  :          */
; 399  :         Proc_list_del(proc->proc_wait,proc);

  0002e	e8 00 00 00 00	 call	 _Proc_list_del

; 400  :         
; 401  :         proc->proc_wait = NULL;

  00033	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN9@Proc_wakeu@2:

; 402  :     }
; 403  : 
; 404  :     Sched_add(proc);

  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 _Sched_add

; 405  : 
; 406  :     if( proc->proc_priority < proc_current->proc_priority )

  00040	8a 46 4d	 mov	 al, BYTE PTR [esi+77]
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00049	83 c4 04	 add	 esp, 4
  0004c	3a 41 4d	 cmp	 al, BYTE PTR [ecx+77]
  0004f	5f		 pop	 edi
  00050	73 0a		 jae	 SHORT $LN5@Proc_wakeu@2

; 407  :         PROC_NEED_SCHED();

  00052	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN5@Proc_wakeu@2:

; 408  :     
; 409  :     SCHED(0);        

  0005c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_need_sched
  00062	85 d2		 test	 edx, edx
  00064	74 0e		 je	 SHORT $LN2@Proc_wakeu@2
  00066	5e		 pop	 esi
  00067	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _proc$[esp-4], 0
  0006f	e9 00 00 00 00	 jmp	 _Proc_sched
$LN2@Proc_wakeu@2:
  00074	5e		 pop	 esi

; 410  : }

  00075	c3		 ret	 0
_Proc_wakeup_proc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HEIMIMFL@parameter?5error?5or?5has?5process?5w@ ; `string'
PUBLIC	_Proc_wait
;	COMDAT ??_C@_0CI@HEIMIMFL@parameter?5error?5or?5has?5process?5w@
CONST	SEGMENT
??_C@_0CI@HEIMIMFL@parameter?5error?5or?5has?5process?5w@ DB 'parameter e'
	DB	'rror or has process wait on!', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_wait
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_Proc_wait PROC						; COMDAT

; 572  : {

  00000	56		 push	 esi

; 573  :     /*
; 574  :      *  如果已经有进程在对象上等待，系统逻辑存在错误，死机
; 575  :      */
; 576  :     if( NULL == proc || *proc )

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _proc$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 05		 je	 SHORT $LN7@Proc_wait
  00009	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000c	74 0d		 je	 SHORT $LN8@Proc_wait
$LN7@Proc_wait:

; 577  :         Sys_halt("parameter error or has process wait on!");

  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HEIMIMFL@parameter?5error?5or?5has?5process?5w@
  00013	e8 00 00 00 00	 call	 _Sys_halt
  00018	83 c4 04	 add	 esp, 4
$LN8@Proc_wait:

; 578  :     *proc = proc_current;

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00020	89 06		 mov	 DWORD PTR [esi], eax

; 579  :     /*
; 580  :      *  保证操作连续，在SMP条件下并不能保证互斥。
; 581  :      */
; 582  :     PROC_SEIZE_DISABLE();

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00028	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00030	83 c2 01	 add	 edx, 1
  00033	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 583  :     Sched_del(proc_current);    /*  已经包含临界段控制      */

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 _Sched_del

; 584  :     proc_current->proc_stat = PROC_STAT_WAIT;

  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00048	c6 42 4e 02	 mov	 BYTE PTR [edx+78], 2

; 585  :     PROC_SEIZE_ENABLE();

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00051	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00054	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  0005a	83 c4 04	 add	 esp, 4
  0005d	83 e9 01	 sub	 ecx, 1
  00060	89 4a 48	 mov	 DWORD PTR [edx+72], ecx
  00063	5e		 pop	 esi

; 586  :     Proc_sched(0);

  00064	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _proc$[esp-4], 0
  0006c	e9 00 00 00 00	 jmp	 _Proc_sched
_Proc_wait ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@KPCPPLM@process?5resume?5error?$CB?$AA@ ; `string'
PUBLIC	_Proc_resume
;	COMDAT ??_C@_0BG@KPCPPLM@process?5resume?5error?$CB?$AA@
CONST	SEGMENT
??_C@_0BG@KPCPPLM@process?5resume?5error?$CB?$AA@ DB 'process resume erro'
	DB	'r!', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_resume
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_Proc_resume PROC					; COMDAT

; 606  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 607  :     proc_t        * p   = NULL;
; 608  : 
; 609  :     if( NULL == proc || NULL == (p = *proc) )

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _proc$[esp+4]
  00006	33 f6		 xor	 esi, esi
  00008	85 ff		 test	 edi, edi
  0000a	74 06		 je	 SHORT $LN17@Proc_resum@3
  0000c	8b 37		 mov	 esi, DWORD PTR [edi]
  0000e	85 f6		 test	 esi, esi
  00010	75 0d		 jne	 SHORT $LN18@Proc_resum@3
$LN17@Proc_resum@3:

; 610  :         Sys_halt("process resume error!");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KPCPPLM@process?5resume?5error?$CB?$AA@
  00017	e8 00 00 00 00	 call	 _Sys_halt
  0001c	83 c4 04	 add	 esp, 4
$LN18@Proc_resum@3:

; 611  :     /*
; 612  :      *  不是等待状态或者在其他对象上等待      
; 613  :      */
; 614  :     if( PROC_STAT_WAIT != p->proc_stat || p->proc_wait  )

  0001f	80 7e 4e 02	 cmp	 BYTE PTR [esi+78], 2
  00023	75 72		 jne	 SHORT $LN2@Proc_resum@3
  00025	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  00029	75 6c		 jne	 SHORT $LN2@Proc_resum@3

; 615  :         return ;
; 616  :     PROC_SEIZE_DISABLE();

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  00030	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00039	83 c1 01	 add	 ecx, 1
  0003c	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 617  :     Sched_add(p);    /*  已经包含临界段控制      */

  0003f	56		 push	 esi
  00040	e8 00 00 00 00	 call	 _Sched_add

; 618  :     p->proc_stat = PROC_STAT_RUN;

  00045	c6 46 4e 01	 mov	 BYTE PTR [esi+78], 1

; 619  :     PROC_SEIZE_ENABLE();

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0004e	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00051	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_current
  00057	83 e9 01	 sub	 ecx, 1
  0005a	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 620  :     if( p->proc_priority < proc_current->proc_priority )

  0005d	8a 46 4d	 mov	 al, BYTE PTR [esi+77]
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00066	83 c4 04	 add	 esp, 4
  00069	3a 41 4d	 cmp	 al, BYTE PTR [ecx+77]
  0006c	73 0a		 jae	 SHORT $LN5@Proc_resum@3

; 621  :         PROC_NEED_SCHED();

  0006e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _proc_need_sched, 1
$LN5@Proc_resum@3:

; 622  :     *proc = NULL;

  00078	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 623  :     SCHED(0);

  0007e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _proc_need_sched
  00084	85 d2		 test	 edx, edx
  00086	74 0f		 je	 SHORT $LN2@Proc_resum@3
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _proc$[esp-4], 0
  00092	e9 00 00 00 00	 jmp	 _Proc_sched
$LN2@Proc_resum@3:
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi

; 624  : }

  00099	c3		 ret	 0
_Proc_resume ENDP
_TEXT	ENDS
PUBLIC	_Proc_exit
; Function compile flags: /Ogtpy
;	COMDAT _Proc_exit
_TEXT	SEGMENT
_code$ = 8						; size = 4
_Proc_exit PROC						; COMDAT

; 1036 : {

  00000	56		 push	 esi

; 1037 :     CRITICAL_DECLARE(proc_pool_lock);
; 1038 : 
; 1039 :     CRITICAL_BEGIN();

  00001	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00006	8b f0		 mov	 esi, eax

; 1040 :     Sched_del(proc_current);    /*  从调度列表中删除进程    */

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR _proc_current
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _Sched_del

; 1041 :     _memzero(proc_current,sizeof(proc_t));

  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _proc_current
  00019	6a 54		 push	 84			; 00000054H
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 __memzero

; 1042 :     CRITICAL_END();

  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 _Cpu_psw_set
  00027	83 c4 10	 add	 esp, 16			; 00000010H
  0002a	5e		 pop	 esi

; 1043 :     Proc_sched(0);

  0002b	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _code$[esp-4], 0
  00033	e9 00 00 00 00	 jmp	 _Proc_sched
_Proc_exit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@ ; `string'
PUBLIC	_Proc_kill
EXTRN	_Koum_handle_object:PROC
EXTRN	_Koum_handle_type:PROC
;	COMDAT ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
CONST	SEGMENT
??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@ DB 'INVALID_HAND'
	DB	'LE != handle', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Proc_kill
_TEXT	SEGMENT
_handle$ = 8						; size = 4
_Proc_kill PROC						; COMDAT

; 1065 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 1066 :     proc_t        * proc        = FIRST_PROC;
; 1067 :     result_t        result      = RESULT_SUCCEED;
; 1068 :     int             i           = 1;
; 1069 :     CRITICAL_DECLARE(proc_pool_lock);
; 1070 : 
; 1071 :     ASSERT( INVALID_HANDLE != handle);

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _handle$[esp+4]
  00006	33 db		 xor	 ebx, ebx
  00008	85 f6		 test	 esi, esi
  0000a	75 2b		 jne	 SHORT $LN12@Proc_kill
  0000c	68 2f 04 00 00	 push	 1071			; 0000042fH
  00011	68 00 00 00 00	 push	 OFFSET ??_C@_06IGODLHJP@proc?4c?$AA@
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@OHCLPFHE@INVALID_HANDLE?5?$CB?$DN?5handle?$AA@
  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NFBECFLL@assert?3?5?$CFs?5?6file?3?5?$CFs?6line?5?3?5?$CFd?6?$AA@
  00020	e8 00 00 00 00	 call	 __printf
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GNOLGLLG@assert?5failed?$AA@
  0002a	e8 00 00 00 00	 call	 _Sys_halt
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	5e		 pop	 esi

; 1072 :     if( INVALID_HANDLE == handle )
; 1073 :         return result;

  00033	33 c0		 xor	 eax, eax
  00035	5b		 pop	 ebx

; 1114 : }

  00036	c3		 ret	 0
$LN12@Proc_kill:

; 1074 :     /*
; 1075 :      *  句柄类型或者句柄对象无效，函数失败
; 1076 :      */
; 1077 :     if( kot_proc != Koum_handle_type(handle) || \
; 1078 :         NULL == ( proc = Koum_handle_object(handle)) )

  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _Koum_handle_type
  0003d	83 c4 04	 add	 esp, 4
  00040	83 f8 01	 cmp	 eax, 1
  00043	0f 85 8d 00 00
	00		 jne	 $LN10@Proc_kill
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 _Koum_handle_object
  0004f	8b f0		 mov	 esi, eax
  00051	83 c4 04	 add	 esp, 4
  00054	85 f6		 test	 esi, esi
  00056	74 7e		 je	 SHORT $LN10@Proc_kill

; 1081 :         goto proc_kill_end;
; 1082 :     }
; 1083 :     /*
; 1084 :      *  杀死自身，不需要返回
; 1085 :      */
; 1086 :     if( proc == proc_current )

  00058	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _proc_current
  0005e	75 0f		 jne	 SHORT $LN8@Proc_kill

; 1087 :     {
; 1088 :         Proc_exit(1);

  00060	6a 01		 push	 1
  00062	e8 00 00 00 00	 call	 _Proc_exit
  00067	83 c4 04	 add	 esp, 4
  0006a	5e		 pop	 esi

; 1112 : proc_kill_end:
; 1113 :     return result;

  0006b	8b c3		 mov	 eax, ebx
  0006d	5b		 pop	 ebx

; 1114 : }

  0006e	c3		 ret	 0
$LN8@Proc_kill:
  0006f	57		 push	 edi

; 1089 :         /*
; 1090 :          *  实际不会执行到这里，但是为了使函数在逻辑上正确，增加了这部分代码
; 1091 :          */
; 1092 :         goto proc_kill_end;
; 1093 :     }
; 1094 :     CRITICAL_BEGIN();

  00070	e8 00 00 00 00	 call	 _Cpu_disable_interrupt
  00075	8b f8		 mov	 edi, eax

; 1095 :     /*
; 1096 :      *  找到的进程会有不同的状态，需要分类处理
; 1097 :      */
; 1098 :     switch( proc->proc_stat )

  00077	0f b6 46 4e	 movzx	 eax, BYTE PTR [esi+78]
  0007b	83 e8 01	 sub	 eax, 1
  0007e	74 36		 je	 SHORT $LN3@Proc_kill
  00080	83 e8 01	 sub	 eax, 1
  00083	74 1f		 je	 SHORT $LN2@Proc_kill
  00085	83 e8 01	 sub	 eax, 1
  00088	75 3d		 jne	 SHORT $LN4@Proc_kill

; 1103 :         break;
; 1104 :     case PROC_STAT_WAIT:
; 1105 :         result = RESULT_FAILED;
; 1106 :         break;
; 1107 :     case PROC_STAT_SLEEP:
; 1108 :         _memzero(proc,sizeof(proc_t));

  0008a	6a 54		 push	 84			; 00000054H
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 __memzero
  00092	83 c4 08	 add	 esp, 8

; 1109 :         break;
; 1110 :     }
; 1111 :     CRITICAL_END();

  00095	57		 push	 edi
  00096	e8 00 00 00 00	 call	 _Cpu_psw_set
  0009b	83 c4 04	 add	 esp, 4
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi

; 1112 : proc_kill_end:
; 1113 :     return result;

  000a0	8b c3		 mov	 eax, ebx
  000a2	5b		 pop	 ebx

; 1114 : }

  000a3	c3		 ret	 0
$LN2@Proc_kill:

; 1109 :         break;
; 1110 :     }
; 1111 :     CRITICAL_END();

  000a4	57		 push	 edi
  000a5	83 cb ff	 or	 ebx, -1
  000a8	e8 00 00 00 00	 call	 _Cpu_psw_set
  000ad	83 c4 04	 add	 esp, 4
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi

; 1112 : proc_kill_end:
; 1113 :     return result;

  000b2	8b c3		 mov	 eax, ebx
  000b4	5b		 pop	 ebx

; 1114 : }

  000b5	c3		 ret	 0
$LN3@Proc_kill:

; 1099 :     {
; 1100 :     case PROC_STAT_RUN:
; 1101 :         Sched_del(proc);        /*  从调度列表中删除进程      */

  000b6	56		 push	 esi
  000b7	e8 00 00 00 00	 call	 _Sched_del

; 1102 :         _memzero(proc,sizeof(proc_t));

  000bc	6a 54		 push	 84			; 00000054H
  000be	56		 push	 esi
  000bf	e8 00 00 00 00	 call	 __memzero
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@Proc_kill:

; 1109 :         break;
; 1110 :     }
; 1111 :     CRITICAL_END();

  000c7	57		 push	 edi
  000c8	e8 00 00 00 00	 call	 _Cpu_psw_set
  000cd	83 c4 04	 add	 esp, 4
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi

; 1112 : proc_kill_end:
; 1113 :     return result;

  000d2	8b c3		 mov	 eax, ebx
  000d4	5b		 pop	 ebx

; 1114 : }

  000d5	c3		 ret	 0
$LN10@Proc_kill:

; 1079 :     {
; 1080 :         result = RESULT_FAILED;

  000d6	83 cb ff	 or	 ebx, -1
  000d9	5e		 pop	 esi

; 1112 : proc_kill_end:
; 1113 :     return result;

  000da	8b c3		 mov	 eax, ebx
$proc_kill_end$2016:
  000dc	5b		 pop	 ebx

; 1114 : }

  000dd	c3		 ret	 0
_Proc_kill ENDP
_TEXT	ENDS
END
