; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	E:\SourcexStudio\Lenix\Lenix\src\kernel\mm.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_Heap_initial
; Function compile flags: /Ogtpy
; File e:\sourcexstudio\lenix\lenix\src\kernel\mm.c
;	COMDAT _Heap_initial
_TEXT	SEGMENT
_heap$ = 8						; size = 4
_buffer$ = 12						; size = 4
_leng$ = 16						; size = 4
_grain$ = 20						; size = 4
_Heap_initial PROC					; COMDAT

; 57   :     
; 58   :     if( heap == NULL || buffer == NULL || leng < MIN_HEAP_SIZE )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _heap$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	56		 push	 esi
  00007	74 55		 je	 SHORT $LN2@Heap_initi
  00009	8b 54 24 0c	 mov	 edx, DWORD PTR _buffer$[esp]
  0000d	85 d2		 test	 edx, edx
  0000f	74 4d		 je	 SHORT $LN2@Heap_initi
  00011	8b 74 24 10	 mov	 esi, DWORD PTR _leng$[esp]
  00015	81 fe 00 20 00
	00		 cmp	 esi, 8192		; 00002000H
  0001b	72 41		 jb	 SHORT $LN2@Heap_initi

; 60   : 
; 61   :     if( grain > 8 ) 

  0001d	8b 4c 24 14	 mov	 ecx, DWORD PTR _grain$[esp]
  00021	83 f9 08	 cmp	 ecx, 8
  00024	76 05		 jbe	 SHORT $LN1@Heap_initi

; 62   :         grain = 8;  //  控制分配单元

  00026	b9 08 00 00 00	 mov	 ecx, 8
$LN1@Heap_initi:
  0002b	57		 push	 edi

; 63   :         
; 64   :     heap->heap_grain                = MAU_SIZE * ( 1 << grain );

  0002c	bf 01 00 00 00	 mov	 edi, 1
  00031	d3 e7		 shl	 edi, cl

; 65   :     heap->heap_hmml                 = buffer;

  00033	89 10		 mov	 DWORD PTR [eax], edx

; 66   :     heap->heap_current              = heap->heap_hmml;

  00035	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 67   :     heap->heap_hmml->hmnh_next      = heap->heap_hmml;
; 68   :     heap->heap_hmml->hmnh_prev      = heap->heap_hmml;
; 69   :     heap->heap_hmml->hmnh_used      = 1;
; 70   :     heap->heap_hmml->hmnh_free      = leng / MAU_SIZE - 1;

  00038	c1 ee 04	 shr	 esi, 4
  0003b	c1 e7 04	 shl	 edi, 4
  0003e	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00041	89 12		 mov	 DWORD PTR [edx], edx
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1
  00051	8b 10		 mov	 edx, DWORD PTR [eax]
  00053	83 ee 01	 sub	 esi, 1
  00056	5f		 pop	 edi
  00057	89 72 0c	 mov	 DWORD PTR [edx+12], esi

; 71   : 
; 72   :     return RESULT_SUCCEED;

  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi

; 73   : }

  0005d	c3		 ret	 0
$LN2@Heap_initi:

; 59   :         return RESULT_FAILED;

  0005e	83 c8 ff	 or	 eax, -1
  00061	5e		 pop	 esi

; 73   : }

  00062	c3		 ret	 0
_Heap_initial ENDP
_TEXT	ENDS
PUBLIC	_Heap_alloc
EXTRN	_Cpu_psw_set:PROC
EXTRN	_Cpu_disable_interrupt:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Heap_alloc
_TEXT	SEGMENT
_heap$ = 8						; size = 4
_size$ = 12						; size = 4
_Heap_alloc PROC					; COMDAT

; 102  :     size_t                  use     = 0;            /*  需要占用的内存单元数量      */
; 103  :     hmnh_t              *   hmn     = NULL;         /*  循环算子                    */
; 104  :     hmnh_t              *   nhmn    = NULL;         /*  新的堆内存节点，new HMN     */
; 105  :     CRITICAL_DECLARE(heap->heap_lock);
; 106  : 
; 107  :     use =  HEAP_GRAIN_ALIGN(size,heap) / MAU_SIZE;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _size$[esp-4]
  00004	56		 push	 esi
  00005	8b 74 24 08	 mov	 esi, DWORD PTR _heap$[esp]
  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	57		 push	 edi
  0000d	8d 7c 08 ff	 lea	 edi, DWORD PTR [eax+ecx-1]
  00011	83 c0 ff	 add	 eax, -1
  00014	f7 d0		 not	 eax
  00016	c1 e8 04	 shr	 eax, 4
  00019	c1 ef 04	 shr	 edi, 4
  0001c	23 f8		 and	 edi, eax

; 108  : 
; 109  :     CRITICAL_BEGIN();

  0001e	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 110  :     /*
; 111  :      *  跳过小于等于所需数量
; 112  :      */
; 113  :     for(    hmn = heap->heap_current ; 
; 114  :             hmn->hmnh_next != heap->heap_current && hmn->hmnh_free <= use ; 
; 115  :             hmn = hmn->hmnh_next)

  00023	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00026	8b ce		 mov	 ecx, esi
  00028	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002a	3b d6		 cmp	 edx, esi
  0002c	74 0f		 je	 SHORT $LN2@Heap_alloc
  0002e	8b ff		 npad	 2
$LL4@Heap_alloc:
  00030	39 79 0c	 cmp	 DWORD PTR [ecx+12], edi
  00033	77 1b		 ja	 SHORT $LN1@Heap_alloc
  00035	8b ca		 mov	 ecx, edx
  00037	8b 11		 mov	 edx, DWORD PTR [ecx]
  00039	3b d6		 cmp	 edx, esi
  0003b	75 f3		 jne	 SHORT $LL4@Heap_alloc
$LN2@Heap_alloc:

; 116  :         ;
; 117  : 
; 118  :     if( hmn->hmnh_free <= use )

  0003d	39 79 0c	 cmp	 DWORD PTR [ecx+12], edi
  00040	77 0e		 ja	 SHORT $LN1@Heap_alloc

; 119  :     {
; 120  :         CRITICAL_END();

  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _Cpu_psw_set
  00048	83 c4 04	 add	 esp, 4
  0004b	5f		 pop	 edi

; 121  :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	5e		 pop	 esi

; 136  : }

  0004f	c3		 ret	 0
$LN1@Heap_alloc:

; 122  :     }
; 123  : 
; 124  :     nhmn                        = hmn + hmn->hmnh_used;

  00050	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00053	c1 e6 04	 shl	 esi, 4
  00056	03 f1		 add	 esi, ecx

; 125  :     nhmn->hmnh_used             = 1 + use;

  00058	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  0005b	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 126  :     nhmn->hmnh_free             = hmn->hmnh_free - 1 - use;

  0005e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00061	2b d7		 sub	 edx, edi
  00063	83 ea 01	 sub	 edx, 1
  00066	89 56 0c	 mov	 DWORD PTR [esi+12], edx

; 127  :     hmn->hmnh_free              = 0;
; 128  : 
; 129  :     nhmn->hmnh_next             = hmn->hmnh_next;

  00069	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  00072	89 16		 mov	 DWORD PTR [esi], edx

; 130  :     nhmn->hmnh_prev             = hmn;

  00074	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 131  :     hmn->hmnh_next->hmnh_prev   = nhmn;

  00077	8b 11		 mov	 edx, DWORD PTR [ecx]
  00079	89 72 04	 mov	 DWORD PTR [edx+4], esi

; 132  :     hmn->hmnh_next              = nhmn;
; 133  : 
; 134  :     CRITICAL_END();

  0007c	50		 push	 eax
  0007d	89 31		 mov	 DWORD PTR [ecx], esi
  0007f	e8 00 00 00 00	 call	 _Cpu_psw_set
  00084	83 c4 04	 add	 esp, 4
  00087	5f		 pop	 edi

; 135  :     return nhmn + 1;

  00088	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0008b	5e		 pop	 esi

; 136  : }

  0008c	c3		 ret	 0
_Heap_alloc ENDP
_TEXT	ENDS
PUBLIC	_Heap_free
; Function compile flags: /Ogtpy
;	COMDAT _Heap_free
_TEXT	SEGMENT
_heap$ = 8						; size = 4
___psw$ = 12						; size = 4
_m$ = 12						; size = 4
_Heap_free PROC						; COMDAT

; 165  :     hmnh_t              *   hmn         = NULL;
; 166  :     hmnh_t              *   hmnh_prev   = NULL;
; 167  :     hmnh_t              *   hmnh_free   = (hmnh_t *)m - 1;
; 168  :     CRITICAL_DECLARE(heap->heap_lock);
; 169  : 
; 170  :     if( NULL == heap || NULL == m)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _heap$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	8b 44 24 08	 mov	 eax, DWORD PTR _m$[esp-4]
  0000a	56		 push	 esi
  0000b	8d 70 f0	 lea	 esi, DWORD PTR [eax-16]
  0000e	74 2d		 je	 SHORT $LN6@Heap_free
  00010	85 c0		 test	 eax, eax
  00012	74 29		 je	 SHORT $LN6@Heap_free

; 172  :         
; 173  :     hmnh_prev   = heap->heap_hmml;

  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 174  :     hmn         = hmnh_prev->hmnh_next;

  00016	8b 01		 mov	 eax, DWORD PTR [ecx]

; 175  : 
; 176  :     for( ; hmn != heap->heap_hmml ; hmnh_prev = hmn ,hmn = hmn->hmnh_next)

  00018	3b c1		 cmp	 eax, ecx
  0001a	74 10		 je	 SHORT $LN11@Heap_free
  0001c	8d 64 24 00	 npad	 4
$LL5@Heap_free:

; 177  :     {
; 178  :         if( hmn == hmnh_free)

  00020	3b c6		 cmp	 eax, esi
  00022	74 1e		 je	 SHORT $LN1@Heap_free
  00024	8b c8		 mov	 ecx, eax
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	3b 02		 cmp	 eax, DWORD PTR [edx]
  0002a	75 f4		 jne	 SHORT $LL5@Heap_free
$LN11@Heap_free:

; 179  :             break;
; 180  :     }
; 181  : 
; 182  :     if( hmn != hmnh_free)

  0002c	3b c6		 cmp	 eax, esi
  0002e	74 12		 je	 SHORT $LN1@Heap_free

; 183  :     {
; 184  :         CRITICAL_END();

  00030	8b 44 24 0c	 mov	 eax, DWORD PTR ___psw$[esp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _Cpu_psw_set
  0003a	83 c4 04	 add	 esp, 4
$LN6@Heap_free:

; 171  :         return RESULT_FAILED;

  0003d	83 c8 ff	 or	 eax, -1
  00040	5e		 pop	 esi

; 196  : }

  00041	c3		 ret	 0
$LN1@Heap_free:

; 185  :         return RESULT_FAILED;
; 186  :     }
; 187  : 
; 188  :     hmnh_prev->hmnh_free       += hmn->hmnh_free + hmn->hmnh_used;

  00042	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00045	03 70 08	 add	 esi, DWORD PTR [eax+8]
  00048	01 71 0c	 add	 DWORD PTR [ecx+12], esi

; 189  :     hmnh_prev->hmnh_next        = hmn->hmnh_next;

  0004b	8b 30		 mov	 esi, DWORD PTR [eax]
  0004d	89 31		 mov	 DWORD PTR [ecx], esi

; 190  :     hmn->hmnh_next->hmnh_prev   = hmnh_prev;

  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 191  :  
; 192  :     heap->heap_current      = hmnh_prev;

  00054	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 193  :     
; 194  :     CRITICAL_END();

  00057	8b 4c 24 0c	 mov	 ecx, DWORD PTR ___psw$[esp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 _Cpu_psw_set
  00061	83 c4 04	 add	 esp, 4

; 195  :     return RESULT_SUCCEED;

  00064	33 c0		 xor	 eax, eax
  00066	5e		 pop	 esi

; 196  : }

  00067	c3		 ret	 0
_Heap_free ENDP
_TEXT	ENDS
PUBLIC	_Fm_initial
EXTRN	__memzero:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Fm_initial
_TEXT	SEGMENT
tv221 = -4						; size = 4
_fm$ = 8						; size = 4
_buffer$ = 12						; size = 4
_size$ = 16						; size = 4
_grain$ = 20						; size = 4
_Fm_initial PROC					; COMDAT

; 231  : {

  00000	51		 push	 ecx
  00001	55		 push	 ebp

; 232  : 
; 233  :     fsmnh_t             *   fe      = NULL;
; 234  :     byte_t              *   buf     = NULL;
; 235  :     int                     i       = 0;
; 236  : 
; 237  :     /*
; 238  :      *  管理的空间必须大于等于1024
; 239  :      */
; 240  :     if( size < 1024 )

  00002	8b 6c 24 14	 mov	 ebp, DWORD PTR _size$[esp+4]
  00006	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  0000c	73 06		 jae	 SHORT $LN7@Fm_initial

; 241  :         return RESULT_FAILED;

  0000e	83 c8 ff	 or	 eax, -1
  00011	5d		 pop	 ebp

; 278  : }

  00012	59		 pop	 ecx
  00013	c3		 ret	 0
$LN7@Fm_initial:
  00014	53		 push	 ebx
  00015	56		 push	 esi

; 242  : 
; 243  :     FM_ZERO(fm);

  00016	8b 74 24 14	 mov	 esi, DWORD PTR _fm$[esp+12]
  0001a	57		 push	 edi
  0001b	6a 20		 push	 32			; 00000020H
  0001d	56		 push	 esi
  0001e	e8 00 00 00 00	 call	 __memzero

; 244  : 
; 245  :     //  将粒度调整为64字节的整数倍，最小64字节，最大512字节
; 246  :     grain = ((grain & 7 ) + 1 ) * 64;
; 247  : #ifdef _CFG_BOUND_CHECK_
; 248  :     grain += 64;
; 249  : #endif
; 250  :     fe  = buffer;
; 251  :     buf = (byte_t *)buffer + size;

  00023	8b 54 24 24	 mov	 edx, DWORD PTR _buffer$[esp+24]
  00027	8b 44 24 2c	 mov	 eax, DWORD PTR _grain$[esp+24]
  0002b	83 e0 07	 and	 eax, 7
  0002e	8d 0c 2a	 lea	 ecx, DWORD PTR [edx+ebp]
  00031	83 c0 01	 add	 eax, 1

; 252  :     buf = (byte_t *)((uint_t  )buf & ~7); //  调整为8字节对齐，不算浪费

  00034	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00037	c1 e0 06	 shl	 eax, 6

; 253  : 
; 254  :     
; 255  :     /*  计算可以划分出的内存块数量  */
; 256  :     for( ; (uint_t  )(fe + 1) < (uint_t  )(buf - grain) ; fe++,buf -= grain)

  0003a	8b d9		 mov	 ebx, ecx
  0003c	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  0003f	2b d8		 sub	 ebx, eax
  00041	83 c4 08	 add	 esp, 8
  00044	3b fb		 cmp	 edi, ebx
  00046	89 7c 24 10	 mov	 DWORD PTR tv221[esp+20], edi
  0004a	73 1d		 jae	 SHORT $LN4@Fm_initial
  0004c	8b 6e 08	 mov	 ebp, DWORD PTR [esi+8]
  0004f	90		 npad	 1
$LL6@Fm_initial:
  00050	83 c7 04	 add	 edi, 4
  00053	2b d8		 sub	 ebx, eax

; 257  :         fm->fm_max++;

  00055	83 c5 01	 add	 ebp, 1
  00058	2b c8		 sub	 ecx, eax
  0005a	3b fb		 cmp	 edi, ebx
  0005c	72 f2		 jb	 SHORT $LL6@Fm_initial
  0005e	8b 7c 24 10	 mov	 edi, DWORD PTR tv221[esp+20]
  00062	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
  00065	8b 6c 24 20	 mov	 ebp, DWORD PTR _size$[esp+16]
$LN4@Fm_initial:

; 258  : 
; 259  :     /*  初始化对象参数  */
; 260  :     fe = buffer;
; 261  :     fm->fm_head         = fe;
; 262  :     fm->fm_tail         = fe;
; 263  :     fm->fm_free         = fm->fm_max;

  00069	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 264  :     fm->fm_size         = size;
; 265  :     fm->fm_grain        = grain;
; 266  :     fm->fm_fehead       = fe;
; 267  :     fm->fm_buffer       = buf;

  0006c	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 268  : 
; 269  :     /*  将空闲块组织成一个链表  */
; 270  :     for( fe++,i = 1 ; i < fm->fm_max ; i++,fe++)

  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	3b d9		 cmp	 ebx, ecx
  00076	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00079	89 16		 mov	 DWORD PTR [esi], edx
  0007b	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0007e	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  00081	89 6e 18	 mov	 DWORD PTR [esi+24], ebp
  00084	89 56 14	 mov	 DWORD PTR [esi+20], edx
  00087	8b c7		 mov	 eax, edi
  00089	7e 1e		 jle	 SHORT $LN1@Fm_initial
  0008b	eb 03 8d 49 00	 npad	 5
$LL3@Fm_initial:

; 271  :     {
; 272  :         fm->fm_tail->fsmnh_next     = fe;

  00090	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00093	89 02		 mov	 DWORD PTR [edx], eax

; 273  :         fm->fm_tail                 = fe;

  00095	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 274  :         fe->fsmnh_next              = NULL;

  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0009e	83 c1 01	 add	 ecx, 1
  000a1	83 c0 04	 add	 eax, 4
  000a4	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  000a7	7c e7		 jl	 SHORT $LL3@Fm_initial
$LN1@Fm_initial:
  000a9	5f		 pop	 edi
  000aa	5e		 pop	 esi
  000ab	5b		 pop	 ebx

; 275  :     }
; 276  :     
; 277  :     return RESULT_SUCCEED;

  000ac	33 c0		 xor	 eax, eax
  000ae	5d		 pop	 ebp

; 278  : }

  000af	59		 pop	 ecx
  000b0	c3		 ret	 0
_Fm_initial ENDP
_TEXT	ENDS
PUBLIC	_Fm_alloc
; Function compile flags: /Ogtpy
;	COMDAT _Fm_alloc
_TEXT	SEGMENT
_fm$ = 8						; size = 4
_Fm_alloc PROC						; COMDAT

; 307  :     fsmnh_t             *   fe      = NULL;
; 308  :     CRITICAL_DECLARE(fm->fm_lock);
; 309  : 
; 310  :     CRITICAL_BEGIN();

  00000	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 311  : 
; 312  :     if( fm->fm_free < 1 )

  00005	8b 4c 24 04	 mov	 ecx, DWORD PTR _fm$[esp-4]
  00009	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0000c	83 fa 01	 cmp	 edx, 1
  0000f	7d 0c		 jge	 SHORT $LN2@Fm_alloc

; 313  :     {
; 314  :         CRITICAL_END();

  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _Cpu_psw_set
  00017	83 c4 04	 add	 esp, 4

; 315  :         return NULL;

  0001a	33 c0		 xor	 eax, eax

; 336  : #endif  /*  _CFG_BOUND_CHECK_   */
; 337  : }

  0001c	c3		 ret	 0
$LN2@Fm_alloc:
  0001d	56		 push	 esi

; 316  :     }
; 317  : 
; 318  :     fe = fm->fm_head;

  0001e	8b 31		 mov	 esi, DWORD PTR [ecx]
  00020	57		 push	 edi

; 319  : 
; 320  :     fm->fm_head = fe->fsmnh_next;

  00021	8b 3e		 mov	 edi, DWORD PTR [esi]

; 321  :     fm->fm_free--;

  00023	83 c2 ff	 add	 edx, -1
  00026	89 39		 mov	 DWORD PTR [ecx], edi
  00028	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 322  : 
; 323  :     if( 0 == fm->fm_free )

  0002b	75 0d		 jne	 SHORT $LN1@Fm_alloc

; 324  :     {
; 325  :         fm->fm_head = NULL;

  0002d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 326  :         fm->fm_tail = NULL;

  00033	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN1@Fm_alloc:

; 327  :     }
; 328  : 
; 329  :     fe->fsmnh_ptr = FM_FETOA(fm,fe);

  0003a	8b d6		 mov	 edx, esi
  0003c	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]

; 330  : 
; 331  :     CRITICAL_END();

  0003f	50		 push	 eax
  00040	c1 fa 02	 sar	 edx, 2
  00043	0f af 51 10	 imul	 edx, DWORD PTR [ecx+16]
  00047	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  0004a	89 16		 mov	 DWORD PTR [esi], edx
  0004c	e8 00 00 00 00	 call	 _Cpu_psw_set

; 332  : #ifdef _CFG_BOUND_CHECK_
; 333  : 
; 334  : #else
; 335  :     return fe->fsmnh_ptr;

  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	83 c4 04	 add	 esp, 4
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 336  : #endif  /*  _CFG_BOUND_CHECK_   */
; 337  : }

  00058	c3		 ret	 0
_Fm_alloc ENDP
_TEXT	ENDS
PUBLIC	_Fm_free
; Function compile flags: /Ogtpy
;	COMDAT _Fm_free
_TEXT	SEGMENT
_fm$ = 8						; size = 4
_m$ = 12						; size = 4
_Fm_free PROC						; COMDAT

; 366  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 367  :     fsmnh_t             *   fe      = NULL;
; 368  :     CRITICAL_DECLARE(fm->fm_lock);
; 369  : 
; 370  :     if( NULL == fm || NULL == m )

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _fm$[esp+4]
  00006	85 f6		 test	 esi, esi
  00008	74 71		 je	 SHORT $LN6@Fm_free
  0000a	8b 5c 24 10	 mov	 ebx, DWORD PTR _m$[esp+4]
  0000e	85 db		 test	 ebx, ebx
  00010	74 69		 je	 SHORT $LN6@Fm_free

; 372  : 
; 373  :     fe = FM_ATOFE(fm,m);

  00012	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00015	8b c1		 mov	 eax, ecx
  00017	2b 46 1c	 sub	 eax, DWORD PTR [esi+28]
  0001a	33 d2		 xor	 edx, edx
  0001c	8d 44 18 ff	 lea	 eax, DWORD PTR [eax+ebx-1]
  00020	f7 f1		 div	 ecx
  00022	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 374  : 
; 375  :     /*
; 376  :      *  内存块合法性校验
; 377  :      */
; 378  :     if( fe->fsmnh_ptr != (fsmnh_t *)m )

  00025	39 1c 81	 cmp	 DWORD PTR [ecx+eax*4], ebx
  00028	57		 push	 edi
  00029	8d 3c 81	 lea	 edi, DWORD PTR [ecx+eax*4]
  0002c	74 07		 je	 SHORT $LN4@Fm_free
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 379  :         return RESULT_FAILED;

  00030	83 c8 ff	 or	 eax, -1
  00033	5b		 pop	 ebx

; 396  :         
; 397  :     CRITICAL_END();
; 398  :     return RESULT_SUCCEED;
; 399  : }

  00034	c3		 ret	 0
$LN4@Fm_free:

; 380  : 
; 381  :     CRITICAL_BEGIN();

  00035	e8 00 00 00 00	 call	 _Cpu_disable_interrupt

; 382  : 
; 383  :     if( 0 == fm->fm_free)

  0003a	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0

; 384  :     {
; 385  :         fm->fm_head    = fe;
; 386  :         fm->fm_tail    = fe;
; 387  :         fm->fm_free++;
; 388  :         CRITICAL_END();

  0003e	50		 push	 eax
  0003f	75 1a		 jne	 SHORT $LN1@Fm_free
  00041	89 3e		 mov	 DWORD PTR [esi], edi
  00043	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00046	c7 46 0c 01 00
	00 00		 mov	 DWORD PTR [esi+12], 1
  0004d	e8 00 00 00 00	 call	 _Cpu_psw_set
  00052	83 c4 04	 add	 esp, 4
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 389  :         return RESULT_SUCCEED;

  00057	33 c0		 xor	 eax, eax
  00059	5b		 pop	 ebx

; 396  :         
; 397  :     CRITICAL_END();
; 398  :     return RESULT_SUCCEED;
; 399  : }

  0005a	c3		 ret	 0
$LN1@Fm_free:

; 390  :     }
; 391  : 
; 392  :     fe->fsmnh_next              = NULL;

  0005b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 393  :     fm->fm_tail->fsmnh_next     = fe;

  00061	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00064	89 3a		 mov	 DWORD PTR [edx], edi

; 394  :     fm->fm_tail                 = fe;
; 395  :     fm->fm_free++;

  00066	83 46 0c 01	 add	 DWORD PTR [esi+12], 1
  0006a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0006d	e8 00 00 00 00	 call	 _Cpu_psw_set
  00072	83 c4 04	 add	 esp, 4
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	33 c0		 xor	 eax, eax
  00079	5b		 pop	 ebx

; 396  :         
; 397  :     CRITICAL_END();
; 398  :     return RESULT_SUCCEED;
; 399  : }

  0007a	c3		 ret	 0
$LN6@Fm_free:
  0007b	5e		 pop	 esi

; 371  :         return RESULT_FAILED;

  0007c	83 c8 ff	 or	 eax, -1
  0007f	5b		 pop	 ebx

; 396  :         
; 397  :     CRITICAL_END();
; 398  :     return RESULT_SUCCEED;
; 399  : }

  00080	c3		 ret	 0
_Fm_free ENDP
_TEXT	ENDS
END
